<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>0.5.Agentic RAG | Junhui&#39;s Journal 2</title>
<meta name="keywords" content="Agent, RAG">
<meta name="description" content="什么是 RAG
Retrieval-Augmented Generation 增强 AI 模型能力的技术框架。它通过以下方式提升 AI 的表现：

检索阶段：从外部知识库中检索与当前问题或上下文相关的文档或段落。
生成阶段：将检索到的信息与 AI 模型结合，生成更准确、更相关的输出。

RAG 技术框架实现的 AI 的作用是：

减少幻觉（Hallucination） ：通过检索外部知识，确保生成内容基于真实信息。
提升上下文理解：结合外部知识，使生成内容更符合上下文。

RAG 是一种系统。LLMs 是在庞大的数据集上进行训练以学习一般知识的。然而，它们可能没有在相关和最新的数据上进行训练。RAG 通过从您的数据中查找和检索相关信息，并将其提供给 LLM 来解决这个问题。
RAG 5个关键阶段
RAG in LlamaIndex
5阶段构成了构建的大多数更大型应用程序。

Loading:

指的是从数据所在的位置获取数据——无论是文本文件、PDF 文件、另一个网站、数据库还是 API，并将其导入到你的工作流程中。LlamaHub 提供了数百种可选择的集成。
【你应该熟悉 LlamaHub 加载器和 LlamaParse 解析器（来源于LlamaIndex 框架），以处理更复杂的数据源。】

Indexing:

创建一个允许查询数据的数据结构。对于 LLMs，这几乎总是意味着创建向量嵌入(vector embeddings)。

Storing：

一旦你的数据被索引，你将想要存储你的索引，以及其他元数据，以避免重新索引它。

Querying：

对于任何给定的索引策略，你可以利用 LLMs 和 LlamaIndex 数据结构以多种方式查询，包括子查询、多步骤查询和混合策略。

Evaluation：

什么是 Agentic RAG
Agentic RAG 是 RAG 的一种扩展形式，是进化版本，它在 RAG 的基础上引入了 AI Agent。 RAG 本身并不具备 AI Agent 的自主决策能力。">
<meta name="author" content="">
<link rel="canonical" href="https://ashburnLee.github.io/blog-2-hugo/agent/0.5.agentic-rag/">
<link crossorigin="anonymous" href="/blog-2-hugo/assets/css/stylesheet.bdaf5941cb3c05e36e857d9e2953ba0c4485ba7bc2da15db169d66a77cbc7a87.css" integrity="sha256-va9ZQcs8BeNuhX2eKVO6DESFunvC2hXbFp1mp3y8eoc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ashburnLee.github.io/blog-2-hugo/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ashburnLee.github.io/blog-2-hugo/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ashburnLee.github.io/blog-2-hugo/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ashburnLee.github.io/blog-2-hugo/apple-touch-icon.png">
<link rel="mask-icon" href="https://ashburnLee.github.io/blog-2-hugo/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://ashburnLee.github.io/blog-2-hugo/agent/0.5.agentic-rag/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" id="MathJax-script" async></script>


<meta property="og:url" content="https://ashburnLee.github.io/blog-2-hugo/agent/0.5.agentic-rag/">
  <meta property="og:site_name" content="Junhui&#39;s Journal 2">
  <meta property="og:title" content="0.5.Agentic RAG">
  <meta property="og:description" content="什么是 RAG Retrieval-Augmented Generation 增强 AI 模型能力的技术框架。它通过以下方式提升 AI 的表现：
检索阶段：从外部知识库中检索与当前问题或上下文相关的文档或段落。 生成阶段：将检索到的信息与 AI 模型结合，生成更准确、更相关的输出。 RAG 技术框架实现的 AI 的作用是：
减少幻觉（Hallucination） ：通过检索外部知识，确保生成内容基于真实信息。 提升上下文理解：结合外部知识，使生成内容更符合上下文。 RAG 是一种系统。LLMs 是在庞大的数据集上进行训练以学习一般知识的。然而，它们可能没有在相关和最新的数据上进行训练。RAG 通过从您的数据中查找和检索相关信息，并将其提供给 LLM 来解决这个问题。
RAG 5个关键阶段 RAG in LlamaIndex
5阶段构成了构建的大多数更大型应用程序。
Loading: 指的是从数据所在的位置获取数据——无论是文本文件、PDF 文件、另一个网站、数据库还是 API，并将其导入到你的工作流程中。LlamaHub 提供了数百种可选择的集成。
【你应该熟悉 LlamaHub 加载器和 LlamaParse 解析器（来源于LlamaIndex 框架），以处理更复杂的数据源。】
Indexing: 创建一个允许查询数据的数据结构。对于 LLMs，这几乎总是意味着创建向量嵌入(vector embeddings)。
Storing： 一旦你的数据被索引，你将想要存储你的索引，以及其他元数据，以避免重新索引它。
Querying： 对于任何给定的索引策略，你可以利用 LLMs 和 LlamaIndex 数据结构以多种方式查询，包括子查询、多步骤查询和混合策略。
Evaluation： 什么是 Agentic RAG Agentic RAG 是 RAG 的一种扩展形式，是进化版本，它在 RAG 的基础上引入了 AI Agent。 RAG 本身并不具备 AI Agent 的自主决策能力。">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="agent">
    <meta property="article:published_time" content="2025-08-31T12:13:26+08:00">
    <meta property="article:modified_time" content="2025-08-31T12:13:26+08:00">
    <meta property="article:tag" content="Agent">
    <meta property="article:tag" content="RAG">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="0.5.Agentic RAG">
<meta name="twitter:description" content="什么是 RAG
Retrieval-Augmented Generation 增强 AI 模型能力的技术框架。它通过以下方式提升 AI 的表现：

检索阶段：从外部知识库中检索与当前问题或上下文相关的文档或段落。
生成阶段：将检索到的信息与 AI 模型结合，生成更准确、更相关的输出。

RAG 技术框架实现的 AI 的作用是：

减少幻觉（Hallucination） ：通过检索外部知识，确保生成内容基于真实信息。
提升上下文理解：结合外部知识，使生成内容更符合上下文。

RAG 是一种系统。LLMs 是在庞大的数据集上进行训练以学习一般知识的。然而，它们可能没有在相关和最新的数据上进行训练。RAG 通过从您的数据中查找和检索相关信息，并将其提供给 LLM 来解决这个问题。
RAG 5个关键阶段
RAG in LlamaIndex
5阶段构成了构建的大多数更大型应用程序。

Loading:

指的是从数据所在的位置获取数据——无论是文本文件、PDF 文件、另一个网站、数据库还是 API，并将其导入到你的工作流程中。LlamaHub 提供了数百种可选择的集成。
【你应该熟悉 LlamaHub 加载器和 LlamaParse 解析器（来源于LlamaIndex 框架），以处理更复杂的数据源。】

Indexing:

创建一个允许查询数据的数据结构。对于 LLMs，这几乎总是意味着创建向量嵌入(vector embeddings)。

Storing：

一旦你的数据被索引，你将想要存储你的索引，以及其他元数据，以避免重新索引它。

Querying：

对于任何给定的索引策略，你可以利用 LLMs 和 LlamaIndex 数据结构以多种方式查询，包括子查询、多步骤查询和混合策略。

Evaluation：

什么是 Agentic RAG
Agentic RAG 是 RAG 的一种扩展形式，是进化版本，它在 RAG 的基础上引入了 AI Agent。 RAG 本身并不具备 AI Agent 的自主决策能力。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Agent",
      "item": "https://ashburnLee.github.io/blog-2-hugo/agent/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "0.5.Agentic RAG",
      "item": "https://ashburnLee.github.io/blog-2-hugo/agent/0.5.agentic-rag/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "0.5.Agentic RAG",
  "name": "0.5.Agentic RAG",
  "description": "什么是 RAG Retrieval-Augmented Generation 增强 AI 模型能力的技术框架。它通过以下方式提升 AI 的表现：\n检索阶段：从外部知识库中检索与当前问题或上下文相关的文档或段落。 生成阶段：将检索到的信息与 AI 模型结合，生成更准确、更相关的输出。 RAG 技术框架实现的 AI 的作用是：\n减少幻觉（Hallucination） ：通过检索外部知识，确保生成内容基于真实信息。 提升上下文理解：结合外部知识，使生成内容更符合上下文。 RAG 是一种系统。LLMs 是在庞大的数据集上进行训练以学习一般知识的。然而，它们可能没有在相关和最新的数据上进行训练。RAG 通过从您的数据中查找和检索相关信息，并将其提供给 LLM 来解决这个问题。\nRAG 5个关键阶段 RAG in LlamaIndex\n5阶段构成了构建的大多数更大型应用程序。\nLoading: 指的是从数据所在的位置获取数据——无论是文本文件、PDF 文件、另一个网站、数据库还是 API，并将其导入到你的工作流程中。LlamaHub 提供了数百种可选择的集成。\n【你应该熟悉 LlamaHub 加载器和 LlamaParse 解析器（来源于LlamaIndex 框架），以处理更复杂的数据源。】\nIndexing: 创建一个允许查询数据的数据结构。对于 LLMs，这几乎总是意味着创建向量嵌入(vector embeddings)。\nStoring： 一旦你的数据被索引，你将想要存储你的索引，以及其他元数据，以避免重新索引它。\nQuerying： 对于任何给定的索引策略，你可以利用 LLMs 和 LlamaIndex 数据结构以多种方式查询，包括子查询、多步骤查询和混合策略。\nEvaluation： 什么是 Agentic RAG Agentic RAG 是 RAG 的一种扩展形式，是进化版本，它在 RAG 的基础上引入了 AI Agent。 RAG 本身并不具备 AI Agent 的自主决策能力。\n",
  "keywords": [
    "Agent", "RAG"
  ],
  "articleBody": "什么是 RAG Retrieval-Augmented Generation 增强 AI 模型能力的技术框架。它通过以下方式提升 AI 的表现：\n检索阶段：从外部知识库中检索与当前问题或上下文相关的文档或段落。 生成阶段：将检索到的信息与 AI 模型结合，生成更准确、更相关的输出。 RAG 技术框架实现的 AI 的作用是：\n减少幻觉（Hallucination） ：通过检索外部知识，确保生成内容基于真实信息。 提升上下文理解：结合外部知识，使生成内容更符合上下文。 RAG 是一种系统。LLMs 是在庞大的数据集上进行训练以学习一般知识的。然而，它们可能没有在相关和最新的数据上进行训练。RAG 通过从您的数据中查找和检索相关信息，并将其提供给 LLM 来解决这个问题。\nRAG 5个关键阶段 RAG in LlamaIndex\n5阶段构成了构建的大多数更大型应用程序。\nLoading: 指的是从数据所在的位置获取数据——无论是文本文件、PDF 文件、另一个网站、数据库还是 API，并将其导入到你的工作流程中。LlamaHub 提供了数百种可选择的集成。\n【你应该熟悉 LlamaHub 加载器和 LlamaParse 解析器（来源于LlamaIndex 框架），以处理更复杂的数据源。】\nIndexing: 创建一个允许查询数据的数据结构。对于 LLMs，这几乎总是意味着创建向量嵌入(vector embeddings)。\nStoring： 一旦你的数据被索引，你将想要存储你的索引，以及其他元数据，以避免重新索引它。\nQuerying： 对于任何给定的索引策略，你可以利用 LLMs 和 LlamaIndex 数据结构以多种方式查询，包括子查询、多步骤查询和混合策略。\nEvaluation： 什么是 Agentic RAG Agentic RAG 是 RAG 的一种扩展形式，是进化版本，它在 RAG 的基础上引入了 AI Agent。 RAG 本身并不具备 AI Agent 的自主决策能力。\nTraditional RAG systems: 通常是静态的，检索和生成过程相对固定。例如，给定一个问题，系统会检索相关的文档片段，然后将这些片段与问题一起输入到生成模型中，生成答案。\nDynamic knowledge retrieval: 指的是可以根据当前的任务和上下文，动态地调整检索策略和知识来源。这意味着系统可以根据需要，从不同的知识库中检索信息，并根据检索结果调整后续的检索策略。\n所以 Agentic RAG 的原理是：\n自主规划： 根据用户的问题，自主地制定检索和生成策略。例如，代理可以决定先检索哪些知识库，然后根据检索结果调整后续的检索方向。 动态检索： 根据当前的任务和上下文，动态地调整检索策略和知识来源。例如，代理可以根据用户的问题，从不同的知识库中检索信息，并根据检索结果调整后续的检索策略。 迭代生成： 通过多次迭代，逐步完善生成的文本。例如，代理可以先生成一个初步的答案，然后根据用户的反馈和检索到的更多信息，对答案进行修改和完善。 比喻：传统的 RAG 就像一个固定的流水线，而 Agentic RAG 则像一个智能的探险家，能够根据环境的变化，自主地探索和发现知识。\nKAQ：关于自主规划，代理可以决定先检索哪些知识库。Agent 如何决定先检索哪些知识库？这是如何实现的？ 这不是关于 Agent 的问题，而是取决于具体的 Agentic RAG 系统设计 的具体方式。\nKAQ: 现在的AI 应用 如 devv.ai 难道不能自己处理复杂的数据源吗？需要用户使用以上工具帮你解析？ 是的。直接处理所有类型的复杂数据源仍然面临一些挑战：\n可以将 Devv.AI 看作是一个强大的 AI 引擎，而 LlamaHub 和 LlamaParse 则是 “数据燃料” 的提供者。 Devv.AI 可以使用这些 “燃料” 来驱动各种 AI 应用。所以 Devv.AI 需要处理的是用户处理过的，格式化的数据，最原始的非格式化的数据，它是不能直接处理的。\n比如场景： 用户想要使用 Devv.AI 分析一份 PDF 格式的财务报告。\n步骤 1： 用户使用 LlamaParse 解析器将 PDF 文件转换为结构化的数据，例如提取表格数据、文本数据等。 步骤 2： 用户将结构化的数据导入到 Devv.AI 中。 步骤 3： Devv.AI 使用其 AI 算法对数据进行分析，例如生成财务报告摘要、预测未来趋势等。 所以 Devv.ai 更像是套壳的 LLM。\n",
  "wordCount" : "160",
  "inLanguage": "en",
  "datePublished": "2025-08-31T12:13:26+08:00",
  "dateModified": "2025-08-31T12:13:26+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ashburnLee.github.io/blog-2-hugo/agent/0.5.agentic-rag/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Junhui's Journal 2",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ashburnLee.github.io/blog-2-hugo/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ashburnLee.github.io/blog-2-hugo/" accesskey="h" title="Junhui&#39;s Journal 2 (Alt + H)">Junhui&#39;s Journal 2</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      0.5.Agentic RAG
    </h1>
    <div class="post-meta"><span title='2025-08-31 12:13:26 +0800 CST'>August 31, 2025</span>

</div>
  </header> 
  <div class="post-content"><h2 id="什么是-rag">什么是 RAG<a hidden class="anchor" aria-hidden="true" href="#什么是-rag">#</a></h2>
<p><strong>Retrieval-Augmented Generation</strong> 增强 AI 模型能力的技术框架。它通过以下方式提升 AI 的表现：</p>
<ul>
<li>检索阶段：从<strong>外部知识库</strong>中检索与当前问题或上下文相关的文档或段落。</li>
<li>生成阶段：将检索到的信息与 AI 模型结合，生成更准确、更相关的输出。</li>
</ul>
<p>RAG 技术框架实现的 AI 的作用是：</p>
<ul>
<li>减少幻觉（Hallucination） ：通过检索外部知识，确保生成内容基于真实信息。</li>
<li>提升上下文理解：结合外部知识，使生成内容更符合上下文。</li>
</ul>
<p>RAG 是一种系统。LLMs 是在庞大的数据集上进行训练以学习一般知识的。然而，它们可能没有在相关和最新的数据上进行训练。RAG 通过从您的数据中查找和检索相关信息，并将其提供给 LLM 来解决这个问题。</p>
<h2 id="rag-5个关键阶段">RAG 5个关键阶段<a hidden class="anchor" aria-hidden="true" href="#rag-5个关键阶段">#</a></h2>
<p><a href="">RAG in LlamaIndex</a></p>
<p>5阶段构成了构建的大多数更大型应用程序。</p>
<ol>
<li>Loading:</li>
</ol>
<p>指的是从数据所在的位置获取数据——无论是文本文件、PDF 文件、另一个网站、数据库还是 API，并将其导入到你的工作流程中。LlamaHub 提供了数百种可选择的集成。</p>
<p>【你应该熟悉 LlamaHub 加载器和 LlamaParse 解析器（来源于LlamaIndex 框架），以处理更复杂的数据源。】</p>
<ol start="2">
<li>Indexing:</li>
</ol>
<p>创建一个允许查询数据的数据结构。对于 LLMs，这几乎总是意味着创建向量嵌入(vector embeddings)。</p>
<ol start="3">
<li>Storing：</li>
</ol>
<p>一旦你的数据被索引，你将想要存储你的索引，以及其他元数据，以避免重新索引它。</p>
<ol start="4">
<li>Querying：</li>
</ol>
<p>对于任何给定的索引策略，你可以利用 LLMs 和 LlamaIndex 数据结构以多种方式查询，包括子查询、多步骤查询和混合策略。</p>
<ol start="5">
<li>Evaluation：</li>
</ol>
<h2 id="什么是-agentic-rag">什么是 Agentic RAG<a hidden class="anchor" aria-hidden="true" href="#什么是-agentic-rag">#</a></h2>
<p><strong>Agentic RAG</strong> 是 RAG 的一种扩展形式，是进化版本，它在 RAG 的基础上引入了 AI Agent。 RAG 本身并不具备 AI Agent 的自主决策能力。</p>
<p>Traditional RAG systems: 通常是静态的，<strong>检索和生成过程相对固定</strong>。例如，给定一个问题，系统会检索相关的文档片段，然后将这些片段与问题一起输入到生成模型中，生成答案。</p>
<p>Dynamic knowledge retrieval: 指的是可以根据当前的任务和上下文，<strong>动态地调整检索策略和知识来源</strong>。这意味着系统可以根据需要，从不同的知识库中检索信息，并根据检索结果调整后续的检索策略。</p>
<p>所以 Agentic RAG 的原理是：</p>
<ul>
<li><strong>自主规划</strong>： 根据用户的问题，自主地制定检索和生成策略。例如，代理可以决定先检索哪些知识库，然后根据检索结果调整后续的检索方向。</li>
<li><strong>动态检索</strong>： 根据当前的任务和上下文，动态地调整检索策略和知识来源。例如，代理可以根据用户的问题，从不同的知识库中检索信息，并根据检索结果调整后续的检索策略。</li>
<li><strong>迭代生成</strong>： 通过<strong>多次迭代，逐步完善生成的文本</strong>。例如，代理可以先生成一个初步的答案，然后根据用户的反馈和检索到的更多信息，对答案进行修改和完善。</li>
</ul>
<p>比喻：传统的 RAG 就像一个<strong>固定的流水线</strong>，而 Agentic RAG 则像一个<strong>智能的探险家</strong>，能够根据环境的变化，自主地探索和发现知识。</p>
<h2 id="kaq关于自主规划代理可以决定先检索哪些知识库agent-如何决定先检索哪些知识库这是如何实现的">KAQ：关于自主规划，代理可以决定先检索哪些知识库。Agent 如何决定先检索哪些知识库？这是如何实现的？<a hidden class="anchor" aria-hidden="true" href="#kaq关于自主规划代理可以决定先检索哪些知识库agent-如何决定先检索哪些知识库这是如何实现的">#</a></h2>
<p>这不是关于 Agent 的问题，而是取决于具体的 Agentic RAG 系统设计 的具体方式。</p>
<h2 id="kaq-现在的ai-应用-如-devvai-难道不能自己处理复杂的数据源吗需要用户使用以上工具帮你解析">KAQ: 现在的AI 应用 如 devv.ai 难道不能自己处理复杂的数据源吗？需要用户使用以上工具帮你解析？<a hidden class="anchor" aria-hidden="true" href="#kaq-现在的ai-应用-如-devvai-难道不能自己处理复杂的数据源吗需要用户使用以上工具帮你解析">#</a></h2>
<p>是的。直接处理所有类型的复杂数据源仍然面临一些挑战：</p>
<p>可以将 Devv.AI 看作是一个强大的 AI 引擎，而 LlamaHub 和 LlamaParse 则是 &ldquo;数据燃料&rdquo; 的提供者。 Devv.AI 可以使用这些 &ldquo;燃料&rdquo; 来驱动各种 AI 应用。所以 Devv.AI 需要处理的是用户处理过的，格式化的数据，最原始的非格式化的数据，它是不能直接处理的。</p>
<p>比如场景： 用户想要使用 Devv.AI 分析一份 PDF 格式的财务报告。</p>
<ul>
<li>步骤 1： 用户使用 LlamaParse 解析器将 PDF 文件转换为结构化的数据，例如提取表格数据、文本数据等。</li>
<li>步骤 2： 用户将结构化的数据导入到 Devv.AI 中。</li>
<li>步骤 3： Devv.AI 使用其 AI 算法对数据进行分析，例如生成财务报告摘要、预测未来趋势等。</li>
</ul>
<p>所以 Devv.ai 更像是套壳的 LLM。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ashburnLee.github.io/blog-2-hugo/tags/agent/">Agent</a></li>
      <li><a href="https://ashburnLee.github.io/blog-2-hugo/tags/rag/">RAG</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://ashburnLee.github.io/blog-2-hugo/">Junhui&#39;s Journal 2</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
