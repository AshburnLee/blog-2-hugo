<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>3.0.LangGraph When to Use | Junhui&#39;s Journal 2</title>
<meta name="keywords" content="Agent, LangGraph, LangChain">
<meta name="description" content="可以用它创建基于 LLM/VLM 模型的应用。
LangChain VS LangGraph

LangChain 核心是将多个 LLM 调用和 tools calling 通过链 Chain 线性拼接组成有序任务序列，适合顺序性、线性流程的场景。
LangGraph 是由 LangChain 创建团队推出的一个扩展库，基于 LangChain 构建，但可独立使用。它引入了图结构（StateGraph）来管理任务流程，支持复杂的多角色 Agent 协作、有状态执行、循环分支、条件跳转等高级功能，更适合复杂、动态、带状态的多智能体协同或长期任务管理。

所以：

LangChain 适合线性任务和单智能体场景。
LangGraph 适合复杂任务、多智能体协作和状态管理场景。

LangChain
LangChain 提供了标准的接口，用于将 models 和工具和组件交互，对于检索、LLM 调用、工具调用 很有用。LangChain 中的 classes 可以与 LangGraph 一同使用。
是市场上目前最成熟的 Agent 框架。
什么时候使用 LangGraph
你再设计AI Agent时会面临 控制&amp;自由 的权衡：自由让你的 LLM 有更多空间进行创造并解决意外问题。；控制确保阿里可预测的行为和可维护。


CodeAgent 的行为非常自由，可能很难预测，它比使用 JSON 方式更不可控。


LangGraph 偏向更多的控制。如果你的应用程序涉及一系列需要以特定方式协调的步骤，并在每个交叉点做出决策，那么 LangGraph 就提供了你所需要的结构。


由于 LLM 最擅长理解文本，因此在能够回答问题之前，你需要将其他复杂模态（图表、表格）转换为文本。 ***
简单讲，如果你想根据每个 step 的输出设计之后的动作流程，并相应地决定下一步执行什么。那么 LangGraph 是正确的框架！！
LangGraph 如何工作的？
使用有向图结构来定义您的应用程序的流程。">
<meta name="author" content="">
<link rel="canonical" href="https://ashburnLee.github.io/blog-2-hugo/agent/3.0.langgraph-when-to-use/">
<link crossorigin="anonymous" href="/blog-2-hugo/assets/css/stylesheet.bdaf5941cb3c05e36e857d9e2953ba0c4485ba7bc2da15db169d66a77cbc7a87.css" integrity="sha256-va9ZQcs8BeNuhX2eKVO6DESFunvC2hXbFp1mp3y8eoc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ashburnLee.github.io/blog-2-hugo/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ashburnLee.github.io/blog-2-hugo/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ashburnLee.github.io/blog-2-hugo/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ashburnLee.github.io/blog-2-hugo/apple-touch-icon.png">
<link rel="mask-icon" href="https://ashburnLee.github.io/blog-2-hugo/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://ashburnLee.github.io/blog-2-hugo/agent/3.0.langgraph-when-to-use/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" id="MathJax-script" async></script>


<meta property="og:url" content="https://ashburnLee.github.io/blog-2-hugo/agent/3.0.langgraph-when-to-use/">
  <meta property="og:site_name" content="Junhui&#39;s Journal 2">
  <meta property="og:title" content="3.0.LangGraph When to Use">
  <meta property="og:description" content="可以用它创建基于 LLM/VLM 模型的应用。
LangChain VS LangGraph LangChain 核心是将多个 LLM 调用和 tools calling 通过链 Chain 线性拼接组成有序任务序列，适合顺序性、线性流程的场景。 LangGraph 是由 LangChain 创建团队推出的一个扩展库，基于 LangChain 构建，但可独立使用。它引入了图结构（StateGraph）来管理任务流程，支持复杂的多角色 Agent 协作、有状态执行、循环分支、条件跳转等高级功能，更适合复杂、动态、带状态的多智能体协同或长期任务管理。 所以：
LangChain 适合线性任务和单智能体场景。 LangGraph 适合复杂任务、多智能体协作和状态管理场景。 LangChain LangChain 提供了标准的接口，用于将 models 和工具和组件交互，对于检索、LLM 调用、工具调用 很有用。LangChain 中的 classes 可以与 LangGraph 一同使用。
是市场上目前最成熟的 Agent 框架。
什么时候使用 LangGraph 你再设计AI Agent时会面临 控制&amp;自由 的权衡：自由让你的 LLM 有更多空间进行创造并解决意外问题。；控制确保阿里可预测的行为和可维护。
CodeAgent 的行为非常自由，可能很难预测，它比使用 JSON 方式更不可控。
LangGraph 偏向更多的控制。如果你的应用程序涉及一系列需要以特定方式协调的步骤，并在每个交叉点做出决策，那么 LangGraph 就提供了你所需要的结构。
由于 LLM 最擅长理解文本，因此在能够回答问题之前，你需要将其他复杂模态（图表、表格）转换为文本。 ***
简单讲，如果你想根据每个 step 的输出设计之后的动作流程，并相应地决定下一步执行什么。那么 LangGraph 是正确的框架！！
LangGraph 如何工作的？ 使用有向图结构来定义您的应用程序的流程。">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="agent">
    <meta property="article:published_time" content="2025-08-31T12:13:30+08:00">
    <meta property="article:modified_time" content="2025-08-31T12:13:30+08:00">
    <meta property="article:tag" content="Agent">
    <meta property="article:tag" content="LangGraph">
    <meta property="article:tag" content="LangChain">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="3.0.LangGraph When to Use">
<meta name="twitter:description" content="可以用它创建基于 LLM/VLM 模型的应用。
LangChain VS LangGraph

LangChain 核心是将多个 LLM 调用和 tools calling 通过链 Chain 线性拼接组成有序任务序列，适合顺序性、线性流程的场景。
LangGraph 是由 LangChain 创建团队推出的一个扩展库，基于 LangChain 构建，但可独立使用。它引入了图结构（StateGraph）来管理任务流程，支持复杂的多角色 Agent 协作、有状态执行、循环分支、条件跳转等高级功能，更适合复杂、动态、带状态的多智能体协同或长期任务管理。

所以：

LangChain 适合线性任务和单智能体场景。
LangGraph 适合复杂任务、多智能体协作和状态管理场景。

LangChain
LangChain 提供了标准的接口，用于将 models 和工具和组件交互，对于检索、LLM 调用、工具调用 很有用。LangChain 中的 classes 可以与 LangGraph 一同使用。
是市场上目前最成熟的 Agent 框架。
什么时候使用 LangGraph
你再设计AI Agent时会面临 控制&amp;自由 的权衡：自由让你的 LLM 有更多空间进行创造并解决意外问题。；控制确保阿里可预测的行为和可维护。


CodeAgent 的行为非常自由，可能很难预测，它比使用 JSON 方式更不可控。


LangGraph 偏向更多的控制。如果你的应用程序涉及一系列需要以特定方式协调的步骤，并在每个交叉点做出决策，那么 LangGraph 就提供了你所需要的结构。


由于 LLM 最擅长理解文本，因此在能够回答问题之前，你需要将其他复杂模态（图表、表格）转换为文本。 ***
简单讲，如果你想根据每个 step 的输出设计之后的动作流程，并相应地决定下一步执行什么。那么 LangGraph 是正确的框架！！
LangGraph 如何工作的？
使用有向图结构来定义您的应用程序的流程。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Agent",
      "item": "https://ashburnLee.github.io/blog-2-hugo/agent/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "3.0.LangGraph When to Use",
      "item": "https://ashburnLee.github.io/blog-2-hugo/agent/3.0.langgraph-when-to-use/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "3.0.LangGraph When to Use",
  "name": "3.0.LangGraph When to Use",
  "description": "可以用它创建基于 LLM/VLM 模型的应用。\nLangChain VS LangGraph LangChain 核心是将多个 LLM 调用和 tools calling 通过链 Chain 线性拼接组成有序任务序列，适合顺序性、线性流程的场景。 LangGraph 是由 LangChain 创建团队推出的一个扩展库，基于 LangChain 构建，但可独立使用。它引入了图结构（StateGraph）来管理任务流程，支持复杂的多角色 Agent 协作、有状态执行、循环分支、条件跳转等高级功能，更适合复杂、动态、带状态的多智能体协同或长期任务管理。 所以：\nLangChain 适合线性任务和单智能体场景。 LangGraph 适合复杂任务、多智能体协作和状态管理场景。 LangChain LangChain 提供了标准的接口，用于将 models 和工具和组件交互，对于检索、LLM 调用、工具调用 很有用。LangChain 中的 classes 可以与 LangGraph 一同使用。\n是市场上目前最成熟的 Agent 框架。\n什么时候使用 LangGraph 你再设计AI Agent时会面临 控制\u0026amp;自由 的权衡：自由让你的 LLM 有更多空间进行创造并解决意外问题。；控制确保阿里可预测的行为和可维护。\nCodeAgent 的行为非常自由，可能很难预测，它比使用 JSON 方式更不可控。\nLangGraph 偏向更多的控制。如果你的应用程序涉及一系列需要以特定方式协调的步骤，并在每个交叉点做出决策，那么 LangGraph 就提供了你所需要的结构。\n由于 LLM 最擅长理解文本，因此在能够回答问题之前，你需要将其他复杂模态（图表、表格）转换为文本。 ***\n简单讲，如果你想根据每个 step 的输出设计之后的动作流程，并相应地决定下一步执行什么。那么 LangGraph 是正确的框架！！\nLangGraph 如何工作的？ 使用有向图结构来定义您的应用程序的流程。\n",
  "keywords": [
    "Agent", "LangGraph", "LangChain"
  ],
  "articleBody": "可以用它创建基于 LLM/VLM 模型的应用。\nLangChain VS LangGraph LangChain 核心是将多个 LLM 调用和 tools calling 通过链 Chain 线性拼接组成有序任务序列，适合顺序性、线性流程的场景。 LangGraph 是由 LangChain 创建团队推出的一个扩展库，基于 LangChain 构建，但可独立使用。它引入了图结构（StateGraph）来管理任务流程，支持复杂的多角色 Agent 协作、有状态执行、循环分支、条件跳转等高级功能，更适合复杂、动态、带状态的多智能体协同或长期任务管理。 所以：\nLangChain 适合线性任务和单智能体场景。 LangGraph 适合复杂任务、多智能体协作和状态管理场景。 LangChain LangChain 提供了标准的接口，用于将 models 和工具和组件交互，对于检索、LLM 调用、工具调用 很有用。LangChain 中的 classes 可以与 LangGraph 一同使用。\n是市场上目前最成熟的 Agent 框架。\n什么时候使用 LangGraph 你再设计AI Agent时会面临 控制\u0026自由 的权衡：自由让你的 LLM 有更多空间进行创造并解决意外问题。；控制确保阿里可预测的行为和可维护。\nCodeAgent 的行为非常自由，可能很难预测，它比使用 JSON 方式更不可控。\nLangGraph 偏向更多的控制。如果你的应用程序涉及一系列需要以特定方式协调的步骤，并在每个交叉点做出决策，那么 LangGraph 就提供了你所需要的结构。\n由于 LLM 最擅长理解文本，因此在能够回答问题之前，你需要将其他复杂模态（图表、表格）转换为文本。 ***\n简单讲，如果你想根据每个 step 的输出设计之后的动作流程，并相应地决定下一步执行什么。那么 LangGraph 是正确的框架！！\nLangGraph 如何工作的？ 使用有向图结构来定义您的应用程序的流程。\nNodes: 代表单个处理步骤，比如工具调用、LLM调用、条件逻辑、获取用户输入等人工干预。 Edges：定义步骤之间的可能转换 States: 由用户定义和维护，并在节点执行期间传递。在决定下一个目标节点时，我们查看的是当前状态。 LangGraph 构建模块 构成 LangGraph 的核心组件，LangGraph 中的应用程序从START开始，根据执行情况，流程可能会进入一个函数或另一个函数，直到到达 END。\n1. State State 是 LangGraph 中的核心概念，它包含了应用程序中的所有内容。它是用户定义的，用户应仔细思考应用程序在步骤之间需要跟踪哪些信息。\n2. Nodes 即 Python 函数。它将 State 作为输入，执行某些操作，并返回对状态的更新 new state。\ndef node_1(state): print(\"---Node 1---\") return {\"graph_state\": state['graph_state'] +\" I am\"} def node_2(state): print(\"---Node 2---\") return {\"graph_state\": state['graph_state'] +\" happy!\"} Nodes 可以包含LLM 调用，tools 调用，条件逻辑和人工干预。\n3. Edges Edges 连接节点并定义你的图中可能的路径。如下，Edge 根据条件返回可能的两个 Nodes 中的一个。Edge 可以是直接的可以是条件的。\nimport random from typing import Literal def decide_mood(state) -\u003e Literal[\"node_2\", \"node_3\"]: # Often, we will use state to decide on the next node to visit user_input = state['graph_state'] # Here, let's just do a 50 / 50 split between nodes 2, 3 if random.random() \u003c 0.5: # 50% of the time, we return Node 2 return \"node_2\" # 50% of the time, we return Node 3 return \"node_3\" 4. StateGraph 这是包含整个工作流的容器。以 START 开始， END 结束。\nfrom IPython.display import Image, display from langgraph.graph import StateGraph, START, END # Build graph builder = StateGraph(State) builder.add_node(\"node_1\", node_1) builder.add_node(\"node_2\", node_2) builder.add_node(\"node_3\", node_3) # 将Edge链接，传入起、始位置 builder.add_edge(START, \"node_1\") builder.add_conditional_edges(\"node_1\", decide_mood) builder.add_edge(\"node_2\", END) builder.add_edge(\"node_3\", END) # Add graph = builder.compile() # View,并且可以可视化工作流： display(Image(graph.get_graph().draw_mermaid_png())) # 最后invoke工作流 graph.invoke({\"graph_state\" : \"Hi, this is Lance.\"}) 所以 LangGraph 的最佳实战是先定义各个组件，然后组装它们。\n",
  "wordCount" : "256",
  "inLanguage": "en",
  "datePublished": "2025-08-31T12:13:30+08:00",
  "dateModified": "2025-08-31T12:13:30+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ashburnLee.github.io/blog-2-hugo/agent/3.0.langgraph-when-to-use/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Junhui's Journal 2",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ashburnLee.github.io/blog-2-hugo/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ashburnLee.github.io/blog-2-hugo/" accesskey="h" title="Junhui&#39;s Journal 2 (Alt + H)">Junhui&#39;s Journal 2</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      3.0.LangGraph When to Use
    </h1>
    <div class="post-meta"><span title='2025-08-31 12:13:30 +0800 CST'>August 31, 2025</span>

</div>
  </header> 
  <div class="post-content"><p>可以用它创建基于 LLM/VLM 模型的应用。</p>
<h1 id="langchain-vs-langgraph">LangChain VS LangGraph<a hidden class="anchor" aria-hidden="true" href="#langchain-vs-langgraph">#</a></h1>
<ul>
<li>LangChain 核心是将多个 LLM 调用和 tools calling 通过链 <strong>Chain 线性拼接</strong>组成有序任务序列，适合顺序性、线性流程的场景。</li>
<li>LangGraph 是由 LangChain 创建团队推出的一个扩展库，基于 LangChain 构建，但可独立使用。它引入了图结构（StateGraph）来管理任务流程，支持复杂的多角色 Agent 协作、有状态执行、循环分支、条件跳转等高级功能，更适合复杂、动态、带状态的多智能体协同或长期任务管理。</li>
</ul>
<p>所以：</p>
<ul>
<li>LangChain 适合线性任务和单智能体场景。</li>
<li>LangGraph 适合复杂任务、多智能体协作和状态管理场景。</li>
</ul>
<h1 id="langchain">LangChain<a hidden class="anchor" aria-hidden="true" href="#langchain">#</a></h1>
<p>LangChain 提供了标准的接口，用于将 models 和工具和组件交互，对于检索、LLM 调用、工具调用 很有用。LangChain 中的 classes 可以与 LangGraph 一同使用。</p>
<p>是市场上目前最成熟的 Agent 框架。</p>
<h1 id="什么时候使用-langgraph">什么时候使用 LangGraph<a hidden class="anchor" aria-hidden="true" href="#什么时候使用-langgraph">#</a></h1>
<p>你再设计AI Agent时会面临 <strong>控制&amp;自由</strong> 的权衡：自由让你的 LLM 有更多空间进行创造并解决意外问题。；控制确保阿里可预测的行为和可维护。</p>
<ul>
<li>
<p>CodeAgent 的行为非常自由，可能很难预测，它比使用 JSON 方式更不可控。</p>
</li>
<li>
<p>LangGraph 偏向<strong>更多的控制</strong>。如果你的应用程序<strong>涉及一系列需要以特定方式协调的步骤</strong>，并<strong>在每个交叉点做出决策</strong>，那么 LangGraph 就提供了你所需要的结构。</p>
</li>
</ul>
<p>由于 <strong>LLM 最擅长理解文本</strong>，因此在能够回答问题之前，你需要<strong>将其他复杂模态</strong>（图表、表格）转换<strong>为文本</strong>。 ***</p>
<p>简单讲，如果你想<strong>根据每个 step 的输出设计之后的动作流程，并相应地决定下一步执行什么</strong>。那么 LangGraph 是正确的框架！！</p>
<h1 id="langgraph-如何工作的">LangGraph 如何工作的？<a hidden class="anchor" aria-hidden="true" href="#langgraph-如何工作的">#</a></h1>
<p>使用有向图结构来定义您的应用程序的流程。</p>
<ul>
<li><code>Nodes</code>: 代表单个处理步骤，比如工具调用、LLM调用、条件逻辑、获取用户输入等人工干预。</li>
<li><code>Edges</code>：定义步骤之间的可能转换</li>
<li><code>States</code>: 由用户定义和维护，并在节点执行期间传递。在决定下一个目标节点时，我们查看的是当前状态。</li>
</ul>
<h2 id="langgraph-构建模块">LangGraph 构建模块<a hidden class="anchor" aria-hidden="true" href="#langgraph-构建模块">#</a></h2>
<p>构成 LangGraph 的核心组件，LangGraph 中的应用程序从<strong>START</strong>开始，根据执行情况，流程可能会进入一个函数或另一个函数，直到到达 <strong>END</strong>。</p>
<h3 id="1-state">1. State<a hidden class="anchor" aria-hidden="true" href="#1-state">#</a></h3>
<p>State 是 LangGraph 中的核心概念，它包含了应用程序中的所有内容。它是用户定义的，用户应<strong>仔细思考</strong>应用程序在步骤之间需要<strong>跟踪哪些信息</strong>。</p>
<h3 id="2-nodes">2. Nodes<a hidden class="anchor" aria-hidden="true" href="#2-nodes">#</a></h3>
<p>即 Python 函数。它将 State 作为输入，执行某些操作，并返回对状态的更新 new state。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">node_1</span>(state):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;---Node 1---&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {<span style="color:#e6db74">&#34;graph_state&#34;</span>: state[<span style="color:#e6db74">&#39;graph_state&#39;</span>] <span style="color:#f92672">+</span><span style="color:#e6db74">&#34; I am&#34;</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">node_2</span>(state):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;---Node 2---&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {<span style="color:#e6db74">&#34;graph_state&#34;</span>: state[<span style="color:#e6db74">&#39;graph_state&#39;</span>] <span style="color:#f92672">+</span><span style="color:#e6db74">&#34; happy!&#34;</span>}
</span></span></code></pre></div><p>Nodes 可以包含LLM 调用，tools 调用，条件逻辑和人工干预。</p>
<h3 id="3-edges">3. Edges<a hidden class="anchor" aria-hidden="true" href="#3-edges">#</a></h3>
<p>Edges 连接节点并定义你的图中可能的路径。如下，Edge 根据条件返回可能的两个 Nodes 中的一个。Edge 可以是直接的可以是条件的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">import</span> random
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> typing <span style="color:#f92672">import</span> Literal
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">decide_mood</span>(state) <span style="color:#f92672">-&gt;</span> Literal[<span style="color:#e6db74">&#34;node_2&#34;</span>, <span style="color:#e6db74">&#34;node_3&#34;</span>]:
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Often, we will use state to decide on the next node to visit</span>
</span></span><span style="display:flex;"><span>    user_input <span style="color:#f92672">=</span> state[<span style="color:#e6db74">&#39;graph_state&#39;</span>] 
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Here, let&#39;s just do a 50 / 50 split between nodes 2, 3</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> random<span style="color:#f92672">.</span>random() <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.5</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 50% of the time, we return Node 2</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;node_2&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 50% of the time, we return Node 3</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;node_3&#34;</span>
</span></span></code></pre></div><h3 id="4-stategraph">4. StateGraph<a hidden class="anchor" aria-hidden="true" href="#4-stategraph">#</a></h3>
<p>这是包含<strong>整个工作流的容器</strong>。以 <strong>START</strong> 开始， <strong>END</strong> 结束。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">from</span> IPython.display <span style="color:#f92672">import</span> Image, display
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> langgraph.graph <span style="color:#f92672">import</span> StateGraph, START, END
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Build graph</span>
</span></span><span style="display:flex;"><span>builder <span style="color:#f92672">=</span> StateGraph(State)
</span></span><span style="display:flex;"><span>builder<span style="color:#f92672">.</span>add_node(<span style="color:#e6db74">&#34;node_1&#34;</span>, node_1)
</span></span><span style="display:flex;"><span>builder<span style="color:#f92672">.</span>add_node(<span style="color:#e6db74">&#34;node_2&#34;</span>, node_2)
</span></span><span style="display:flex;"><span>builder<span style="color:#f92672">.</span>add_node(<span style="color:#e6db74">&#34;node_3&#34;</span>, node_3)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 将Edge链接，传入起、始位置</span>
</span></span><span style="display:flex;"><span>builder<span style="color:#f92672">.</span>add_edge(START, <span style="color:#e6db74">&#34;node_1&#34;</span>)
</span></span><span style="display:flex;"><span>builder<span style="color:#f92672">.</span>add_conditional_edges(<span style="color:#e6db74">&#34;node_1&#34;</span>, decide_mood)
</span></span><span style="display:flex;"><span>builder<span style="color:#f92672">.</span>add_edge(<span style="color:#e6db74">&#34;node_2&#34;</span>, END)
</span></span><span style="display:flex;"><span>builder<span style="color:#f92672">.</span>add_edge(<span style="color:#e6db74">&#34;node_3&#34;</span>, END)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Add</span>
</span></span><span style="display:flex;"><span>graph <span style="color:#f92672">=</span> builder<span style="color:#f92672">.</span>compile()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># View,并且可以可视化工作流：</span>
</span></span><span style="display:flex;"><span>display(Image(graph<span style="color:#f92672">.</span>get_graph()<span style="color:#f92672">.</span>draw_mermaid_png()))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 最后invoke工作流</span>
</span></span><span style="display:flex;"><span>graph<span style="color:#f92672">.</span>invoke({<span style="color:#e6db74">&#34;graph_state&#34;</span> : <span style="color:#e6db74">&#34;Hi, this is Lance.&#34;</span>})
</span></span></code></pre></div><p>所以 LangGraph 的最佳实战是<strong>先定义各个组件，然后组装它们</strong>。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ashburnLee.github.io/blog-2-hugo/tags/agent/">Agent</a></li>
      <li><a href="https://ashburnLee.github.io/blog-2-hugo/tags/langgraph/">LangGraph</a></li>
      <li><a href="https://ashburnLee.github.io/blog-2-hugo/tags/langchain/">LangChain</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://ashburnLee.github.io/blog-2-hugo/">Junhui&#39;s Journal 2</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
