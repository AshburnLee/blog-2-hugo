<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>CICD on Junhui&#39;s Journal 2</title>
    <link>https://ashburnLee.github.io/blog-2-hugo/tags/cicd/</link>
    <description>Recent content in CICD on Junhui&#39;s Journal 2</description>
    <generator>Hugo -- 0.149.0</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 31 Aug 2025 12:57:45 +0800</lastBuildDate>
    <atom:link href="https://ashburnLee.github.io/blog-2-hugo/tags/cicd/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Jenkins</title>
      <link>https://ashburnLee.github.io/blog-2-hugo/jenkins/</link>
      <pubDate>Sun, 31 Aug 2025 12:57:45 +0800</pubDate>
      <guid>https://ashburnLee.github.io/blog-2-hugo/jenkins/</guid>
      <description>&lt;h2 id=&#34;tutorial&#34;&gt;tutorial&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pipline &amp;amp; jenkinsfile 手册：https://www.jenkins.io/doc/book/pipeline/getting-started/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供的全局变量 &lt;code&gt;env.&lt;/code&gt;: &lt;code&gt;&amp;lt;Jenkins master的地址&amp;gt;/pipeline-syntax/globals#env&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pipline 实例：https://www.jenkins.io/doc/pipeline/examples/&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;尽可能应用jenkins提供的命令而不是一股脑儿使用shell脚本&#34;&gt;尽可能应用Jenkins提供的命令，而不是一股脑儿使用shell脚本&lt;/h2&gt;
&lt;p&gt;比如，git clone，使用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;checkout &lt;span style=&#34;color:#a6e22e&#34;&gt;scmGit&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;branches: &lt;span style=&#34;color:#f92672&#34;&gt;[[&lt;/span&gt;name: params&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;BRANCH&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                extensions: &lt;span style=&#34;color:#f92672&#34;&gt;[],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                userRemoteConfigs: &lt;span style=&#34;color:#f92672&#34;&gt;[[&lt;/span&gt;credentialsId: params&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;GITHUB_CREDENTIAL&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; url: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://github.com/xxx.git&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;jenkins是面向过程的对于任务配置多考虑使用表驱动&#34;&gt;jenkins是面向过程的，对于任务配置，多考虑使用表驱动&lt;/h2&gt;
&lt;h2 id=&#34;pipline-中访问-env-变量&#34;&gt;Pipline 中访问 env 变量&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;stage&lt;span style=&#34;color:#f92672&#34;&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    println &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;WORKSPACE: ${env.WORKSPACE}&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    echo env&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;WORKSPACE&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    echo WORKSPACE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;环境变量可以通过 Groovy 代码访问，方式为 &lt;code&gt;env.VARNAME&lt;/code&gt; 或者直接使用 &lt;code&gt;VARNAME&lt;/code&gt;。你也可以修改这些属性，但只能通过使用 &lt;code&gt;env.&lt;/code&gt; 前缀来写入。所以：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;jenkins job 中有保留的 env 变量，避免疑惑这些变量要加上 &lt;code&gt;env.&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;env 变量即使在机器上设定了，也是可以修改的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;groovy中的数学计算&#34;&gt;groovy中的数学计算&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; number &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;243&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 要计算的数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; fifthRoot &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; number &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;/5)  /&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;计算&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;次方根&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;两种pipline&#34;&gt;两种pipline&lt;/h2&gt;
&lt;p&gt;在Jenkins中，有两种主要类型的Pipeline：Scripted Pipeline 和 Declarative Pipeline。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Scripted Pipeline【我的工作中都是这种的脚本】:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;使用Groovy语法编写，允许更灵活的流程控制和自定义逻辑。&lt;/li&gt;
&lt;li&gt;通过node和stage等关键字来定义流水线的执行节点和阶段。&lt;/li&gt;
&lt;li&gt;可以直接编写Groovy脚本来构建流水线。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Declarative Pipeline:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;使用更结构化的语法，更易于阅读和维护。&lt;/li&gt;
&lt;li&gt;通过pipeline、agent、stages等关键字来定义流水线的结构和执行环境。&lt;/li&gt;
&lt;li&gt;提供了更丰富的语法来定义构建、部署和测试等阶段。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jenkins-中如何在多个-node-并行执行任务&#34;&gt;jenkins 中如何在多个 NODE 并行执行任务&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; parallel_tasks &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[:]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;params&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;GPU_TASK&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    parallel_tasks&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;GPU_TASK&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        node&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;params&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;GPU_NODE&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            stage&lt;span style=&#34;color:#f92672&#34;&gt;(){}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;params&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;CPU_TASK&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    parallel_tasks&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;CPU_TASK&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        node&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;params&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;CPU_NODE&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            stage&lt;span style=&#34;color:#f92672&#34;&gt;(){}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;parallel&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;parallel_tasks&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;elvis-操作符-&#34;&gt;Elvis 操作符 &lt;code&gt;?:&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;这两句句话有什么不同：&lt;/p&gt;</description>
    </item>
    <item>
      <title>CICD</title>
      <link>https://ashburnLee.github.io/blog-2-hugo/cicd/</link>
      <pubDate>Sun, 31 Aug 2025 12:57:44 +0800</pubDate>
      <guid>https://ashburnLee.github.io/blog-2-hugo/cicd/</guid>
      <description>&lt;p&gt;回忆 Jenkin 是如何实现当 PR push 时自动触发执行的？需要找一个 jenkins 插件帮助我实现 PR 通过 关键字 触发 CI.&lt;/p&gt;
&lt;p&gt;使用什么插件？尝试了 “GitHub Branch Source” 中的 “Multibranch Pipeline projects”，需要在目标 repo 的根目录中创建并编辑 JenkinsFile 文件并且在 github repo 中配置一个webhook，每当有新 PR 到这个 repo，扫描 repo 并触发新 branch 执行 JenkinsFile。每一个 branch 触发一个 job，而这个 job 是不能通过修改 job config 来参数化的，需要通过 property step 在 JenkinsFile 中将这个branch 的 job 参数化。如此就可以执行任何内容了。&lt;/p&gt;
&lt;h1 id=&#34;pytest&#34;&gt;Pytest&lt;/h1&gt;
&lt;h2 id=&#34;pytest-测试框架&#34;&gt;Pytest 测试框架&lt;/h2&gt;
&lt;p&gt;pytest 提供了许多装饰器，比如 &lt;code&gt;@pytest.mark.parametrize&lt;/code&gt; 让你为一个测试用例提供多个输入（输出参数，不同参数之间会进行&lt;strong&gt;笛卡尔积组合&lt;/strong&gt;）。减少了重复代码。&lt;/p&gt;
&lt;p&gt;更多用法 看看 pytest 命令参数。结果有4中状态，xfailed 等。实例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; pytest
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@pytest.mark.parametrize&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@pytest.mark.parametrize&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;b&amp;#34;&lt;/span&gt;, [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;y&amp;#39;&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;test_example&lt;/span&gt;(a, b):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Testing with a=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;a&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; and b=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;b&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 输出将会是：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Testing with a=1 and b=x&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Testing with a=1 and b=y&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Testing with a=2 and b=x&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Testing with a=2 and b=y&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;跳过某些-test-cases&#34;&gt;跳过某些 test cases&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;pytest.mark.skip&lt;/code&gt; 标记 case。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;--deselect-from-file&lt;/code&gt; 接受一个文件，这个文件中的所有 cases 都会被跳过。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;--ignore=test_xxx.py&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;与-pytest-一同使用的插件&#34;&gt;与 pytest 一同使用的插件&lt;/h2&gt;
&lt;p&gt;pytest-select&lt;/p&gt;</description>
    </item>
    <item>
      <title>Github Actions</title>
      <link>https://ashburnLee.github.io/blog-2-hugo/github-actions/</link>
      <pubDate>Sun, 31 Aug 2025 12:57:44 +0800</pubDate>
      <guid>https://ashburnLee.github.io/blog-2-hugo/github-actions/</guid>
      <description>&lt;h2 id=&#34;使用-actionscache&#34;&gt;使用 actions/cache&lt;/h2&gt;
&lt;p&gt;如果你的工作流程经常运行，使用缓存来存储依赖项（如 Bandit）可以减少安装时间。
比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yml&#34; data-lang=&#34;yml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Cache Python dependencies&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;uses&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;actions/cache@v2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;with&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;path&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;~/.cache/pip&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;key&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;${{ runner.os }}-pip-${{ hashFiles(&amp;#39;**/requirements.txt&amp;#39;) }}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;restore-keys&lt;/span&gt;: |&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;            ${{ runner.os }}-pip-&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;我的-github-workflow-工作流程经常运行但是不一定是在同一台机器上这种情况下actionscache-如何cache&#34;&gt;我的 github workflow 工作流程经常运行，但是不一定是在同一台机器上，这种情况下actions/cache 如何cache&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;actions/cache@v2&lt;/code&gt; 是跨工作流程和跨运行器设计的，这意味着即使工作流程在不同的机器上运行，缓存仍然是有效的。&lt;strong&gt;缓存是与仓库相关联的&lt;/strong&gt;，而不是与特定的运行器实例相关联。&lt;/p&gt;
&lt;p&gt;这是 &lt;code&gt;actions/cache&lt;/code&gt; 的一个重要特性。缓存不是存储在某一台特定的运行器或机器上，而是&lt;strong&gt;存储在 GitHub 的云端基础设施中&lt;/strong&gt;。当你使用 &lt;code&gt;actions/cache&lt;/code&gt; 创建缓存时，GitHub 会将缓存内容保存在其服务器上，这样无论后续的工作流程在哪里运行，都可以访问和恢复这些缓存。&lt;/p&gt;
&lt;h2 id=&#34;坑&#34;&gt;坑&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;actions/checkout@v4 只会最少的 repo 内容给你，与手动 clone 不同，所以你需要提供一些其他参数来给出更多的 commit 等信息。&lt;strong&gt;因为actions/checkout@v4 默认不会把历史commit 给你&lt;/strong&gt; 需要添加 &lt;code&gt;fetch-depth: 0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;github 不希望你访问除了当前repo之外的目录，所以&lt;strong&gt;所有的操作都应该在这个repo的目录中&lt;/strong&gt;，比如你想clone例外一个repo，那么把它clone到当前repo的 external/new_repo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于GitHub Actions的安全限制，工作流中的步骤&lt;strong&gt;不能直接传递&lt;/strong&gt;输出到触发下一次工作流的schedule触发器。因此，你需要考虑其他方法来存储和检索PR编号，例如使用仓库的Secrets、工作流的**工件(artifacts)**或者外部存储服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;${{ env.TARGET_PRID }}&lt;/code&gt; 这种方式的变量是 yml 变量，不应该在 shell 命令中使用（即不应该使用在 &lt;code&gt;run: |&lt;/code&gt;）,但功能上也可以在shell 中这样访问。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;echo &amp;quot;TARGET_PRID=$(&amp;lt;file_downloaded/PRID.txt)&amp;quot; &amp;gt;&amp;gt; $GITHUB_ENV&lt;/code&gt; 这句话表示将变量 &lt;code&gt;TARGET_PRID&lt;/code&gt; 放在环境变量中，并且在&lt;strong&gt;相同的job&lt;/strong&gt;中的后续步骤中的 shell 总可以直接访问 &lt;code&gt;$TARGET_PRID&lt;/code&gt;。而且 在非shell的地方可以通过 &lt;code&gt;{{ env.TARGET_PRID }}&lt;/code&gt; 访问其值。在当前job中之后的步骤里，已经有值了，生效了。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
