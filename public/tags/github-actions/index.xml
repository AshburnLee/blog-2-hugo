<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Github Actions on Junhui&#39;s Journal 2</title>
    <link>https://ashburnLee.github.io/blog-2-hugo/tags/github-actions/</link>
    <description>Recent content in Github Actions on Junhui&#39;s Journal 2</description>
    <generator>Hugo -- 0.149.0</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 31 Aug 2025 12:57:44 +0800</lastBuildDate>
    <atom:link href="https://ashburnLee.github.io/blog-2-hugo/tags/github-actions/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Github Actions</title>
      <link>https://ashburnLee.github.io/blog-2-hugo/github-actions/</link>
      <pubDate>Sun, 31 Aug 2025 12:57:44 +0800</pubDate>
      <guid>https://ashburnLee.github.io/blog-2-hugo/github-actions/</guid>
      <description>&lt;h2 id=&#34;使用-actionscache&#34;&gt;使用 actions/cache&lt;/h2&gt;
&lt;p&gt;如果你的工作流程经常运行，使用缓存来存储依赖项（如 Bandit）可以减少安装时间。
比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yml&#34; data-lang=&#34;yml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Cache Python dependencies&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;uses&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;actions/cache@v2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;with&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;path&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;~/.cache/pip&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;key&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;${{ runner.os }}-pip-${{ hashFiles(&amp;#39;**/requirements.txt&amp;#39;) }}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;restore-keys&lt;/span&gt;: |&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;            ${{ runner.os }}-pip-&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;我的-github-workflow-工作流程经常运行但是不一定是在同一台机器上这种情况下actionscache-如何cache&#34;&gt;我的 github workflow 工作流程经常运行，但是不一定是在同一台机器上，这种情况下actions/cache 如何cache&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;actions/cache@v2&lt;/code&gt; 是跨工作流程和跨运行器设计的，这意味着即使工作流程在不同的机器上运行，缓存仍然是有效的。&lt;strong&gt;缓存是与仓库相关联的&lt;/strong&gt;，而不是与特定的运行器实例相关联。&lt;/p&gt;
&lt;p&gt;这是 &lt;code&gt;actions/cache&lt;/code&gt; 的一个重要特性。缓存不是存储在某一台特定的运行器或机器上，而是&lt;strong&gt;存储在 GitHub 的云端基础设施中&lt;/strong&gt;。当你使用 &lt;code&gt;actions/cache&lt;/code&gt; 创建缓存时，GitHub 会将缓存内容保存在其服务器上，这样无论后续的工作流程在哪里运行，都可以访问和恢复这些缓存。&lt;/p&gt;
&lt;h2 id=&#34;坑&#34;&gt;坑&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;actions/checkout@v4 只会最少的 repo 内容给你，与手动 clone 不同，所以你需要提供一些其他参数来给出更多的 commit 等信息。&lt;strong&gt;因为actions/checkout@v4 默认不会把历史commit 给你&lt;/strong&gt; 需要添加 &lt;code&gt;fetch-depth: 0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;github 不希望你访问除了当前repo之外的目录，所以&lt;strong&gt;所有的操作都应该在这个repo的目录中&lt;/strong&gt;，比如你想clone例外一个repo，那么把它clone到当前repo的 external/new_repo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于GitHub Actions的安全限制，工作流中的步骤&lt;strong&gt;不能直接传递&lt;/strong&gt;输出到触发下一次工作流的schedule触发器。因此，你需要考虑其他方法来存储和检索PR编号，例如使用仓库的Secrets、工作流的**工件(artifacts)**或者外部存储服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;${{ env.TARGET_PRID }}&lt;/code&gt; 这种方式的变量是 yml 变量，不应该在 shell 命令中使用（即不应该使用在 &lt;code&gt;run: |&lt;/code&gt;）,但功能上也可以在shell 中这样访问。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;echo &amp;quot;TARGET_PRID=$(&amp;lt;file_downloaded/PRID.txt)&amp;quot; &amp;gt;&amp;gt; $GITHUB_ENV&lt;/code&gt; 这句话表示将变量 &lt;code&gt;TARGET_PRID&lt;/code&gt; 放在环境变量中，并且在&lt;strong&gt;相同的job&lt;/strong&gt;中的后续步骤中的 shell 总可以直接访问 &lt;code&gt;$TARGET_PRID&lt;/code&gt;。而且 在非shell的地方可以通过 &lt;code&gt;{{ env.TARGET_PRID }}&lt;/code&gt; 访问其值。在当前job中之后的步骤里，已经有值了，生效了。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
