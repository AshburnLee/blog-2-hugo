<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>网络 Clash | Junhui&#39;s Journal 2</title>
<meta name="keywords" content="clash, proxy">
<meta name="description" content="路由路径
查看Windows系统中的路由路径，可以使用命令行工具 tracert（Trace Route），它可以显示数据包从本机到目标主机经过的每个路由节点（跳数），帮助分析路由路径和每跳延迟。也可使用 pathping 命令结合了 ping 和 tracert 的功能，带来更详细的路径和丢包统计。
tracert 目标域名或IP地址
pathping www.baidu.com
cookies
Cookie 是网页服务器发送到你的浏览器中并储存的一小段数据文件（文本信息）。网页浏览器会保存这些Cookie，并在你访问同一网站时自动发送给服务器，使服务器能够识别你之前的访问和身份，并为你提供个性化服务。
requests 库
requests 库是基于 HTTP 协议的客户端库。requests.get() 等方法默认且仅支持 HTTP/HTTPS 请求，这些方法定义的请求类型（GET、POST、PUT、DELETE等）都是 HTTP 协议定义的动作。
在发送请求时，优势需要给出header。用来传递额外的元信息，比如访问指定服务器的 token。headers 是一个字典，可以张这样：
import requests
GITHUB_TOKEN = xxx  # Copy your GitHub token here

headers = {
    &#34;User-Agent&#34;: &#34;MyApp/1.0&#34;,
    &#34;Authorization&#34;: &#34;Bearer my_secret_token&#34;,
    &#34;Accept&#34;: &#34;application/json&#34;,
    &#34;Authorization&#34;: f&#34;token {GITHUB_TOKEN}&#34;
}

response = requests.get(&#34;https://api.example.com/data&#34;, headers=headers)
print(response.status_code)
print(response.json())
路由器负责将局域网的私有 IP 地址转换为互联网上的公网 IP 地址，从而保证了互联网上的地址唯一性
用一个具体的例子来说明路由器如何将局域网的私有 IP 地址转换为互联网上的公网 IP 地址，从而保证互联网地址的唯一性（通过 （Network Address Translation）NAT）。
场景： 一个家庭网络，包含一台路由器、一台笔记本电脑和一手机。">
<meta name="author" content="">
<link rel="canonical" href="https://ashburnLee.github.io/blog-2-hugo/%E7%BD%91%E7%BB%9C-clash/">
<link crossorigin="anonymous" href="/blog-2-hugo/assets/css/stylesheet.bdaf5941cb3c05e36e857d9e2953ba0c4485ba7bc2da15db169d66a77cbc7a87.css" integrity="sha256-va9ZQcs8BeNuhX2eKVO6DESFunvC2hXbFp1mp3y8eoc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ashburnLee.github.io/blog-2-hugo/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ashburnLee.github.io/blog-2-hugo/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ashburnLee.github.io/blog-2-hugo/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ashburnLee.github.io/blog-2-hugo/apple-touch-icon.png">
<link rel="mask-icon" href="https://ashburnLee.github.io/blog-2-hugo/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://ashburnLee.github.io/blog-2-hugo/%E7%BD%91%E7%BB%9C-clash/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" id="MathJax-script" async></script>


<meta property="og:url" content="https://ashburnLee.github.io/blog-2-hugo/%E7%BD%91%E7%BB%9C-clash/">
  <meta property="og:site_name" content="Junhui&#39;s Journal 2">
  <meta property="og:title" content="网络 Clash">
  <meta property="og:description" content="路由路径 查看Windows系统中的路由路径，可以使用命令行工具 tracert（Trace Route），它可以显示数据包从本机到目标主机经过的每个路由节点（跳数），帮助分析路由路径和每跳延迟。也可使用 pathping 命令结合了 ping 和 tracert 的功能，带来更详细的路径和丢包统计。
tracert 目标域名或IP地址 pathping www.baidu.com cookies Cookie 是网页服务器发送到你的浏览器中并储存的一小段数据文件（文本信息）。网页浏览器会保存这些Cookie，并在你访问同一网站时自动发送给服务器，使服务器能够识别你之前的访问和身份，并为你提供个性化服务。
requests 库 requests 库是基于 HTTP 协议的客户端库。requests.get() 等方法默认且仅支持 HTTP/HTTPS 请求，这些方法定义的请求类型（GET、POST、PUT、DELETE等）都是 HTTP 协议定义的动作。
在发送请求时，优势需要给出header。用来传递额外的元信息，比如访问指定服务器的 token。headers 是一个字典，可以张这样：
import requests GITHUB_TOKEN = xxx # Copy your GitHub token here headers = { &#34;User-Agent&#34;: &#34;MyApp/1.0&#34;, &#34;Authorization&#34;: &#34;Bearer my_secret_token&#34;, &#34;Accept&#34;: &#34;application/json&#34;, &#34;Authorization&#34;: f&#34;token {GITHUB_TOKEN}&#34; } response = requests.get(&#34;https://api.example.com/data&#34;, headers=headers) print(response.status_code) print(response.json()) 路由器负责将局域网的私有 IP 地址转换为互联网上的公网 IP 地址，从而保证了互联网上的地址唯一性 用一个具体的例子来说明路由器如何将局域网的私有 IP 地址转换为互联网上的公网 IP 地址，从而保证互联网地址的唯一性（通过 （Network Address Translation）NAT）。
场景： 一个家庭网络，包含一台路由器、一台笔记本电脑和一手机。">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:published_time" content="2025-08-31T12:57:46+08:00">
    <meta property="article:modified_time" content="2025-08-31T12:57:46+08:00">
    <meta property="article:tag" content="Clash">
    <meta property="article:tag" content="Proxy">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="网络 Clash">
<meta name="twitter:description" content="路由路径
查看Windows系统中的路由路径，可以使用命令行工具 tracert（Trace Route），它可以显示数据包从本机到目标主机经过的每个路由节点（跳数），帮助分析路由路径和每跳延迟。也可使用 pathping 命令结合了 ping 和 tracert 的功能，带来更详细的路径和丢包统计。
tracert 目标域名或IP地址
pathping www.baidu.com
cookies
Cookie 是网页服务器发送到你的浏览器中并储存的一小段数据文件（文本信息）。网页浏览器会保存这些Cookie，并在你访问同一网站时自动发送给服务器，使服务器能够识别你之前的访问和身份，并为你提供个性化服务。
requests 库
requests 库是基于 HTTP 协议的客户端库。requests.get() 等方法默认且仅支持 HTTP/HTTPS 请求，这些方法定义的请求类型（GET、POST、PUT、DELETE等）都是 HTTP 协议定义的动作。
在发送请求时，优势需要给出header。用来传递额外的元信息，比如访问指定服务器的 token。headers 是一个字典，可以张这样：
import requests
GITHUB_TOKEN = xxx  # Copy your GitHub token here

headers = {
    &#34;User-Agent&#34;: &#34;MyApp/1.0&#34;,
    &#34;Authorization&#34;: &#34;Bearer my_secret_token&#34;,
    &#34;Accept&#34;: &#34;application/json&#34;,
    &#34;Authorization&#34;: f&#34;token {GITHUB_TOKEN}&#34;
}

response = requests.get(&#34;https://api.example.com/data&#34;, headers=headers)
print(response.status_code)
print(response.json())
路由器负责将局域网的私有 IP 地址转换为互联网上的公网 IP 地址，从而保证了互联网上的地址唯一性
用一个具体的例子来说明路由器如何将局域网的私有 IP 地址转换为互联网上的公网 IP 地址，从而保证互联网地址的唯一性（通过 （Network Address Translation）NAT）。
场景： 一个家庭网络，包含一台路由器、一台笔记本电脑和一手机。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "网络 Clash",
      "item": "https://ashburnLee.github.io/blog-2-hugo/%E7%BD%91%E7%BB%9C-clash/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "网络 Clash",
  "name": "网络 Clash",
  "description": "路由路径 查看Windows系统中的路由路径，可以使用命令行工具 tracert（Trace Route），它可以显示数据包从本机到目标主机经过的每个路由节点（跳数），帮助分析路由路径和每跳延迟。也可使用 pathping 命令结合了 ping 和 tracert 的功能，带来更详细的路径和丢包统计。\ntracert 目标域名或IP地址 pathping www.baidu.com cookies Cookie 是网页服务器发送到你的浏览器中并储存的一小段数据文件（文本信息）。网页浏览器会保存这些Cookie，并在你访问同一网站时自动发送给服务器，使服务器能够识别你之前的访问和身份，并为你提供个性化服务。\nrequests 库 requests 库是基于 HTTP 协议的客户端库。requests.get() 等方法默认且仅支持 HTTP/HTTPS 请求，这些方法定义的请求类型（GET、POST、PUT、DELETE等）都是 HTTP 协议定义的动作。\n在发送请求时，优势需要给出header。用来传递额外的元信息，比如访问指定服务器的 token。headers 是一个字典，可以张这样：\nimport requests GITHUB_TOKEN = xxx # Copy your GitHub token here headers = { \u0026#34;User-Agent\u0026#34;: \u0026#34;MyApp/1.0\u0026#34;, \u0026#34;Authorization\u0026#34;: \u0026#34;Bearer my_secret_token\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;Authorization\u0026#34;: f\u0026#34;token {GITHUB_TOKEN}\u0026#34; } response = requests.get(\u0026#34;https://api.example.com/data\u0026#34;, headers=headers) print(response.status_code) print(response.json()) 路由器负责将局域网的私有 IP 地址转换为互联网上的公网 IP 地址，从而保证了互联网上的地址唯一性 用一个具体的例子来说明路由器如何将局域网的私有 IP 地址转换为互联网上的公网 IP 地址，从而保证互联网地址的唯一性（通过 （Network Address Translation）NAT）。\n场景： 一个家庭网络，包含一台路由器、一台笔记本电脑和一手机。\n",
  "keywords": [
    "clash", "proxy"
  ],
  "articleBody": "路由路径 查看Windows系统中的路由路径，可以使用命令行工具 tracert（Trace Route），它可以显示数据包从本机到目标主机经过的每个路由节点（跳数），帮助分析路由路径和每跳延迟。也可使用 pathping 命令结合了 ping 和 tracert 的功能，带来更详细的路径和丢包统计。\ntracert 目标域名或IP地址 pathping www.baidu.com cookies Cookie 是网页服务器发送到你的浏览器中并储存的一小段数据文件（文本信息）。网页浏览器会保存这些Cookie，并在你访问同一网站时自动发送给服务器，使服务器能够识别你之前的访问和身份，并为你提供个性化服务。\nrequests 库 requests 库是基于 HTTP 协议的客户端库。requests.get() 等方法默认且仅支持 HTTP/HTTPS 请求，这些方法定义的请求类型（GET、POST、PUT、DELETE等）都是 HTTP 协议定义的动作。\n在发送请求时，优势需要给出header。用来传递额外的元信息，比如访问指定服务器的 token。headers 是一个字典，可以张这样：\nimport requests GITHUB_TOKEN = xxx # Copy your GitHub token here headers = { \"User-Agent\": \"MyApp/1.0\", \"Authorization\": \"Bearer my_secret_token\", \"Accept\": \"application/json\", \"Authorization\": f\"token {GITHUB_TOKEN}\" } response = requests.get(\"https://api.example.com/data\", headers=headers) print(response.status_code) print(response.json()) 路由器负责将局域网的私有 IP 地址转换为互联网上的公网 IP 地址，从而保证了互联网上的地址唯一性 用一个具体的例子来说明路由器如何将局域网的私有 IP 地址转换为互联网上的公网 IP 地址，从而保证互联网地址的唯一性（通过 （Network Address Translation）NAT）。\n场景： 一个家庭网络，包含一台路由器、一台笔记本电脑和一手机。\n路由器: 拥有一个公网 IP 地址，例如 xxx.0.113.1 (这是一个示例，实际的公网IP地址会因ISP而异)。 路由器内部使用私有 IP 地址进行局域网通信。 笔记本电脑: 配置了私有 IP 地址 x.y.z.100。 手机: 配置了私有 IP 地址 x.y.z.101。 过程：\n笔记本电脑访问互联网: 笔记本电脑想要访问一个网站，例如 www.example.com。笔记本向路由器发送一个请求，目标地址是 www.example.com，源地址是它的私有 IP 地址 x.y.z.100。\n路由器进行 NAT: 路由器收到请求后，不会直接将请求发送到互联网。 它会进行网络地址转换 (NAT)。 具体来说，它会：\n修改源 IP 地址: 将请求的源 IP 地址从 x.y.z.100 更改为路由器的公网 IP 地址 xxx.0.113.1。 可能修改源端口: 路由器还会修改源端口号，以区分来自不同设备的请求。 假设笔记本电脑使用端口 50000，路由器可能会将其更改为一个未使用的端口，例如 60000。 记录映射: 路由器会记录这个映射关系：x.y.z.100:50000 -\u003e xxx.0.113.1:60000。 这个映射关系存储在路由器的 NAT 表中。 请求发送到互联网: 修改后的请求（源 IP 为 xxx.0.113.1:60000，目标 IP 为 www.example.com）被发送到互联网。\n服务器响应: www.example.com 服务器处理请求并发送响应，目标 IP 地址是 xxx.0.113.1:60000。\n路由器进行反向 NAT: 路由器收到响应后，会根据 NAT 表中的映射关系，将目标 IP 地址从 xxx.0.113.1:60000 更改回 x.y.z.100:50000，然后将响应发送给笔记本电脑。\n结果： 笔记本电脑使用私有 IP 地址 x.y.z.100 在局域网内通信，但通过路由器的 NAT 功能，它能够访问互联网，并且互联网上的服务器只看到路由器的公网 IP 地址 xxx.0.113.1。 手机也以同样的方式工作，使用其私有 IP 地址 x.y.z.101，但通过路由器的 NAT 转换为公网 IP 地址进行互联网访问。 这保证了互联网上的 IP 地址的唯一性，因为只有路由器的公网 IP 地址暴露在互联网上。\n这个例子展示了 NAT 如何工作，以及如何通过一个公网 IP 地址为多个私有 IP 地址提供互联网访问，从而避免了私有 IP 地址在互联网上的冲突。 这正是路由器在局域网和互联网之间起到的关键作用。\nWindows 主机的局域网 IP 和 Windows ip地址 指的是相同的事情，ip地址就是局域网里的地址，用于在同一局域网内设备通信。\n与局域网ip 对应的是 公网ip，即互联网上的地址。由互联网服务提供商（ISP）分配给你的网络，用于在互联网上进行通信。通过在浏览器中搜索“我的ip地址”，你可以查到你的公网ip地址。\n在相同局域网内的设备可以相互ping TUN 模式 会在 Windows中 看到一个额外的活动网络 Clash。因为当你启用 Clash 的 TUN 模式时，它会创建一个虚拟网卡，这个网卡通常被 Windows 识别为一个独立的网络接口。在你的情况中，这个接口被标记为“公用网络”。 并且 Clash 网络是 无法连接到 Internet 的，因为尽管 Clash 的 TUN 模式可以正常代理流量，但 Windows 可能无法检测到这个虚拟网卡是否有Internet连接。这是因为TUN模式主要用于代理流量，而不是提供直接的Internet访问。\n什么是监听 监听（Listening）是指一个网络服务或程序等待并接受来自其他设备的连接请求的状态。例如，当一个 Web 服务器监听端口 80 时，它会等待并处理来自任何设备的 HTTP 请求。\n什么是所有网络接口？ 网络接口（Network Interface）是指计算机与网络连接的通道。每个接口都有一个唯一的 IP 地址。常见的网络接口包括：\n回环接口（127.0.0.1）：用于本机内部通信，不涉及外部网络。 以太网接口（例如 x.y.z.100）：用于连接局域网。 无线网卡接口（例如 x.y.z.101）：用于连接 Wi-Fi 网络。 Allow-lan=true 在 Clash 的 Allow LAN 功能中，开启后，Clash 将不仅仅监听本地回环接口（127.0.0.1），而是监听同一局域网中所有可用的网络接口（如 192.168.x.x）。这使得同一局域网内的其他设备可以通过指定的 IP 地址和端口（例如 7890）访问 Clash 代理服务，从而共享网络环境.\nClash 的 Allow LAN 功能主要是为了在同一局域网内共享代理服务，而不是对外部网络开放。因此，虽然它监听所有可用的网络接口，但实际上主要是为了局域网内的设备提供服务。\n0.0.0.0 的作用 在网络配置中，使用 0.0.0.0 作为监听地址时，表示该服务将监听所有可用的网络接口。这与 Clash 的 Allow LAN 功能类似，都是为了使服务对所有网络接口开放\nbind-address 默认就是不指明 bind-address 时，其值是 0.0.0.0 ，监听所有 ip。\n如果你已经将 allow-lan 设置为 true，并且只有一条局域网 IP 地址，那么设置 bind-address 确实是多余的。\n设置 bind-address 参数来指定 Clash 只监听特定的 IP 地址 有些情况下，一个设备可能会有多个局域网 IP 地址。比如通过软件创建的虚拟网卡 VMware network Adapter VMNet1 他有自己的局域网ip。\n多网卡的情况下，可以通过 bind-address 限制访问。\n设备网卡和wifi之间的关系时什么？不同的 wifi 下的同一个网卡的ip不同？ 在同一个 WiFi 网络下，不同的设备（即使使用相同的无线网卡）通常会被分配不同的 IP 地址。这是因为每个设备在连接到网络时，会从路由器的 DHCP 服务器获取一个唯一的 IP 地址，以便在网络中进行通信。\n为什么这样做：DHCP 分配以免地址冲突，设备识别。\n不同的 wifi 下的同一个网卡的ip不同，因为 DHCP 是动态分配.\n网卡被分到的 ip 就是所在局域网的 ip 是的\n回环地址 127.0.0.1 回环接口允许应用程序像使用网络接口一样访问本地主机，为什么在同一台机器上需要像使用网络接口一样访问本地主机? 都在一台机器上了呀?\n在同一台机器上使用回环接口来访问本地主机，尽管看起来有些多余，但它提供了几个关键的好处. 列出一个用途:\n回环接口允许开发者在本地模拟网络环境，测试应用程序在不同网络条件下的行为，而无需依赖外部网络。这对于开发和调试网络应用程序非常有用，因为它可以在不影响外部网络的情况下进行测试.\n配置特定工具的代理 apt 【sudo vim /etc/apt/apt.conf.d/proxy.conf】\nAcquire::http::Proxy \"http://x.y.112.1:1234\"; Acquire::https::Proxy \"http://x.y.112.1:1234\"; git\ngit config --global http.proxy http://x.y.112.1:1234 git config --global https.proxy http://x.y.112.1:1234 如果需要 WSL 中的所有流量都走 Clash 代理（类似 VPN 效果），可以使用 proxychains 或类似工具：\nsudo apt update sudo apt install proxychains 默认网关 默认网关就是你的设备所在是局域网的地址，浏览器输入该地址就可以配置局域网路由器了。\n默认网关（Default Gateway）是网络设备（如电脑、手机、路由器等）在局域网中用来与外部网络通信的关键地址。它通常是路由器的 IP 地址，负责将局域网内的数据包转发到其他网络（如互联网）。简单来说，默认网关是设备访问“外面世界”的出口。\n设备的公共 ip 地址 命令行获取，或者通过浏览器获取\ncurl ifconfig.me # linux curl ipinfo.io/ip # winodws 路由器中使用虚拟服务器设置 【未成功】 设置参数值的解释如下：\n常用服务器：可以选择 “SSH”，或者自定义一个名称，例如 “MySSH”。 外部端口：这是从外部网络访问你的 SSH 服务的端口。可以选择一个 1024 到 65535 之间的端口，例如 2222（不推荐使用常用端口如 22，以增加安全性）。 内部端口：这是目标设备上 SSH 服务监听的端口。通常 SSH 的默认端口是 22。 IP 地址：这是目标设备在局域网内的私有 IP 地址。例如，x.y.z.100。你需要在目标设备上查看其 IP 地址。 协议类型：选择 TCP 协议，因为 SSH 使用 TCP 协议进行通信. 快速查看 ip 当 windows 通过 ssh 连接到 linux 时，Windows 是客户端，Linux是服务器。此时，在Linux上查看env SSH_CONNECTION：\nSSH_CONNECTION=192.168.x.y 14019 192.168.x.z 22 给你总要的 4 信息：\n客户端 IP 地址: 发起 SSH 连接的客户端机器的 IP 地址。 即你的 Windows 机器的 IP 地址。 客户端端口号: 客户端机器用于发起 SSH 连接的端口号。 这是一个临时的、随机分配的端口。 服务器 IP 地址: 接收 SSH 连接的 Linux 服务器的 IP 地址。 服务器端口号: Linux 服务器上 SSH daemon 监听的端口号。 默认情况下，SSH 监听端口是 22。 ",
  "wordCount" : "482",
  "inLanguage": "en",
  "datePublished": "2025-08-31T12:57:46+08:00",
  "dateModified": "2025-08-31T12:57:46+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ashburnLee.github.io/blog-2-hugo/%E7%BD%91%E7%BB%9C-clash/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Junhui's Journal 2",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ashburnLee.github.io/blog-2-hugo/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ashburnLee.github.io/blog-2-hugo/" accesskey="h" title="Junhui&#39;s Journal 2 (Alt + H)">Junhui&#39;s Journal 2</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      网络 Clash
    </h1>
    <div class="post-meta"><span title='2025-08-31 12:57:46 +0800 CST'>August 31, 2025</span>

</div>
  </header> 
  <div class="post-content"><h1 id="路由路径">路由路径<a hidden class="anchor" aria-hidden="true" href="#路由路径">#</a></h1>
<p>查看Windows系统中的路由路径，可以使用命令行工具 tracert（Trace Route），它可以显示数据包从本机到目标主机经过的每个路由节点（跳数），帮助分析路由路径和每跳延迟。也可使用 pathping 命令结合了 ping 和 tracert 的功能，带来更详细的路径和丢包统计。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>tracert 目标域名或IP地址
</span></span><span style="display:flex;"><span>pathping www.baidu.com
</span></span></code></pre></div><h1 id="cookies">cookies<a hidden class="anchor" aria-hidden="true" href="#cookies">#</a></h1>
<p>Cookie 是网页服务器发送到你的浏览器中并储存的一小段数据文件（文本信息）。网页浏览器会保存这些Cookie，并在你访问同一网站时自动发送给服务器，使服务器能够识别你之前的访问和身份，并为你提供个性化服务。</p>
<h1 id="requests-库">requests 库<a hidden class="anchor" aria-hidden="true" href="#requests-库">#</a></h1>
<p>requests 库是基于 HTTP 协议的客户端库。<code>requests.get()</code> 等方法默认且仅支持 <code>HTTP/HTTPS</code> 请求，这些方法定义的请求类型（<code>GET、POST、PUT、DELETE</code>等）都是 HTTP 协议定义的动作。</p>
<p>在发送请求时，优势需要给出<code>header</code>。用来传递额外的元信息，比如访问指定服务器的 token。<code>headers</code> 是一个字典，可以张这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">import</span> requests
</span></span><span style="display:flex;"><span>GITHUB_TOKEN <span style="color:#f92672">=</span> xxx  <span style="color:#75715e"># Copy your GitHub token here</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>headers <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;User-Agent&#34;</span>: <span style="color:#e6db74">&#34;MyApp/1.0&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;Authorization&#34;</span>: <span style="color:#e6db74">&#34;Bearer my_secret_token&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;Accept&#34;</span>: <span style="color:#e6db74">&#34;application/json&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;Authorization&#34;</span>: <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;token </span><span style="color:#e6db74">{</span>GITHUB_TOKEN<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>response <span style="color:#f92672">=</span> requests<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#34;https://api.example.com/data&#34;</span>, headers<span style="color:#f92672">=</span>headers)
</span></span><span style="display:flex;"><span>print(response<span style="color:#f92672">.</span>status_code)
</span></span><span style="display:flex;"><span>print(response<span style="color:#f92672">.</span>json())
</span></span></code></pre></div><h1 id="路由器负责将局域网的私有-ip-地址转换为互联网上的公网-ip-地址从而保证了互联网上的地址唯一性">路由器负责将局域网的私有 IP 地址转换为互联网上的公网 IP 地址，从而保证了互联网上的地址唯一性<a hidden class="anchor" aria-hidden="true" href="#路由器负责将局域网的私有-ip-地址转换为互联网上的公网-ip-地址从而保证了互联网上的地址唯一性">#</a></h1>
<p>用一个具体的例子来说明路由器如何将局域网的私有 IP 地址转换为互联网上的公网 IP 地址，从而保证互联网地址的唯一性（通过 （Network Address Translation）NAT）。</p>
<p>场景： 一个家庭网络，包含一台路由器、一台笔记本电脑和一手机。</p>
<ul>
<li>路由器: 拥有一个公网 IP 地址，例如 xxx.0.113.1 (这是一个示例，实际的公网IP地址会因ISP而异)。 路由器内部使用私有 IP 地址进行局域网通信。</li>
<li>笔记本电脑: 配置了私有 IP 地址 x.y.z.100。</li>
<li>手机: 配置了私有 IP 地址 x.y.z.101。</li>
</ul>
<p>过程：</p>
<ul>
<li>
<p>笔记本电脑访问互联网: 笔记本电脑想要访问一个网站，例如 <a href="https://www.example.com">www.example.com</a>。笔记本向路由器发送一个请求，目标地址是 <a href="https://www.example.com">www.example.com</a>，源地址是它的私有 IP 地址 x.y.z.100。</p>
</li>
<li>
<p>路由器进行 NAT: 路由器收到请求后，不会直接将请求发送到互联网。 它会进行网络地址转换 (NAT)。 具体来说，它会：</p>
<ul>
<li>修改源 IP 地址: 将请求的源 IP 地址从 x.y.z.100 更改为路由器的公网 IP 地址 xxx.0.113.1。</li>
<li>可能修改源端口: 路由器还会修改源端口号，以区分来自不同设备的请求。 假设笔记本电脑使用端口 50000，路由器可能会将其更改为一个未使用的端口，例如 60000。</li>
<li>记录映射: 路由器会记录这个映射关系：x.y.z.100:50000 -&gt; xxx.0.113.1:60000。 这个映射关系存储在路由器的 NAT 表中。</li>
</ul>
</li>
<li>
<p>请求发送到互联网: 修改后的请求（源 IP 为 xxx.0.113.1:60000，目标 IP 为 <a href="https://www.example.com">www.example.com</a>）被发送到互联网。</p>
</li>
<li>
<p>服务器响应: <a href="https://www.example.com">www.example.com</a> 服务器处理请求并发送响应，目标 IP 地址是 xxx.0.113.1:60000。</p>
</li>
<li>
<p>路由器进行反向 NAT: 路由器收到响应后，会根据 NAT 表中的映射关系，将目标 IP 地址从 xxx.0.113.1:60000 更改回 x.y.z.100:50000，然后将响应发送给笔记本电脑。</p>
</li>
</ul>
<p>结果： 笔记本电脑使用私有 IP 地址 x.y.z.100 在局域网内通信，但通过路由器的 NAT 功能，它能够访问互联网，并且互联网上的服务器只看到路由器的公网 IP 地址 xxx.0.113.1。 手机也以同样的方式工作，使用其私有 IP 地址 x.y.z.101，但通过路由器的 NAT 转换为公网 IP 地址进行互联网访问。 这保证了互联网上的 IP 地址的唯一性，因为只有路由器的公网 IP 地址暴露在互联网上。</p>
<p>这个例子展示了 NAT 如何工作，以及如何通过一个公网 IP 地址为多个私有 IP 地址提供互联网访问，从而避免了私有 IP 地址在互联网上的冲突。 这正是路由器在局域网和互联网之间起到的关键作用。</p>
<h2 id="windows-主机的局域网-ip-和-windows-ip地址">Windows 主机的局域网 IP 和 Windows ip地址<a hidden class="anchor" aria-hidden="true" href="#windows-主机的局域网-ip-和-windows-ip地址">#</a></h2>
<p>指的是相同的事情，ip地址就是局域网里的地址，用于在同一局域网内设备通信。</p>
<p>与局域网ip 对应的是 公网ip，即互联网上的地址。由互联网服务提供商（ISP）分配给你的网络，用于在互联网上进行通信。通过在浏览器中搜索“我的ip地址”，你可以查到你的公网ip地址。</p>
<h2 id="在相同局域网内的设备可以相互ping">在相同局域网内的设备可以相互ping<a hidden class="anchor" aria-hidden="true" href="#在相同局域网内的设备可以相互ping">#</a></h2>
<h2 id="tun-模式">TUN 模式<a hidden class="anchor" aria-hidden="true" href="#tun-模式">#</a></h2>
<p>会在 Windows中 看到一个额外的活动网络 Clash。因为当你启用 Clash 的 TUN 模式时，它会创建一个虚拟网卡，这个网卡通常被 Windows 识别为一个独立的网络接口。在你的情况中，这个接口被标记为“公用网络”。
并且 Clash 网络是 无法连接到 Internet 的，因为尽管 Clash 的 TUN 模式可以正常代理流量，但 Windows 可能无法检测到这个虚拟网卡是否有Internet连接。这是因为TUN模式主要用<strong>于代理流量</strong>，而不是提供直接的Internet访问。</p>
<h2 id="什么是监听">什么是监听<a hidden class="anchor" aria-hidden="true" href="#什么是监听">#</a></h2>
<p>监听（Listening）是指一个<strong>网络服务或程序等待并接受来自其他设备的连接请求的状态</strong>。例如，当一个 Web 服务器监听端口 80 时，它会等待并处理来自任何设备的 HTTP 请求。</p>
<h2 id="什么是所有网络接口">什么是所有网络接口？<a hidden class="anchor" aria-hidden="true" href="#什么是所有网络接口">#</a></h2>
<p>网络接口（Network Interface）是指计算机与网络连接的通道。每个接口都有一个唯一的 IP 地址。常见的网络接口包括：</p>
<ul>
<li>回环接口（127.0.0.1）：用于本机内部通信，不涉及外部网络。</li>
<li>以太网接口（例如 x.y.z.100）：用于连接局域网。</li>
<li>无线网卡接口（例如 x.y.z.101）：用于连接 Wi-Fi 网络。</li>
</ul>
<h2 id="allow-lantrue">Allow-lan=true<a hidden class="anchor" aria-hidden="true" href="#allow-lantrue">#</a></h2>
<p>在 Clash 的 Allow LAN 功能中，开启后，Clash 将不仅仅监听本地回环接口（127.0.0.1），而是监听同一局域网中<strong>所有可用的网络接口</strong>（如 192.168.x.x）。这使得同一局域网内的其他设备可以通过指定的 IP 地址和端口（例如 7890）访问 Clash 代理服务，从而共享网络环境.</p>
<p>Clash 的 Allow LAN 功能主要是为了<strong>在同一局域网内共享代理服务</strong>，而不是对外部网络开放。因此，虽然它监听所有可用的网络接口，但实际上主要是为了局域网内的设备提供服务。</p>
<h2 id="0000-的作用">0.0.0.0 的作用<a hidden class="anchor" aria-hidden="true" href="#0000-的作用">#</a></h2>
<p>在网络配置中，使用 0.0.0.0 作为监听地址时，表示该服务将<strong>监听所有可用的网络接口</strong>。这与 Clash 的 Allow LAN 功能类似，都是为了使服务对所有网络接口开放</p>
<h2 id="bind-address">bind-address<a hidden class="anchor" aria-hidden="true" href="#bind-address">#</a></h2>
<p>默认就是不指明 bind-address 时，其值是 0.0.0.0 ，监听所有 ip。</p>
<p>如果你已经将 allow-lan 设置为 true，并且只有一条局域网 IP 地址，那么设置 bind-address 确实是多余的。</p>
<h2 id="设置-bind-address-参数来指定-clash-只监听特定的-ip-地址">设置 bind-address 参数来指定 Clash 只监听特定的 IP 地址<a hidden class="anchor" aria-hidden="true" href="#设置-bind-address-参数来指定-clash-只监听特定的-ip-地址">#</a></h2>
<p>有些情况下，一个设备可能会有多个局域网 IP 地址。比如通过软件创建的虚拟网卡 VMware network Adapter VMNet1 他有自己的局域网ip。</p>
<p>多网卡的情况下，可以通过 bind-address 限制访问。</p>
<h2 id="设备网卡和wifi之间的关系时什么不同的-wifi-下的同一个网卡的ip不同">设备网卡和wifi之间的关系时什么？不同的 wifi 下的同一个网卡的ip不同？<a hidden class="anchor" aria-hidden="true" href="#设备网卡和wifi之间的关系时什么不同的-wifi-下的同一个网卡的ip不同">#</a></h2>
<p>在同一个 WiFi 网络下，不同的设备（即使使用相同的无线网卡）通常会被分配不同的 IP 地址。这是因为每个设备在连接到网络时，会从路由器的 DHCP 服务器获取一个唯一的 IP 地址，以便在网络中进行通信。</p>
<p>为什么这样做：DHCP 分配以免地址冲突，设备识别。</p>
<p>不同的 wifi 下的同一个网卡的ip不同，因为 DHCP 是动态分配.</p>
<h2 id="网卡被分到的-ip-就是所在局域网的-ip">网卡被分到的 ip 就是所在局域网的 ip<a hidden class="anchor" aria-hidden="true" href="#网卡被分到的-ip-就是所在局域网的-ip">#</a></h2>
<p>是的</p>
<h2 id="回环地址-127001">回环地址 127.0.0.1<a hidden class="anchor" aria-hidden="true" href="#回环地址-127001">#</a></h2>
<p>回环接口允许应用程序像使用网络接口一样访问本地主机，为什么在同一台机器上需要像使用网络接口一样访问本地主机? 都在一台机器上了呀?</p>
<p>在同一台机器上使用回环接口来访问本地主机，尽管看起来有些多余，但它提供了几个关键的好处. 列出一个用途:</p>
<p>回环接口允许开发者在本地模拟网络环境，测试应用程序在不同网络条件下的行为，而无需依赖外部网络。这对于开发和调试网络应用程序非常有用，因为它可以在不影响外部网络的情况下进行测试.</p>
<h2 id="配置特定工具的代理">配置特定工具的代理<a hidden class="anchor" aria-hidden="true" href="#配置特定工具的代理">#</a></h2>
<p>apt  【sudo vim /etc/apt/apt.conf.d/proxy.conf】</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>Acquire::http::Proxy <span style="color:#e6db74">&#34;http://x.y.112.1:1234&#34;</span>;
</span></span><span style="display:flex;"><span>Acquire::https::Proxy <span style="color:#e6db74">&#34;http://x.y.112.1:1234&#34;</span>;
</span></span></code></pre></div><p>git</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git config --global http.proxy http://x.y.112.1:1234
</span></span><span style="display:flex;"><span>git config --global https.proxy http://x.y.112.1:1234
</span></span></code></pre></div><p>如果需要 WSL 中的所有流量都走 Clash 代理（类似 VPN 效果），可以使用 proxychains 或类似工具：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo apt update
</span></span><span style="display:flex;"><span>sudo apt install proxychains
</span></span></code></pre></div><h2 id="默认网关">默认网关<a hidden class="anchor" aria-hidden="true" href="#默认网关">#</a></h2>
<p>默认网关就是你的设备所在是局域网的地址，浏览器输入该地址就可以配置局域网路由器了。</p>
<p>默认网关（Default Gateway）是网络设备（如电脑、手机、路由器等）在局域网中用来与外部网络通信的关键地址。它通常是路由器的 IP 地址，负责将局域网内的数据包转发到其他网络（如互联网）。简单来说，默认网关是设备访问“外面世界”的出口。</p>
<h2 id="设备的公共-ip-地址">设备的公共 ip 地址<a hidden class="anchor" aria-hidden="true" href="#设备的公共-ip-地址">#</a></h2>
<p>命令行获取，或者通过浏览器获取</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>curl ifconfig.me <span style="color:#75715e"># linux</span>
</span></span><span style="display:flex;"><span>curl ipinfo.io/ip  <span style="color:#75715e"># winodws</span>
</span></span></code></pre></div><h2 id="路由器中使用虚拟服务器设置--未成功">路由器中使用虚拟服务器设置  【未成功】<a hidden class="anchor" aria-hidden="true" href="#路由器中使用虚拟服务器设置--未成功">#</a></h2>
<p>设置参数值的解释如下：</p>
<ul>
<li>常用服务器：可以选择 &ldquo;SSH&rdquo;，或者自定义一个名称，例如 &ldquo;MySSH&rdquo;。</li>
<li>外部端口：这是从外部网络访问你的 SSH 服务的端口。可以选择一个 1024 到 65535 之间的端口，例如 2222（不推荐使用常用端口如 22，以增加安全性）。</li>
<li>内部端口：这是目标设备上 SSH 服务监听的端口。通常 SSH 的默认端口是 22。</li>
<li>IP 地址：这是目标设备在局域网内的私有 IP 地址。例如，x.y.z.100。你需要在目标设备上查看其 IP 地址。</li>
<li>协议类型：选择 TCP 协议，因为 SSH 使用 TCP 协议进行通信.</li>
</ul>
<h2 id="快速查看-ip">快速查看 ip<a hidden class="anchor" aria-hidden="true" href="#快速查看-ip">#</a></h2>
<p>当 windows 通过 ssh 连接到 linux 时，Windows 是客户端，Linux是服务器。此时，在Linux上查看<code>env SSH_CONNECTION</code>：</p>
<p><code>SSH_CONNECTION=192.168.x.y 14019 192.168.x.z 22</code> 给你总要的 4 信息：</p>
<ul>
<li>客户端 IP 地址: 发起 SSH 连接的客户端机器的 IP 地址。 即你的 Windows 机器的 IP 地址。</li>
<li>客户端端口号: 客户端机器用于发起 SSH 连接的端口号。 这是一个临时的、随机分配的端口。</li>
<li>服务器 IP 地址: 接收 SSH 连接的 Linux 服务器的 IP 地址。</li>
<li>服务器端口号: Linux 服务器上 SSH daemon 监听的端口号。 默认情况下，SSH 监听端口是 22。</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ashburnLee.github.io/blog-2-hugo/tags/clash/">Clash</a></li>
      <li><a href="https://ashburnLee.github.io/blog-2-hugo/tags/proxy/">Proxy</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://ashburnLee.github.io/blog-2-hugo/">Junhui&#39;s Journal 2</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
