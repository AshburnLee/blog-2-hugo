<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Warp | Junhui&#39;s Journal 2</title>
<meta name="keywords" content="CUDA, Warp">
<meta name="description" content="Warp &amp; Lane

Warp 是 GPU 中最基本的调度单位。
Warp 是一个包含 32 个线程的执行单元。这些线程被称为 Lane。 Warp 中的所有 Lane 同时执行相同的指令。这被称为单指令多线程 (SIMT) 执行模型。
每个 Lane 都是一个独立的线程，拥有自己的数据和状态。它们可以访问自己的寄存器、私有内存和全局内存。
每个 Lane 都有一个唯一的 Lane ID，从 0 到 31 。可以使用内建函数 __Laneid() 或 threadIdx.x &amp; 31 来获取 Lane ID。
CUDA 提供了一组 Warp shuffle 指令，允许 Lane 之间进行数据交换。这些指令包括 __shfl_sync()、__shfl_up_sync()、__shfl_down_sync() 和 __shfl_xor_sync()。 这些指令可以高效地进行 Warp 内部的数据通信，而无需访问共享内存。

可以通过使用 Warp shuffle 指令和 Lane ID 来间接地控制 Lane 的行为。不能直接对 Lane 进行编程。
Warp 之间没有（传统意义上的）上下文切换
有 Warp 调度器。所以 Warp 需要调度。
CUDA 并非以传统操作系统意义上的“上下文切换”方式在线程之间切换。 GPU 的 SM 会同时执行多个 Warp，并通过调度器动态地选择哪个 Warp 执行下一条指令。这更像是一种指令级并行，而不是线程级上下文切换。 没有显式的“切换”动作，而是并发执行。CUDA 利用 SIMT 架构，通过并发执行多个 Warp 来隐藏内存延迟和指令执行延迟，而不是通过频繁的线程上下文切换。">
<meta name="author" content="">
<link rel="canonical" href="https://ashburnLee.github.io/blog-2-hugo/cuda-notes/warp/">
<link crossorigin="anonymous" href="/blog-2-hugo/assets/css/stylesheet.bdaf5941cb3c05e36e857d9e2953ba0c4485ba7bc2da15db169d66a77cbc7a87.css" integrity="sha256-va9ZQcs8BeNuhX2eKVO6DESFunvC2hXbFp1mp3y8eoc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ashburnLee.github.io/blog-2-hugo/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ashburnLee.github.io/blog-2-hugo/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ashburnLee.github.io/blog-2-hugo/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ashburnLee.github.io/blog-2-hugo/apple-touch-icon.png">
<link rel="mask-icon" href="https://ashburnLee.github.io/blog-2-hugo/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://ashburnLee.github.io/blog-2-hugo/cuda-notes/warp/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" id="MathJax-script" async></script>


<meta property="og:url" content="https://ashburnLee.github.io/blog-2-hugo/cuda-notes/warp/">
  <meta property="og:site_name" content="Junhui&#39;s Journal 2">
  <meta property="og:title" content="Warp">
  <meta property="og:description" content="Warp &amp; Lane Warp 是 GPU 中最基本的调度单位。 Warp 是一个包含 32 个线程的执行单元。这些线程被称为 Lane。 Warp 中的所有 Lane 同时执行相同的指令。这被称为单指令多线程 (SIMT) 执行模型。 每个 Lane 都是一个独立的线程，拥有自己的数据和状态。它们可以访问自己的寄存器、私有内存和全局内存。 每个 Lane 都有一个唯一的 Lane ID，从 0 到 31 。可以使用内建函数 __Laneid() 或 threadIdx.x &amp; 31 来获取 Lane ID。 CUDA 提供了一组 Warp shuffle 指令，允许 Lane 之间进行数据交换。这些指令包括 __shfl_sync()、__shfl_up_sync()、__shfl_down_sync() 和 __shfl_xor_sync()。 这些指令可以高效地进行 Warp 内部的数据通信，而无需访问共享内存。 可以通过使用 Warp shuffle 指令和 Lane ID 来间接地控制 Lane 的行为。不能直接对 Lane 进行编程。
Warp 之间没有（传统意义上的）上下文切换 有 Warp 调度器。所以 Warp 需要调度。
CUDA 并非以传统操作系统意义上的“上下文切换”方式在线程之间切换。 GPU 的 SM 会同时执行多个 Warp，并通过调度器动态地选择哪个 Warp 执行下一条指令。这更像是一种指令级并行，而不是线程级上下文切换。 没有显式的“切换”动作，而是并发执行。CUDA 利用 SIMT 架构，通过并发执行多个 Warp 来隐藏内存延迟和指令执行延迟，而不是通过频繁的线程上下文切换。">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="cuda-notes">
    <meta property="article:published_time" content="2025-08-31T12:45:54+08:00">
    <meta property="article:modified_time" content="2025-08-31T12:45:54+08:00">
    <meta property="article:tag" content="CUDA">
    <meta property="article:tag" content="Warp">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Warp">
<meta name="twitter:description" content="Warp &amp; Lane

Warp 是 GPU 中最基本的调度单位。
Warp 是一个包含 32 个线程的执行单元。这些线程被称为 Lane。 Warp 中的所有 Lane 同时执行相同的指令。这被称为单指令多线程 (SIMT) 执行模型。
每个 Lane 都是一个独立的线程，拥有自己的数据和状态。它们可以访问自己的寄存器、私有内存和全局内存。
每个 Lane 都有一个唯一的 Lane ID，从 0 到 31 。可以使用内建函数 __Laneid() 或 threadIdx.x &amp; 31 来获取 Lane ID。
CUDA 提供了一组 Warp shuffle 指令，允许 Lane 之间进行数据交换。这些指令包括 __shfl_sync()、__shfl_up_sync()、__shfl_down_sync() 和 __shfl_xor_sync()。 这些指令可以高效地进行 Warp 内部的数据通信，而无需访问共享内存。

可以通过使用 Warp shuffle 指令和 Lane ID 来间接地控制 Lane 的行为。不能直接对 Lane 进行编程。
Warp 之间没有（传统意义上的）上下文切换
有 Warp 调度器。所以 Warp 需要调度。
CUDA 并非以传统操作系统意义上的“上下文切换”方式在线程之间切换。 GPU 的 SM 会同时执行多个 Warp，并通过调度器动态地选择哪个 Warp 执行下一条指令。这更像是一种指令级并行，而不是线程级上下文切换。 没有显式的“切换”动作，而是并发执行。CUDA 利用 SIMT 架构，通过并发执行多个 Warp 来隐藏内存延迟和指令执行延迟，而不是通过频繁的线程上下文切换。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "CUDA Notes",
      "item": "https://ashburnLee.github.io/blog-2-hugo/cuda-notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Warp",
      "item": "https://ashburnLee.github.io/blog-2-hugo/cuda-notes/warp/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Warp",
  "name": "Warp",
  "description": "Warp \u0026amp; Lane Warp 是 GPU 中最基本的调度单位。 Warp 是一个包含 32 个线程的执行单元。这些线程被称为 Lane。 Warp 中的所有 Lane 同时执行相同的指令。这被称为单指令多线程 (SIMT) 执行模型。 每个 Lane 都是一个独立的线程，拥有自己的数据和状态。它们可以访问自己的寄存器、私有内存和全局内存。 每个 Lane 都有一个唯一的 Lane ID，从 0 到 31 。可以使用内建函数 __Laneid() 或 threadIdx.x \u0026amp; 31 来获取 Lane ID。 CUDA 提供了一组 Warp shuffle 指令，允许 Lane 之间进行数据交换。这些指令包括 __shfl_sync()、__shfl_up_sync()、__shfl_down_sync() 和 __shfl_xor_sync()。 这些指令可以高效地进行 Warp 内部的数据通信，而无需访问共享内存。 可以通过使用 Warp shuffle 指令和 Lane ID 来间接地控制 Lane 的行为。不能直接对 Lane 进行编程。\nWarp 之间没有（传统意义上的）上下文切换 有 Warp 调度器。所以 Warp 需要调度。\nCUDA 并非以传统操作系统意义上的“上下文切换”方式在线程之间切换。 GPU 的 SM 会同时执行多个 Warp，并通过调度器动态地选择哪个 Warp 执行下一条指令。这更像是一种指令级并行，而不是线程级上下文切换。 没有显式的“切换”动作，而是并发执行。CUDA 利用 SIMT 架构，通过并发执行多个 Warp 来隐藏内存延迟和指令执行延迟，而不是通过频繁的线程上下文切换。\n",
  "keywords": [
    "CUDA", "Warp"
  ],
  "articleBody": "Warp \u0026 Lane Warp 是 GPU 中最基本的调度单位。 Warp 是一个包含 32 个线程的执行单元。这些线程被称为 Lane。 Warp 中的所有 Lane 同时执行相同的指令。这被称为单指令多线程 (SIMT) 执行模型。 每个 Lane 都是一个独立的线程，拥有自己的数据和状态。它们可以访问自己的寄存器、私有内存和全局内存。 每个 Lane 都有一个唯一的 Lane ID，从 0 到 31 。可以使用内建函数 __Laneid() 或 threadIdx.x \u0026 31 来获取 Lane ID。 CUDA 提供了一组 Warp shuffle 指令，允许 Lane 之间进行数据交换。这些指令包括 __shfl_sync()、__shfl_up_sync()、__shfl_down_sync() 和 __shfl_xor_sync()。 这些指令可以高效地进行 Warp 内部的数据通信，而无需访问共享内存。 可以通过使用 Warp shuffle 指令和 Lane ID 来间接地控制 Lane 的行为。不能直接对 Lane 进行编程。\nWarp 之间没有（传统意义上的）上下文切换 有 Warp 调度器。所以 Warp 需要调度。\nCUDA 并非以传统操作系统意义上的“上下文切换”方式在线程之间切换。 GPU 的 SM 会同时执行多个 Warp，并通过调度器动态地选择哪个 Warp 执行下一条指令。这更像是一种指令级并行，而不是线程级上下文切换。 没有显式的“切换”动作，而是并发执行。CUDA 利用 SIMT 架构，通过并发执行多个 Warp 来隐藏内存延迟和指令执行延迟，而不是通过频繁的线程上下文切换。\nWarp 调度器会检查哪些 Warp 的指令已经准备好执行（例如，没有数据依赖性或内存访问冲突）。然后，调度器会从这些 “eligible” 的 Warp 中选择一个，并发出它的下一条指令。这个切换过程几乎没有开销，因为它不需要像传统上下文切换那样保存和加载线程状态。\n所以没有传统意义上的上下文切换，没有保存和加载线程状态的开销（零开销），是零开销的指令流的交织执行。 ***\n虽然理想情况下，我们希望所有 Warp 都能在同一时间一起执行，但由于 SIMT 架构的限制、延迟、资源冲突和依赖关系等因素，事实是 GPU 中有 Warp 调度器，它必须对 Warp 的执行进行调度，以实现最佳的性能。 ***\n资源（寄存器、共享内存等）并非一直分配给每个线程直到它完成。 一个 SM 的资源是有限的。当一个 Warp完成执行后，其占用的资源会被释放，供其他 Warp 使用。 虽然单个线程的寄存器在 Warp 执行期间保持不变，但 SM 整体的资源分配是动态的，由调度器管理。\nWarp 内部线程同一时刻执行相同的指令 SM 通过 Warp 调度器快速切换 Warp 来实现并发，而 Warp 内部的线程在理想情况下是同时执行的（SIMT）。 ***\n@ Warp 内部的 reduce 为什么效率高 Warp 内部的 reduce 操作通常不需要额外的同步指令（如 __syncthreads() ），因为 Warp 内的线程是同步执行的。\n在 Warp 内部进行 reduce 操作时，线程可以访问连续的内存地址，这符合GPU的内存访问优化原则。连续的内存访问可以进一步减少访存延迟。\n而且通过 Warp shuffle 机制，可以减少 bank conflict。Warp 不操作 Shared memory，直接访问寄存器的，但是寄存器也有bank，所以可能会有bank conflict。寄存器的bank conflict 很少被提及。\n@ 每个 Warp 代表一个指令流，调度器负责在这些指令流之间进行动态切换？为什么要切换，不能在同一个时间一起执行吗 硬件就是这么设计的，有 Warp 调度器。没有为啥。\nWarp Scheduler 负责选择要执行的 Warp。Warp Scheduler 根据一定的策略（例如 Round-Robin 或优先级）从 ready 的 Warp 队列中选择一个 Warp。\nDispatch Unit 主要作用是将 Warp Scheduler 选择的 Warp 的指令发送到 SM 中的各个执行单元。 负责将 Warp Scheduler 选择的 Warp 的指令发送到各个执行单元。\nWarp 中线程 ID dim3 blockDim(32, 32) 的情况下， Warp 的线程 ID 是如何分布的。\n线程块内的线程会被划分成多个 Warp。划分的顺序是先按照 x 维度，再按照 y 维度。 *** x维度变化最快。\n第一个 Warp 的线程 ID：threadIdx.x 从 0 到 31，threadIdx.y 都为 0 第二个 Warp 的线程 ID：threadIdx.x 从 0 到 31，threadIdx.y 都为 1 第三个 Warp 的线程 ID：threadIdx.x 从 0 到 31，threadIdx.y 都为 2 … 第 32 个 Warp 的线程 ID：threadIdx.x 从 0 到 31，threadIdx.y 都为 31\nDivergence GPU 采用 SIMT 架构，这意味着一个线程束中的所有线程在同一时刻执行相同的指令，当一个 Warp 中的线程执行不同的指令时，就会发生 divergence。比如 Warp 中的线程执行循环的次数不同时。假设一个线程束有8个线程，它们的循环次数分别是：\n线程ID: 0, 1, 2, 3, 4, 5, 6, 7 循环次数: 10, 12, 15, 10, 18, 20, 12, 15\n在这种情况下，GPU会按照以下步骤执行：\n循环体执行10次：所有8个线程都处于活跃状态。 循环体执行2次：线程1和线程6处于活跃状态。 循环体执行3次：线程2和线程7处于活跃状态。 循环体执行5次：线程4处于活跃状态。 循环体执行2次：线程5处于活跃状态。 总执行次数：10 + 2 + 3 + 5 + 2 = 22 次,\n@ 发散为什么会导致性能下降 GPU 需要多次执行相同的指令，而每次只有部分线程处于活跃状态。当没有发散时，所有线程相同的指令执行一次。 线程束发散会导致 GPU 执行额外的指令，从而降低性能。活跃线程的比例越低，性能损失越大。 线程束发散会导致 GPU 执行的额外指令 主要包括以下几种：\n1. 分支指令（Branch Instructions） 当线程束中的线程执行到分支语句（例如 if 语句或循环）时，如果某些线程满足条件，而另一些线程不满足条件，GPU 会生成额外的分支指令。这些分支指令用于控制线程的执行路径，使得不同的线程执行不同的代码块。\n2. 屏蔽指令（Masking Instructions） 当线程束发散发生时，GPU 会使用屏蔽指令来屏蔽不满足条件的线程，使得它们不执行当前的代码块。屏蔽指令会增加指令的数量，并可能导致性能下降。\n3. 线程同步指令（Thread Synchronization Instructions） 当线程束发散发生时，GPU 需要在不同的分支执行完毕后，将线程束中的所有线程重新同步。线程同步指令会增加指令的数量，并可能导致性能下降。\n4. Predicated Execution 指令 虽然 predicated execution 可以减少线程束发散，但它也会增加指令的数量。Predicated execution 使用 @p 修饰符来控制指令的执行，这意味着每条指令都需要判断条件是否满足，这会增加指令的数量。\n",
  "wordCount" : "344",
  "inLanguage": "en",
  "datePublished": "2025-08-31T12:45:54+08:00",
  "dateModified": "2025-08-31T12:45:54+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ashburnLee.github.io/blog-2-hugo/cuda-notes/warp/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Junhui's Journal 2",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ashburnLee.github.io/blog-2-hugo/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ashburnLee.github.io/blog-2-hugo/" accesskey="h" title="Junhui&#39;s Journal 2 (Alt + H)">Junhui&#39;s Journal 2</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Warp
    </h1>
    <div class="post-meta"><span title='2025-08-31 12:45:54 +0800 CST'>August 31, 2025</span>

</div>
  </header> 
  <div class="post-content"><h2 id="warp--lane">Warp &amp; Lane<a hidden class="anchor" aria-hidden="true" href="#warp--lane">#</a></h2>
<ul>
<li>Warp 是 GPU 中最基本的调度单位。</li>
<li>Warp 是一个包含 32 个线程的执行单元。这些线程被称为 Lane。 Warp 中的所有 Lane 同时执行相同的指令。这被称为单指令多线程 (SIMT) 执行模型。</li>
<li>每个 Lane 都是一个独立的线程，拥有自己的数据和状态。它们可以访问自己的寄存器、私有内存和全局内存。</li>
<li>每个 Lane 都有一个唯一的 Lane ID，从 0 到 31 。可以使用内建函数 <code>__Laneid()</code> 或 <code>threadIdx.x &amp; 31</code> 来获取 Lane ID。</li>
<li><strong>CUDA 提供了一组 Warp shuffle 指令，允许 Lane 之间进行数据交换</strong>。这些指令包括 <code>__shfl_sync()</code>、<code>__shfl_up_sync()</code>、<code>__shfl_down_sync()</code> 和 <code>__shfl_xor_sync()</code>。 这些指令可以高效地进行 Warp 内部的数据通信，而无需访问共享内存。</li>
</ul>
<p>可以通过使用 Warp shuffle 指令和 Lane ID 来间接地控制 Lane 的行为。不能直接对 Lane 进行编程。</p>
<h2 id="warp-之间没有传统意义上的上下文切换">Warp 之间没有（传统意义上的）上下文切换<a hidden class="anchor" aria-hidden="true" href="#warp-之间没有传统意义上的上下文切换">#</a></h2>
<p>有 Warp 调度器。所以 Warp 需要调度。</p>
<p>CUDA 并非以传统操作系统意义上的“上下文切换”方式在线程之间切换。 GPU 的 SM 会同时执行多个 Warp，并通过调度器动态地选择哪个 Warp 执行下一条指令。<strong>这更像是一种指令级并行，而不是线程级上下文切换</strong>。 没有显式的“切换”动作，而是并发执行。CUDA 利用 SIMT 架构，通过并发执行多个 Warp 来隐藏内存延迟和指令执行延迟，而不是通过频繁的线程上下文切换。</p>
<p><strong>Warp 调度器</strong>会检查哪些 Warp 的指令已经准备好执行（例如，没有数据依赖性或内存访问冲突）。然后，调度器会从这些 &ldquo;eligible&rdquo; 的 Warp 中选择一个，并发出它的下一条指令。这个切换过程几乎没有开销，因为它不需要像传统上下文切换那样保存和加载线程状态。</p>
<p>所以没有传统意义上的上下文切换，没有保存和加载线程状态的开销（零开销），是零开销的指令流的交织执行。 ***</p>
<p>虽然理想情况下，我们希望所有 Warp 都能在同一时间一起执行，但由于 SIMT 架构的限制、延迟、资源冲突和依赖关系等因素，事实是 GPU 中有 <strong>Warp 调度器</strong>，它必须对 Warp 的执行进行调度，以实现最佳的性能。 ***</p>
<p>资源（寄存器、共享内存等）并非一直分配给每个线程直到它完成。 一个 SM 的资源是有限的。当一个 Warp完成执行后，其占用的资源会被释放，供其他 Warp 使用。 虽然单个线程的寄存器在 Warp 执行期间保持不变，但 SM 整体的资源分配是动态的，由调度器管理。</p>
<h2 id="warp-内部线程同一时刻执行相同的指令">Warp 内部线程同一时刻执行相同的指令<a hidden class="anchor" aria-hidden="true" href="#warp-内部线程同一时刻执行相同的指令">#</a></h2>
<p>SM 通过 Warp 调度器快速切换 Warp 来实现并发，而 Warp 内部的线程在理想情况下是同时执行的（SIMT）。 ***</p>
<h2 id="-warp-内部的-reduce-为什么效率高">@ Warp 内部的 reduce 为什么效率高<a hidden class="anchor" aria-hidden="true" href="#-warp-内部的-reduce-为什么效率高">#</a></h2>
<ol>
<li>
<p>Warp 内部的 reduce 操作通常不需要额外的同步指令（如 <code>__syncthreads()</code> ），因为 Warp 内的线程是同步执行的。</p>
</li>
<li>
<p>在 Warp 内部进行 reduce 操作时，线程可以访问连续的内存地址，这符合GPU的内存访问优化原则。连续的内存访问可以进一步减少访存延迟。</p>
</li>
<li>
<p>而且通过 Warp shuffle 机制，<del>可以减少 bank conflict</del>。Warp 不操作 Shared memory，直接访问寄存器的，但是寄存器也有bank，所以可能会有bank conflict。寄存器的bank conflict 很少被提及。</p>
</li>
</ol>
<h2 id="-每个-warp-代表一个指令流调度器负责在这些指令流之间进行动态切换为什么要切换不能在同一个时间一起执行吗">@ 每个 Warp 代表一个指令流，调度器负责在这些指令流之间进行动态切换？为什么要切换，不能在同一个时间一起执行吗<a hidden class="anchor" aria-hidden="true" href="#-每个-warp-代表一个指令流调度器负责在这些指令流之间进行动态切换为什么要切换不能在同一个时间一起执行吗">#</a></h2>
<p>硬件就是这么设计的，有 Warp 调度器。没有为啥。</p>
<h2 id="warp-scheduler">Warp Scheduler<a hidden class="anchor" aria-hidden="true" href="#warp-scheduler">#</a></h2>
<p>负责选择要执行的 Warp。Warp Scheduler 根据一定的策略（例如 Round-Robin 或优先级）从 ready 的 Warp 队列中选择一个 Warp。</p>
<h2 id="dispatch-unit">Dispatch Unit<a hidden class="anchor" aria-hidden="true" href="#dispatch-unit">#</a></h2>
<p>主要作用是将 Warp Scheduler 选择的 Warp 的指令发送到 SM 中的各个执行单元。
负责将 Warp Scheduler 选择的 Warp 的指令发送到各个执行单元。</p>
<h2 id="warp-中线程-id">Warp 中线程 ID<a hidden class="anchor" aria-hidden="true" href="#warp-中线程-id">#</a></h2>
<p><code>dim3 blockDim(32, 32)</code> 的情况下， Warp 的线程 ID 是如何分布的。</p>
<p><strong>线程块内的线程会被划分成多个 Warp。划分的顺序是先按照 x 维度，再按照 y 维度</strong>。 *** x维度变化最快。</p>
<p>第一个 Warp 的线程 ID：threadIdx.x 从 0 到 31，threadIdx.y 都为 0
第二个 Warp 的线程 ID：threadIdx.x 从 0 到 31，threadIdx.y 都为 1
第三个 Warp 的线程 ID：threadIdx.x 从 0 到 31，threadIdx.y 都为 2
&hellip;
第 32 个 Warp 的线程 ID：threadIdx.x 从 0 到 31，threadIdx.y 都为 31</p>
<hr>
<h2 id="divergence">Divergence<a hidden class="anchor" aria-hidden="true" href="#divergence">#</a></h2>
<p>GPU 采用 SIMT 架构，这意味着一个线程束中的所有线程在同一时刻执行相同的指令，当一个 Warp 中的线程执行不同的指令时，就会发生 divergence。比如 Warp 中的线程执行循环的次数不同时。假设一个线程束有8个线程，它们的循环次数分别是：</p>
<p>线程ID:   0,  1,  2,  3,  4,  5,  6,  7
循环次数: 10, 12, 15, 10, 18, 20, 12, 15</p>
<p>在这种情况下，GPU会按照以下步骤执行：</p>
<pre><code>循环体执行10次：所有8个线程都处于活跃状态。
循环体执行2次：线程1和线程6处于活跃状态。
循环体执行3次：线程2和线程7处于活跃状态。
循环体执行5次：线程4处于活跃状态。
循环体执行2次：线程5处于活跃状态。
</code></pre>
<p>总执行次数：10 + 2 + 3 + 5 + 2 = 22 次,</p>
<h2 id="-发散为什么会导致性能下降">@ 发散为什么会导致性能下降<a hidden class="anchor" aria-hidden="true" href="#-发散为什么会导致性能下降">#</a></h2>
<ol>
<li>GPU 需要多次执行相同的指令，而每次只有部分线程处于活跃状态。当没有发散时，所有线程相同的指令执行一次。</li>
<li>线程束发散会导致 GPU 执行<strong>额外的指令</strong>，从而降低性能。活跃线程的比例越低，性能损失越大。</li>
</ol>
<h2 id="线程束发散会导致-gpu-执行的额外指令">线程束发散会导致 GPU 执行的额外指令<a hidden class="anchor" aria-hidden="true" href="#线程束发散会导致-gpu-执行的额外指令">#</a></h2>
<p>主要包括以下几种：</p>
<h3 id="1-分支指令branch-instructions">1. 分支指令（Branch Instructions）<a hidden class="anchor" aria-hidden="true" href="#1-分支指令branch-instructions">#</a></h3>
<p>当线程束中的线程执行到分支语句（例如 if 语句或循环）时，如果某些线程满足条件，而另一些线程不满足条件，GPU 会生成额外的分支指令。这些分支指令用于控制线程的执行路径，使得不同的线程执行不同的代码块。</p>
<h3 id="2-屏蔽指令masking-instructions">2. 屏蔽指令（Masking Instructions）<a hidden class="anchor" aria-hidden="true" href="#2-屏蔽指令masking-instructions">#</a></h3>
<p>当线程束发散发生时，GPU 会使用屏蔽指令来<strong>屏蔽</strong>不满足条件的线程，使得它们不执行当前的代码块。屏蔽指令会增加指令的数量，并可能导致性能下降。</p>
<h3 id="3-线程同步指令thread-synchronization-instructions">3. 线程同步指令（Thread Synchronization Instructions）<a hidden class="anchor" aria-hidden="true" href="#3-线程同步指令thread-synchronization-instructions">#</a></h3>
<p>当线程束发散发生时，GPU 需要在不同的分支执行完毕后，将线程束中的所有线程重新同步。线程同步指令会增加指令的数量，并可能导致性能下降。</p>
<h3 id="4-predicated-execution-指令">4. Predicated Execution 指令<a hidden class="anchor" aria-hidden="true" href="#4-predicated-execution-指令">#</a></h3>
<p>虽然 predicated execution 可以减少线程束发散，但它也会增加指令的数量。Predicated execution 使用 <code>@p</code> 修饰符来控制指令的执行，这意味着每条指令都需要判断条件是否满足，这会增加指令的数量。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ashburnLee.github.io/blog-2-hugo/tags/cuda/">CUDA</a></li>
      <li><a href="https://ashburnLee.github.io/blog-2-hugo/tags/warp/">Warp</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://ashburnLee.github.io/blog-2-hugo/">Junhui&#39;s Journal 2</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
