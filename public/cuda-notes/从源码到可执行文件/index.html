<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>从源码到可执行文件 | Junhui&#39;s Journal 2</title>
<meta name="keywords" content="CUDA, nvcc">
<meta name="description" content="nvcc 和 ptxas
nvcc（NVIDIA CUDA Compiler Driver）
nvcc 是 NVIDIA CUDA 编译器驱动程序，它负责管理整个 CUDA 编译过程。它的主要职责包括：

预处理：处理宏定义、头文件包含等预处理步骤。
分离 Host 代码和 Device 代码：将 CUDA 源代码分离成 Host 代码（Host Code）和 Device 代码（Device Code）。
编译 Host 代码：调用标准的 C&#43;&#43; 编译器（如 g&#43;&#43; 或 clang）来编译 Host 代码部分。
编译 Device 代码：nvcc 将 device 代码编译成 PTX 代码，并传递给 ptxas 进行进一步编译。
链接：将 Host 代码和 Device 代码链接在一起，生成最终的可执行文件或库文件。

nvcc -ptx my_kernel.cu -o my_kernel.ptx 查看对应的 PTX 代码。
ptxas（Parallel Thread Execution Assembler）
ptxas 是 CUDA 工具链中的汇编器，它专门负责将 PTX（Parallel Thread Execution）代码编译成 GPU 可以执行的机器代码（SASS）。它的主要职责包括：">
<meta name="author" content="">
<link rel="canonical" href="https://ashburnLee.github.io/blog-2-hugo/cuda-notes/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/">
<link crossorigin="anonymous" href="/blog-2-hugo/assets/css/stylesheet.bdaf5941cb3c05e36e857d9e2953ba0c4485ba7bc2da15db169d66a77cbc7a87.css" integrity="sha256-va9ZQcs8BeNuhX2eKVO6DESFunvC2hXbFp1mp3y8eoc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ashburnLee.github.io/blog-2-hugo/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ashburnLee.github.io/blog-2-hugo/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ashburnLee.github.io/blog-2-hugo/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ashburnLee.github.io/blog-2-hugo/apple-touch-icon.png">
<link rel="mask-icon" href="https://ashburnLee.github.io/blog-2-hugo/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://ashburnLee.github.io/blog-2-hugo/cuda-notes/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" id="MathJax-script" async></script>


<meta property="og:url" content="https://ashburnLee.github.io/blog-2-hugo/cuda-notes/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/">
  <meta property="og:site_name" content="Junhui&#39;s Journal 2">
  <meta property="og:title" content="从源码到可执行文件">
  <meta property="og:description" content="nvcc 和 ptxas nvcc（NVIDIA CUDA Compiler Driver） nvcc 是 NVIDIA CUDA 编译器驱动程序，它负责管理整个 CUDA 编译过程。它的主要职责包括：
预处理：处理宏定义、头文件包含等预处理步骤。 分离 Host 代码和 Device 代码：将 CUDA 源代码分离成 Host 代码（Host Code）和 Device 代码（Device Code）。 编译 Host 代码：调用标准的 C&#43;&#43; 编译器（如 g&#43;&#43; 或 clang）来编译 Host 代码部分。 编译 Device 代码：nvcc 将 device 代码编译成 PTX 代码，并传递给 ptxas 进行进一步编译。 链接：将 Host 代码和 Device 代码链接在一起，生成最终的可执行文件或库文件。 nvcc -ptx my_kernel.cu -o my_kernel.ptx 查看对应的 PTX 代码。
ptxas（Parallel Thread Execution Assembler） ptxas 是 CUDA 工具链中的汇编器，它专门负责将 PTX（Parallel Thread Execution）代码编译成 GPU 可以执行的机器代码（SASS）。它的主要职责包括：">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="cuda-notes">
    <meta property="article:published_time" content="2025-08-31T12:45:54+08:00">
    <meta property="article:modified_time" content="2025-08-31T12:45:54+08:00">
    <meta property="article:tag" content="CUDA">
    <meta property="article:tag" content="Nvcc">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="从源码到可执行文件">
<meta name="twitter:description" content="nvcc 和 ptxas
nvcc（NVIDIA CUDA Compiler Driver）
nvcc 是 NVIDIA CUDA 编译器驱动程序，它负责管理整个 CUDA 编译过程。它的主要职责包括：

预处理：处理宏定义、头文件包含等预处理步骤。
分离 Host 代码和 Device 代码：将 CUDA 源代码分离成 Host 代码（Host Code）和 Device 代码（Device Code）。
编译 Host 代码：调用标准的 C&#43;&#43; 编译器（如 g&#43;&#43; 或 clang）来编译 Host 代码部分。
编译 Device 代码：nvcc 将 device 代码编译成 PTX 代码，并传递给 ptxas 进行进一步编译。
链接：将 Host 代码和 Device 代码链接在一起，生成最终的可执行文件或库文件。

nvcc -ptx my_kernel.cu -o my_kernel.ptx 查看对应的 PTX 代码。
ptxas（Parallel Thread Execution Assembler）
ptxas 是 CUDA 工具链中的汇编器，它专门负责将 PTX（Parallel Thread Execution）代码编译成 GPU 可以执行的机器代码（SASS）。它的主要职责包括：">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "CUDA Notes",
      "item": "https://ashburnLee.github.io/blog-2-hugo/cuda-notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "从源码到可执行文件",
      "item": "https://ashburnLee.github.io/blog-2-hugo/cuda-notes/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "从源码到可执行文件",
  "name": "从源码到可执行文件",
  "description": "nvcc 和 ptxas nvcc（NVIDIA CUDA Compiler Driver） nvcc 是 NVIDIA CUDA 编译器驱动程序，它负责管理整个 CUDA 编译过程。它的主要职责包括：\n预处理：处理宏定义、头文件包含等预处理步骤。 分离 Host 代码和 Device 代码：将 CUDA 源代码分离成 Host 代码（Host Code）和 Device 代码（Device Code）。 编译 Host 代码：调用标准的 C++ 编译器（如 g++ 或 clang）来编译 Host 代码部分。 编译 Device 代码：nvcc 将 device 代码编译成 PTX 代码，并传递给 ptxas 进行进一步编译。 链接：将 Host 代码和 Device 代码链接在一起，生成最终的可执行文件或库文件。 nvcc -ptx my_kernel.cu -o my_kernel.ptx 查看对应的 PTX 代码。\nptxas（Parallel Thread Execution Assembler） ptxas 是 CUDA 工具链中的汇编器，它专门负责将 PTX（Parallel Thread Execution）代码编译成 GPU 可以执行的机器代码（SASS）。它的主要职责包括：\n",
  "keywords": [
    "CUDA", "nvcc"
  ],
  "articleBody": "nvcc 和 ptxas nvcc（NVIDIA CUDA Compiler Driver） nvcc 是 NVIDIA CUDA 编译器驱动程序，它负责管理整个 CUDA 编译过程。它的主要职责包括：\n预处理：处理宏定义、头文件包含等预处理步骤。 分离 Host 代码和 Device 代码：将 CUDA 源代码分离成 Host 代码（Host Code）和 Device 代码（Device Code）。 编译 Host 代码：调用标准的 C++ 编译器（如 g++ 或 clang）来编译 Host 代码部分。 编译 Device 代码：nvcc 将 device 代码编译成 PTX 代码，并传递给 ptxas 进行进一步编译。 链接：将 Host 代码和 Device 代码链接在一起，生成最终的可执行文件或库文件。 nvcc -ptx my_kernel.cu -o my_kernel.ptx 查看对应的 PTX 代码。\nptxas（Parallel Thread Execution Assembler） ptxas 是 CUDA 工具链中的汇编器，它专门负责将 PTX（Parallel Thread Execution）代码编译成 GPU 可以执行的机器代码（SASS）。它的主要职责包括：\n接收 PTX 代码：从 nvcc 接收 PTX 中间表示代码。 优化 PTX 优化：对 PTX 代码进行优化，以提高 GPU 执行效率。 生成 SASS 代码：将优化后的 PTX 代码编译成 SASS 机器代码，这些代码可以直接在 NVIDIA GPU 上执行。 两者的关系 用 nvcc 编译 CUDA 程序时，nvcc 会首先处理预处理、代码分离和主机代码编译等步骤。 对于 Host 代码部分调用标准的 C++ 编译器（如 g++ 或 clang）来编译。 对于 Device 代码部分，nvcc 会生成 PTX 代码，并将其传递给 ptxas。 ptxas 接收到 PTX 代码后，会对其进行优化，并将其编译成 SASS 机器代码（SASS是一种低级汇编语言,非常接近实际的GPU机器码,但仍然是人类可读的），SASS 不等同于最终的机器码。它是机器码的一种表示形式，SASS 会被进一步转换成实际的二进制机器码（cubin）。 最终，nvcc 会将 Host 代码和 Device 代码链接在一起，生成最终的可执行文件或库文件。 PTX 代码 SASS 代码 和 cubin 文件 CUDA 代码 –[nvcc]-\u003e PTX 代码(与硬件无关，低级别的汇编风格的IR) –[ptxas]-\u003e SASS 代码（特定架构的） 进一步生成 cubin 文件（特定架构的）:\nCUDA 代码 -\u003e PTX（架构无关）。 PTX -\u003e SASS（架构特定的汇编）。 SASS -\u003e cubin（二进制形式）。 SASS 是 cubin 文件的直接前身，cubin 文件是 SASS 代码的二进制形式。 可以理解为 SASS 是可读的汇编代码，而 cubin 是不可读的二进制代码，两者都针对特定的 GPU 架构。最终生成的执行文件会包含 cubin 文件（cubin 是 GPU 执行的最终指令集合），以便在运行时加载到 GPU 上执行。\n“执行文件”通常指完整的程序（主机 + GPU 代码），而 cubin 仅是 GPU 部分的二进制代码。cubin 仅包含 GPU kernel 的 SASS 指令，无法独立运行。它需要主机程序通过 CUDA 运行时（或驱动 API）加载和执行。\nJIT 编译 GPU 驱动程序可以在运行时(JIT)将 PTX 编译成特定 GPU 架构的机器码。这种 JIT 编译的结果是二进制机器码, 不是 SASS 或 cubin 。\nJIT 编译生成的二进制机器码更接近于 GPU 的硬件指令，更底层，更贴近硬件，因此在某些情况下可以获得更高的性能。 但它也牺牲了部分可移植性，因为编译过程依赖于运行时的 GPU 环境。 而传统的 SASS 和 cubin 文件则提供了更好的可移植性（在同一架构的 GPU 之间），但优化程度可能不如 JIT 编译。 两者各有优劣，选择哪种方式取决于具体的应用场景和性能需求。\nJIT 编译和传统编译的区别：\n编译时机: 传统的 CUDA 编译流程在程序运行之前 完成编译，将 PTX 代码编译成 SASS，然后打包成 cubin 文件。而 JIT 编译则在程序运行 期间，根据运行时确定的 GPU 架构和特性，动态地将 PTX 代码编译成机器码。 目标代码表示: 传统的流程生成 SASS 代码，然后将其转换为 cubin 的二进制格式。 cubin 文件虽然是二进制的，但它仍然是一种相对高级的表示，包含了指令、数据等信息，需要 GPU 的驱动程序进一步解释执行。 而 JIT 编译直接生成 GPU 的 原生机器码，这是 GPU 最底层的指令集，可以直接由 GPU 的硬件执行单元处理，无需额外的解释。 优化机会: JIT 编译器可以在运行时获得更多关于 GPU 的信息，例如可用资源、内存带宽等，从而进行更精细的优化。 这使得 JIT 编译生成的机器码可能比预先编译的 cubin 文件具有更高的性能，尤其是在处理复杂或特定于硬件的计算时。 可移植性: cubin 文件是特定于 GPU 架构的，不能在不同架构的 GPU 上直接运行。 而 JIT 编译生成的机器码也是特定于 GPU 架构的，但其优势在于，驱动程序负责处理架构差异，应用程序代码本身无需针对不同的 GPU 架构进行修改。 业界使用 JIT 的场景是怎样的？\n@ CUDA 文件如何 JIT 编译 hold\nlibcudart.so CUDA 运行时库。对于 cuda，依然可以使用 ldd 等工具查看 cuda 程序的依赖关系。CUDA 10.0及以后版本支持** Device 代码的动态链接**，使得 Device 代码也可以被编译成动态库并在运行时加载。\nlibcudart.so 是 nvidia 提供的，不是用户编译出来的，因为 cuda 不是开源的。\nnvcc 编译时指明头文件的搜索路径 使用 -I 选项: 这是最常用的方法。 -I 选项后跟头文件的目录路径。 您可以多次使用 -I 选项来指定多个目录。 nvcc 会按照您指定的顺序搜索这些目录。 使用环境变量 INCLUDE: 设置环境变量 INCLUDE 来指定额外的头文件搜索路径。 nvcc 会自动搜索 INCLUDE 环境变量中指定的目录。 这在需要在多个编译命令中使用相同的头文件路径时非常方便。 使用 Makefile: 如果您使用 Makefile 来管理编译过程，则可以在 Makefile 中指定 INCLUDE 变量， ",
  "wordCount" : "355",
  "inLanguage": "en",
  "datePublished": "2025-08-31T12:45:54+08:00",
  "dateModified": "2025-08-31T12:45:54+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ashburnLee.github.io/blog-2-hugo/cuda-notes/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Junhui's Journal 2",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ashburnLee.github.io/blog-2-hugo/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ashburnLee.github.io/blog-2-hugo/" accesskey="h" title="Junhui&#39;s Journal 2 (Alt + H)">Junhui&#39;s Journal 2</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      从源码到可执行文件
    </h1>
    <div class="post-meta"><span title='2025-08-31 12:45:54 +0800 CST'>August 31, 2025</span>

</div>
  </header> 
  <div class="post-content"><h2 id="nvcc-和-ptxas">nvcc 和 ptxas<a hidden class="anchor" aria-hidden="true" href="#nvcc-和-ptxas">#</a></h2>
<h3 id="nvccnvidia-cuda-compiler-driver">nvcc（NVIDIA CUDA Compiler Driver）<a hidden class="anchor" aria-hidden="true" href="#nvccnvidia-cuda-compiler-driver">#</a></h3>
<p>nvcc 是 NVIDIA CUDA <strong>编译器驱动程序</strong>，它负责管理整个 CUDA 编译过程。它的主要职责包括：</p>
<ul>
<li><strong>预处理</strong>：处理宏定义、头文件包含等预处理步骤。</li>
<li><strong>分离 Host 代码和 Device 代码</strong>：将 CUDA 源代码分离成 Host 代码（Host Code）和 Device 代码（Device Code）。</li>
<li><strong>编译 Host 代码</strong>：调用标准的 C++ 编译器（如 g++ 或 clang）来编译 Host 代码部分。</li>
<li><strong>编译 Device 代码</strong>：nvcc 将 device 代码编译成 PTX 代码，并传递给 ptxas 进行进一步编译。</li>
<li><strong>链接</strong>：将 Host 代码和 Device 代码链接在一起，生成最终的可执行文件或库文件。</li>
</ul>
<p><code>nvcc -ptx my_kernel.cu -o my_kernel.ptx</code> 查看对应的 PTX 代码。</p>
<h3 id="ptxasparallel-thread-execution-assembler">ptxas（Parallel Thread Execution Assembler）<a hidden class="anchor" aria-hidden="true" href="#ptxasparallel-thread-execution-assembler">#</a></h3>
<p>ptxas 是 CUDA 工具链中的汇编器，它专门负责将 PTX（Parallel Thread Execution）代码编译成 GPU 可以执行的机器代码（SASS）。它的主要职责包括：</p>
<ul>
<li>接收 PTX 代码：从 nvcc 接收 PTX 中间表示代码。</li>
<li>优化 PTX 优化：对 PTX 代码进行优化，以提高 GPU 执行效率。</li>
<li>生成 SASS 代码：将优化后的 PTX 代码编译成 SASS 机器代码，这些代码可以直接在 NVIDIA GPU 上执行。</li>
</ul>
<h3 id="两者的关系">两者的关系<a hidden class="anchor" aria-hidden="true" href="#两者的关系">#</a></h3>
<ul>
<li>用 nvcc 编译 CUDA 程序时，nvcc 会首先处理预处理、代码分离和主机代码编译等步骤。</li>
<li>对于 Host 代码部分调用标准的 C++ 编译器（如 g++ 或 clang）来编译。</li>
<li>对于 Device 代码部分，<strong>nvcc 会生成 PTX 代码，并将其传递给 ptxas</strong>。</li>
<li>ptxas 接收到 PTX 代码后，会对其进行优化，并将其编译成 SASS 机器代码（SASS是一种低级汇编语言,非常接近实际的GPU机器码,但仍然是人类可读的），SASS 不等同于最终的机器码。它是机器码的一种表示形式，SASS 会被进一步转换成实际的二进制机器码（cubin）。</li>
<li>最终，nvcc 会将 Host 代码和 Device 代码<strong>链接在一起</strong>，生成最终的可执行文件或库文件。</li>
</ul>
<h3 id="ptx-代码-sass-代码-和-cubin-文件">PTX 代码 SASS 代码 和 cubin 文件<a hidden class="anchor" aria-hidden="true" href="#ptx-代码-sass-代码-和-cubin-文件">#</a></h3>
<p>CUDA 代码 &ndash;[nvcc]-&gt; PTX 代码(与硬件无关，低级别的汇编风格的IR) &ndash;[ptxas]-&gt; <code>SASS</code> 代码（特定架构的） 进一步生成 <code>cubin</code> 文件（特定架构的）:</p>
<ul>
<li>CUDA 代码 -&gt; PTX（架构无关）。</li>
<li>PTX -&gt; SASS（架构特定的汇编）。</li>
<li>SASS -&gt; cubin（二进制形式）。</li>
</ul>
<p><code>SASS</code> 是 <code>cubin</code> 文件的直接前身，cubin 文件是 <code>SASS</code> 代码的二进制形式。 可以理解为 <code>SASS</code> 是可读的汇编代码，而 <code>cubin</code> 是不可读的二进制代码，两者都针对特定的 GPU 架构。最终生成的执行文件会<strong>包含</strong> <code>cubin</code> 文件（cubin 是 GPU 执行的最终指令集合），以便在<strong>运行时</strong>加载到 GPU 上执行。</p>
<p>“执行文件”通常指完整的程序（主机 + GPU 代码），而 <code>cubin</code> 仅是 GPU 部分的二进制代码。<code>cubin</code> 仅包含 GPU kernel 的 <code>SASS</code> 指令，无法独立运行。它需要主机程序通过 CUDA 运行时（或驱动 API）加载和执行。</p>
<h3 id="jit-编译">JIT 编译<a hidden class="anchor" aria-hidden="true" href="#jit-编译">#</a></h3>
<p>GPU 驱动程序可以在运行时(JIT)将 PTX 编译成特定 GPU 架构的机器码。这种 JIT 编译的结果是二进制机器码, 不是 <code>SASS</code> 或 <code>cubin</code> 。</p>
<p>JIT 编译生成的二进制机器码更接近于 GPU 的硬件指令，更底层，更贴近硬件，因此在某些情况下可以获得更高的性能。 但它也牺牲了部分可移植性，因为<strong>编译过程依赖于运行时的 GPU 环境</strong>。 而传统的 <code>SASS</code> 和 <code>cubin</code> 文件则提供了更好的<strong>可移植性</strong>（在同一架构的 GPU 之间），但优化程度可能不如 JIT 编译。 两者各有优劣，选择哪种方式取决于具体的应用场景和性能需求。</p>
<p>JIT 编译和传统编译的区别：</p>
<ul>
<li><strong>编译时机</strong>: 传统的 CUDA 编译流程在程序运行之前 完成编译，将 PTX 代码编译成 SASS，然后打包成 <code>cubin</code> 文件。而 JIT 编译则在程序运行 期间，根据运行时确定的 GPU 架构和特性，动态地将 PTX 代码编译成机器码。</li>
<li><strong>目标代码表示</strong>: 传统的流程生成 SASS 代码，然后将其转换为 <code>cubin</code> 的二进制格式。 <code>cubin</code> 文件虽然是二进制的，但它仍然是一种相对高级的表示，包含了指令、数据等信息，需要 GPU 的驱动程序进一步解释执行。 而 JIT 编译直接生成 GPU 的 原生机器码，这是 GPU 最底层的指令集，可以直接由 GPU 的硬件执行单元处理，无需额外的解释。</li>
<li><strong>优化机会</strong>: JIT 编译器可以在运行时获得更多关于 GPU 的信息，例如可用资源、内存带宽等，从而进行更精细的优化。 这使得 JIT 编译生成的机器码可能比预先编译的 <code>cubin</code> 文件具有更高的性能，尤其是在处理复杂或特定于硬件的计算时。</li>
<li><strong>可移植性</strong>: <code>cubin</code> 文件是特定于 GPU 架构的，不能在不同架构的 GPU 上直接运行。 而 JIT 编译生成的机器码也是特定于 GPU 架构的，但其优势在于，驱动程序负责处理架构差异，应用程序代码本身无需针对不同的 GPU 架构进行修改。</li>
</ul>
<p>业界使用 JIT 的场景是怎样的？</p>
<h3 id="-cuda-文件如何-jit-编译">@ CUDA 文件如何 JIT 编译<a hidden class="anchor" aria-hidden="true" href="#-cuda-文件如何-jit-编译">#</a></h3>
<p>hold</p>
<h2 id="libcudartso">libcudart.so<a hidden class="anchor" aria-hidden="true" href="#libcudartso">#</a></h2>
<p>CUDA 运行时库。对于 cuda，依然可以使用 <code>ldd</code> 等工具查看 cuda 程序的依赖关系。CUDA 10.0及以后版本支持** Device 代码的动态链接**，使得 Device 代码也可以被编译成动态库并在运行时加载。</p>
<p><code>libcudart.so</code> 是 nvidia 提供的，不是用户编译出来的，因为 cuda 不是开源的。</p>
<h2 id="nvcc-编译时指明头文件的搜索路径">nvcc 编译时指明头文件的搜索路径<a hidden class="anchor" aria-hidden="true" href="#nvcc-编译时指明头文件的搜索路径">#</a></h2>
<ul>
<li>使用 <code>-I</code> 选项: 这是最常用的方法。 <code>-I</code> 选项后跟头文件的目录路径。 您可以多次使用 <code>-I</code> 选项来指定多个目录。 nvcc 会按照您指定的顺序搜索这些目录。</li>
<li>使用环境变量 <code>INCLUDE</code>: 设置环境变量 <code>INCLUDE</code> 来指定额外的头文件搜索路径。 nvcc 会自动搜索 <code>INCLUDE</code> 环境变量中指定的目录。 这在需要在多个编译命令中使用相同的头文件路径时非常方便。</li>
<li>使用 Makefile: 如果您使用 Makefile 来管理编译过程，则可以在 Makefile 中指定 <code>INCLUDE</code> 变量，</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ashburnLee.github.io/blog-2-hugo/tags/cuda/">CUDA</a></li>
      <li><a href="https://ashburnLee.github.io/blog-2-hugo/tags/nvcc/">Nvcc</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://ashburnLee.github.io/blog-2-hugo/">Junhui&#39;s Journal 2</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
