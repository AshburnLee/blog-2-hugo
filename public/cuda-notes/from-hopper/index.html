<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>From Hopper | Junhui&#39;s Journal 2</title>
<meta name="keywords" content="CUDA">
<meta name="description" content="https://docs.nvidia.com/cuda/hopper-tuning-guide/index.html
NVIDIA Hopper GPU 架构保留了并扩展了之前 NVIDIA GPU 架构（如 NVIDIA Ampere GPU 架构和 NVIDIA Turing）提供的相同的 CUDA 编程模型，遵循这些架构最佳实践的应程序通常在 NVIDIA H100 GPU 上看到速度提升，无需任何代码更改。
高优先级建议如下

寻找并行化顺序代码的方法。
最小化主机与设备之间的数据传输。
调整内核启动配置以最大化设备利用率。
确保全局内存访问是 coalesced 的。
尽可能减少对全局内存的冗余访问。
尽量量避免同一warp中线程执行路径出现长时间的分歧(sequences of diverged execution)。

TODO：这个文档中还有更多的关于 Hopper 的参数。
NVIDIA Hopper 流式多处理器（SM）在 Turing 和 NVIDIA Ampere GPU 架构的基础上提供了以下改进。
每个 SM 的最大并发 warp 数量与 NVIDIA Ampere GPU 架构相同（即 64），每个 warp 需要占用一定的寄存器和共享内存等资源。SM 的资源是有限的，因此能够同时支持的 warp 数量也是有限的。如果一个 SM 上只有少数几个 warp，那么 SM 的资源可能无法充分利用，导致性能下降。资源占用率要高，并行程度也要高。
影响 warp 占用的其他因素包括：


寄存器文件大小为每个 SM 64K 个 32 位寄存器。（register个数 64x1024=65536个，每个register大小 32bit/8=4Byte, register总大小是 256 KB）">
<meta name="author" content="">
<link rel="canonical" href="https://ashburnLee.github.io/blog-2-hugo/cuda-notes/from-hopper/">
<link crossorigin="anonymous" href="/blog-2-hugo/assets/css/stylesheet.bdaf5941cb3c05e36e857d9e2953ba0c4485ba7bc2da15db169d66a77cbc7a87.css" integrity="sha256-va9ZQcs8BeNuhX2eKVO6DESFunvC2hXbFp1mp3y8eoc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ashburnLee.github.io/blog-2-hugo/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ashburnLee.github.io/blog-2-hugo/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ashburnLee.github.io/blog-2-hugo/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ashburnLee.github.io/blog-2-hugo/apple-touch-icon.png">
<link rel="mask-icon" href="https://ashburnLee.github.io/blog-2-hugo/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://ashburnLee.github.io/blog-2-hugo/cuda-notes/from-hopper/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" id="MathJax-script" async></script>


<meta property="og:url" content="https://ashburnLee.github.io/blog-2-hugo/cuda-notes/from-hopper/">
  <meta property="og:site_name" content="Junhui&#39;s Journal 2">
  <meta property="og:title" content="From Hopper">
  <meta property="og:description" content="https://docs.nvidia.com/cuda/hopper-tuning-guide/index.html
NVIDIA Hopper GPU 架构保留了并扩展了之前 NVIDIA GPU 架构（如 NVIDIA Ampere GPU 架构和 NVIDIA Turing）提供的相同的 CUDA 编程模型，遵循这些架构最佳实践的应程序通常在 NVIDIA H100 GPU 上看到速度提升，无需任何代码更改。
高优先级建议如下 寻找并行化顺序代码的方法。 最小化主机与设备之间的数据传输。 调整内核启动配置以最大化设备利用率。 确保全局内存访问是 coalesced 的。 尽可能减少对全局内存的冗余访问。 尽量量避免同一warp中线程执行路径出现长时间的分歧(sequences of diverged execution)。 TODO：这个文档中还有更多的关于 Hopper 的参数。
NVIDIA Hopper 流式多处理器（SM）在 Turing 和 NVIDIA Ampere GPU 架构的基础上提供了以下改进。 每个 SM 的最大并发 warp 数量与 NVIDIA Ampere GPU 架构相同（即 64），每个 warp 需要占用一定的寄存器和共享内存等资源。SM 的资源是有限的，因此能够同时支持的 warp 数量也是有限的。如果一个 SM 上只有少数几个 warp，那么 SM 的资源可能无法充分利用，导致性能下降。资源占用率要高，并行程度也要高。
影响 warp 占用的其他因素包括：
寄存器文件大小为每个 SM 64K 个 32 位寄存器。（register个数 64x1024=65536个，每个register大小 32bit/8=4Byte, register总大小是 256 KB）">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="cuda-notes">
    <meta property="article:published_time" content="2025-08-31T12:45:50+08:00">
    <meta property="article:modified_time" content="2025-08-31T12:45:50+08:00">
    <meta property="article:tag" content="CUDA">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="From Hopper">
<meta name="twitter:description" content="https://docs.nvidia.com/cuda/hopper-tuning-guide/index.html
NVIDIA Hopper GPU 架构保留了并扩展了之前 NVIDIA GPU 架构（如 NVIDIA Ampere GPU 架构和 NVIDIA Turing）提供的相同的 CUDA 编程模型，遵循这些架构最佳实践的应程序通常在 NVIDIA H100 GPU 上看到速度提升，无需任何代码更改。
高优先级建议如下

寻找并行化顺序代码的方法。
最小化主机与设备之间的数据传输。
调整内核启动配置以最大化设备利用率。
确保全局内存访问是 coalesced 的。
尽可能减少对全局内存的冗余访问。
尽量量避免同一warp中线程执行路径出现长时间的分歧(sequences of diverged execution)。

TODO：这个文档中还有更多的关于 Hopper 的参数。
NVIDIA Hopper 流式多处理器（SM）在 Turing 和 NVIDIA Ampere GPU 架构的基础上提供了以下改进。
每个 SM 的最大并发 warp 数量与 NVIDIA Ampere GPU 架构相同（即 64），每个 warp 需要占用一定的寄存器和共享内存等资源。SM 的资源是有限的，因此能够同时支持的 warp 数量也是有限的。如果一个 SM 上只有少数几个 warp，那么 SM 的资源可能无法充分利用，导致性能下降。资源占用率要高，并行程度也要高。
影响 warp 占用的其他因素包括：


寄存器文件大小为每个 SM 64K 个 32 位寄存器。（register个数 64x1024=65536个，每个register大小 32bit/8=4Byte, register总大小是 256 KB）">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "CUDA Notes",
      "item": "https://ashburnLee.github.io/blog-2-hugo/cuda-notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "From Hopper",
      "item": "https://ashburnLee.github.io/blog-2-hugo/cuda-notes/from-hopper/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "From Hopper",
  "name": "From Hopper",
  "description": "https://docs.nvidia.com/cuda/hopper-tuning-guide/index.html\nNVIDIA Hopper GPU 架构保留了并扩展了之前 NVIDIA GPU 架构（如 NVIDIA Ampere GPU 架构和 NVIDIA Turing）提供的相同的 CUDA 编程模型，遵循这些架构最佳实践的应程序通常在 NVIDIA H100 GPU 上看到速度提升，无需任何代码更改。\n高优先级建议如下 寻找并行化顺序代码的方法。 最小化主机与设备之间的数据传输。 调整内核启动配置以最大化设备利用率。 确保全局内存访问是 coalesced 的。 尽可能减少对全局内存的冗余访问。 尽量量避免同一warp中线程执行路径出现长时间的分歧(sequences of diverged execution)。 TODO：这个文档中还有更多的关于 Hopper 的参数。\nNVIDIA Hopper 流式多处理器（SM）在 Turing 和 NVIDIA Ampere GPU 架构的基础上提供了以下改进。 每个 SM 的最大并发 warp 数量与 NVIDIA Ampere GPU 架构相同（即 64），每个 warp 需要占用一定的寄存器和共享内存等资源。SM 的资源是有限的，因此能够同时支持的 warp 数量也是有限的。如果一个 SM 上只有少数几个 warp，那么 SM 的资源可能无法充分利用，导致性能下降。资源占用率要高，并行程度也要高。\n影响 warp 占用的其他因素包括：\n寄存器文件大小为每个 SM 64K 个 32 位寄存器。（register个数 64x1024=65536个，每个register大小 32bit/8=4Byte, register总大小是 256 KB）\n",
  "keywords": [
    "CUDA"
  ],
  "articleBody": "https://docs.nvidia.com/cuda/hopper-tuning-guide/index.html\nNVIDIA Hopper GPU 架构保留了并扩展了之前 NVIDIA GPU 架构（如 NVIDIA Ampere GPU 架构和 NVIDIA Turing）提供的相同的 CUDA 编程模型，遵循这些架构最佳实践的应程序通常在 NVIDIA H100 GPU 上看到速度提升，无需任何代码更改。\n高优先级建议如下 寻找并行化顺序代码的方法。 最小化主机与设备之间的数据传输。 调整内核启动配置以最大化设备利用率。 确保全局内存访问是 coalesced 的。 尽可能减少对全局内存的冗余访问。 尽量量避免同一warp中线程执行路径出现长时间的分歧(sequences of diverged execution)。 TODO：这个文档中还有更多的关于 Hopper 的参数。\nNVIDIA Hopper 流式多处理器（SM）在 Turing 和 NVIDIA Ampere GPU 架构的基础上提供了以下改进。 每个 SM 的最大并发 warp 数量与 NVIDIA Ampere GPU 架构相同（即 64），每个 warp 需要占用一定的寄存器和共享内存等资源。SM 的资源是有限的，因此能够同时支持的 warp 数量也是有限的。如果一个 SM 上只有少数几个 warp，那么 SM 的资源可能无法充分利用，导致性能下降。资源占用率要高，并行程度也要高。\n影响 warp 占用的其他因素包括：\n寄存器文件大小为每个 SM 64K 个 32 位寄存器。（register个数 64x1024=65536个，每个register大小 32bit/8=4Byte, register总大小是 256 KB）\n每线程的最大寄存器数量为 255。\n对于计算能力为 9.0（H100 GPU）的设备，每个 SM 的最大 block 数为 32，。\n对于计算能力为 9.0（H100 GPU）的设备，每个 SM 的 Shared mem 容量为 228KB，比 A100 的 164 KB 容量增加了 39%。\n对于计算能力为 9.0（H100 GPU）的设备，每个 Block 的最大共享内存为 227 KB。\n对于使用线程块集群的应用，始终建议使用 cudaOccupancyMaxActiveClusters 来计算占用率，并相应地启动基于集群的内核。\nTMA 张量内存加速器（TMA）允许应用程序在全局内存和共享内存之间以及同一集群（Thread Block Clusters）中不同 SM 的共享内存区域之间双向传输 1D 和最多 5D 张量（请参阅线程块集群）。此外，对于从共享内存到全局内存的写入，它允许指定逐元素累加/最小/最大等操作以及对于大多数常见数据类型的位与/或操作。\nThread Block Clusters NVIDIA Hopper 架构增加了一个新的可选层次级别，线程块集群，这为并行化应用程序提供了更多可能性。线程块可以读取、写入并对其集群内其他线程块的共享内存执行原子操作。这被称为分布式共享内存。如 CUDA C++ 编程指南所示，有些应用程序无法将所需数据放入共享内存，而必须使用全局内存。分布式共享内存可以作为这两种选项之间的中间步骤。\n内存系统 NVIDIA H100 GPU 支持 HBM3 和 HBM2e 内存，容量高达 80 GB。HBM3 内存系统支持高达 3 TB/s 的内存带宽，比 A100-40GB 上的 1.55 TB/s 提高了 93%。\n增加 L2 容量 NVIDIA Hopper 架构将 A100 GPU 中的 L2 缓存容量从 40 MB 增加到 H100 GPU 中的 50 MB。随着容量的增加，L2 缓存到 SM 的带宽也增加了。\n持久化 L2 缓存 (Persistent L2 Cache): 在 Compute Capability 8.0 及以上的设备上，CUDA 支持持久化 L2 缓存。 这允许开发者将频繁访问的数据保留在 L2 缓存中，从而减少对全局内存的访问，提高性能。 这并非直接编程缓存，而是通过 CUDA API 控制数据在 L2 缓存中的驻留时间。 你需要使用 cudaMemPrefetchAsync() 或类似函数来提示 CUDA 运行时将数据预先加载到 L2 缓存中。\n",
  "wordCount" : "205",
  "inLanguage": "en",
  "datePublished": "2025-08-31T12:45:50+08:00",
  "dateModified": "2025-08-31T12:45:50+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ashburnLee.github.io/blog-2-hugo/cuda-notes/from-hopper/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Junhui's Journal 2",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ashburnLee.github.io/blog-2-hugo/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ashburnLee.github.io/blog-2-hugo/" accesskey="h" title="Junhui&#39;s Journal 2 (Alt + H)">Junhui&#39;s Journal 2</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      From Hopper
    </h1>
    <div class="post-meta"><span title='2025-08-31 12:45:50 +0800 CST'>August 31, 2025</span>

</div>
  </header> 
  <div class="post-content"><p><a href="https://docs.nvidia.com/cuda/hopper-tuning-guide/index.html">https://docs.nvidia.com/cuda/hopper-tuning-guide/index.html</a></p>
<p>NVIDIA Hopper GPU 架构保留了并扩展了之前 NVIDIA GPU 架构（如 NVIDIA Ampere GPU 架构和 NVIDIA Turing）提供的相同的 CUDA 编程模型，遵循这些架构最佳实践的应程序通常在 NVIDIA H100 GPU 上看到速度提升，无需任何代码更改。</p>
<h2 id="高优先级建议如下">高优先级建议如下<a hidden class="anchor" aria-hidden="true" href="#高优先级建议如下">#</a></h2>
<ul>
<li>寻找并行化顺序代码的方法。</li>
<li>最小化主机与设备之间的数据传输。</li>
<li>调整内核启动配置以最大化设备利用率。</li>
<li>确保全局内存访问是 coalesced 的。</li>
<li>尽可能减少对全局内存的冗余访问。</li>
<li>尽量量避免同一warp中线程执行路径出现长时间的分歧(sequences of diverged execution)。</li>
</ul>
<p>TODO：这个文档中还有更多的关于 Hopper 的参数。</p>
<h2 id="nvidia-hopper-流式多处理器sm在-turing-和-nvidia-ampere-gpu-架构的基础上提供了以下改进">NVIDIA Hopper 流式多处理器（SM）在 Turing 和 NVIDIA Ampere GPU 架构的基础上提供了以下改进。<a hidden class="anchor" aria-hidden="true" href="#nvidia-hopper-流式多处理器sm在-turing-和-nvidia-ampere-gpu-架构的基础上提供了以下改进">#</a></h2>
<p>每个 SM 的最大并发 warp 数量与 NVIDIA Ampere GPU 架构相同（即 <strong>64</strong>），每个 warp 需要占用一定的寄存器和共享内存等资源。SM 的资源是有限的，因此能够同时支持的 warp 数量也是有限的。如果一个 SM 上只有少数几个 warp，那么 SM 的资源可能无法充分利用，导致性能下降。资源占用率要高，并行程度也要高。</p>
<p>影响 warp 占用的其他因素包括：</p>
<ul>
<li>
<p>寄存器文件大小为每个 SM 64K 个 32 位寄存器。（register个数 64x1024=<strong>65536</strong>个，每个register大小 32bit/8=4Byte, register总大小是 256 KB）</p>
</li>
<li>
<p>每线程的最大寄存器数量为 255。</p>
</li>
<li>
<p>对于计算能力为 9.0（H100 GPU）的设备，<strong>每个 SM 的最大 block 数为 32</strong>，。</p>
</li>
<li>
<p>对于计算能力为 9.0（H100 GPU）的设备，<strong>每个 SM 的 Shared mem 容量为 228KB</strong>，比 A100 的 164 KB 容量增加了 39%。</p>
</li>
<li>
<p>对于计算能力为 9.0（H100 GPU）的设备，<strong>每个 Block 的最大共享内存为 227 KB</strong>。</p>
</li>
<li>
<p>对于使用线程块集群的应用，始终建议使用 cudaOccupancyMaxActiveClusters 来计算占用率，并相应地启动基于集群的内核。</p>
</li>
</ul>
<h2 id="tma">TMA<a hidden class="anchor" aria-hidden="true" href="#tma">#</a></h2>
<p>张量内存加速器（TMA）允许应用程序在全局内存和共享内存<strong>之间</strong>以及同一集群（Thread Block Clusters）中不同 SM 的共享内存区域<strong>之间</strong>双向传输 1D 和最多 5D 张量（请参阅线程块集群）。此外，对于从共享内存到全局内存的写入，它允许指定逐元素累加/最小/最大等操作以及对于大多数常见数据类型的位与/或操作。</p>
<h2 id="thread-block-clusters">Thread Block Clusters<a hidden class="anchor" aria-hidden="true" href="#thread-block-clusters">#</a></h2>
<p>NVIDIA Hopper 架构增加了一个新的可选层次级别，线程块集群，这为并行化应用程序提供了更多可能性。线程块可以读取、写入并对其集群内其他线程块的共享内存执行原子操作。这被称为分布式共享内存。如 CUDA C++ 编程指南所示，有些应用程序无法将所需数据放入共享内存，而必须使用全局内存。分布式共享内存可以作为这两种选项之间的中间步骤。</p>
<h2 id="内存系统">内存系统<a hidden class="anchor" aria-hidden="true" href="#内存系统">#</a></h2>
<p>NVIDIA H100 GPU 支持 HBM3 和 HBM2e 内存，容量高达 <strong>80 GB</strong>。HBM3 内存系统支持高达 <strong>3 TB/s</strong> 的内存带宽，比 <strong>A100-40GB</strong> 上的 <strong>1.55 TB/s</strong> 提高了 93%。</p>
<h2 id="增加-l2-容量">增加 L2 容量<a hidden class="anchor" aria-hidden="true" href="#增加-l2-容量">#</a></h2>
<p>NVIDIA Hopper 架构将 A100 GPU 中的 L2 缓存容量从 <strong>40 MB</strong> 增加到 H100 GPU 中的 <strong>50 MB</strong>。随着容量的增加，<strong>L2 缓存到 SM 的带宽也增加了</strong>。</p>
<p>持久化 L2 缓存 (<strong>Persistent L2 Cache</strong>): 在 Compute Capability 8.0 及以上的设备上，CUDA 支持持久化 L2 缓存。 这允许开发者将频繁访问的数据保留在 L2 缓存中，从而减少对全局内存的访问，提高性能。 这并非直接编程缓存，而是通过 CUDA API 控制数据在 L2 缓存中的驻留时间。 你需要使用 <code>cudaMemPrefetchAsync()</code> 或类似函数来提示 CUDA 运行时将数据预先加载到 L2 缓存中。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ashburnLee.github.io/blog-2-hugo/tags/cuda/">CUDA</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://ashburnLee.github.io/blog-2-hugo/">Junhui&#39;s Journal 2</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
