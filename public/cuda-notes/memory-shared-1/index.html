<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Memory Shared 1 | Junhui&#39;s Journal 2</title>
<meta name="keywords" content="CUDA, Shared Memory, Bank">
<meta name="description" content="Shared Memory

片上内存，极低延迟
是每个线程块 (Thread Block) 独有的；
生命周期与创建它的线程块相同；当线程块执行完毕后，共享内存中的数据也会被释放。
用于实现高性能的协作并行算法，例如并行归约。
用于手动管理的数据缓存，减少对全局内存的访问。比如通过 Shared Mem 实现 reverse 一个数组。
共享内存可以静态分配（在编译时指定大小）或动态分配（在运行时指定大小）；
每个 SM 都有，且是有限的共享内存容量；
注意 Bank conflict
在共享内存中进行读写操作时，通常需要使用 __syncthreads() 函数进行线程同步。
每个线程块可用的共享内存量是有限的。可以使用 cudaGetDeviceProperties 函数来查询设备的共享内存大小。

分配 Shared Memory
静态分配：适用于共享内存大小在运行时保持不变的情况，在 kernel 中固定大小 vectorAddStatic&lt;&lt;&lt;blocksPerGrid, threadsPerBlock&gt;&gt;&gt;() 。它更简单，并且编译器可以进行更好的优化。
动态分配：适用于共享内存大小可能在运行时变化的情况，在启动 kernel 时 给出 vectorAddDynamic&lt;&lt;&lt;blocksPerGrid, threadsPerBlock, sharedMemSize&gt;&gt;&gt;()。
更多使用 Shared Memory 的实例：&hellip;
Bank
CUDA 共享内存被划分为多个内存 Bank，每个 Bank 在一时钟周期内只能处理一个内存请求。如果多个线程试图同时访问同一个 Bank 中的不同地址，就会发生 Bank 冲突 (Bank conflict)。这会导致内存访问串行化，降低性能。
避免 Bank 冲突的策略:


内存对齐: 确保线程访问的内存地址在不同的 Bank 中。


访问模式: 避免多个线程同时访问同一个 Bank 。 例如，如果共享内存是一个二维数组，则应避免所有线程同时访问同一列（或同一行，取决于内存布局）。">
<meta name="author" content="">
<link rel="canonical" href="https://ashburnLee.github.io/blog-2-hugo/cuda-notes/memory-shared-1/">
<link crossorigin="anonymous" href="/blog-2-hugo/assets/css/stylesheet.bdaf5941cb3c05e36e857d9e2953ba0c4485ba7bc2da15db169d66a77cbc7a87.css" integrity="sha256-va9ZQcs8BeNuhX2eKVO6DESFunvC2hXbFp1mp3y8eoc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ashburnLee.github.io/blog-2-hugo/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ashburnLee.github.io/blog-2-hugo/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ashburnLee.github.io/blog-2-hugo/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ashburnLee.github.io/blog-2-hugo/apple-touch-icon.png">
<link rel="mask-icon" href="https://ashburnLee.github.io/blog-2-hugo/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://ashburnLee.github.io/blog-2-hugo/cuda-notes/memory-shared-1/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" id="MathJax-script" async></script>


<meta property="og:url" content="https://ashburnLee.github.io/blog-2-hugo/cuda-notes/memory-shared-1/">
  <meta property="og:site_name" content="Junhui&#39;s Journal 2">
  <meta property="og:title" content="Memory Shared 1">
  <meta property="og:description" content="Shared Memory 片上内存，极低延迟 是每个线程块 (Thread Block) 独有的； 生命周期与创建它的线程块相同；当线程块执行完毕后，共享内存中的数据也会被释放。 用于实现高性能的协作并行算法，例如并行归约。 用于手动管理的数据缓存，减少对全局内存的访问。比如通过 Shared Mem 实现 reverse 一个数组。 共享内存可以静态分配（在编译时指定大小）或动态分配（在运行时指定大小）； 每个 SM 都有，且是有限的共享内存容量； 注意 Bank conflict 在共享内存中进行读写操作时，通常需要使用 __syncthreads() 函数进行线程同步。 每个线程块可用的共享内存量是有限的。可以使用 cudaGetDeviceProperties 函数来查询设备的共享内存大小。 分配 Shared Memory 静态分配：适用于共享内存大小在运行时保持不变的情况，在 kernel 中固定大小 vectorAddStatic&lt;&lt;&lt;blocksPerGrid, threadsPerBlock&gt;&gt;&gt;() 。它更简单，并且编译器可以进行更好的优化。
动态分配：适用于共享内存大小可能在运行时变化的情况，在启动 kernel 时 给出 vectorAddDynamic&lt;&lt;&lt;blocksPerGrid, threadsPerBlock, sharedMemSize&gt;&gt;&gt;()。
更多使用 Shared Memory 的实例：…
Bank CUDA 共享内存被划分为多个内存 Bank，每个 Bank 在一时钟周期内只能处理一个内存请求。如果多个线程试图同时访问同一个 Bank 中的不同地址，就会发生 Bank 冲突 (Bank conflict)。这会导致内存访问串行化，降低性能。
避免 Bank 冲突的策略:
内存对齐: 确保线程访问的内存地址在不同的 Bank 中。
访问模式: 避免多个线程同时访问同一个 Bank 。 例如，如果共享内存是一个二维数组，则应避免所有线程同时访问同一列（或同一行，取决于内存布局）。">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="cuda-notes">
    <meta property="article:published_time" content="2025-08-31T12:45:52+08:00">
    <meta property="article:modified_time" content="2025-08-31T12:45:52+08:00">
    <meta property="article:tag" content="CUDA">
    <meta property="article:tag" content="Shared Memory">
    <meta property="article:tag" content="Bank">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Memory Shared 1">
<meta name="twitter:description" content="Shared Memory

片上内存，极低延迟
是每个线程块 (Thread Block) 独有的；
生命周期与创建它的线程块相同；当线程块执行完毕后，共享内存中的数据也会被释放。
用于实现高性能的协作并行算法，例如并行归约。
用于手动管理的数据缓存，减少对全局内存的访问。比如通过 Shared Mem 实现 reverse 一个数组。
共享内存可以静态分配（在编译时指定大小）或动态分配（在运行时指定大小）；
每个 SM 都有，且是有限的共享内存容量；
注意 Bank conflict
在共享内存中进行读写操作时，通常需要使用 __syncthreads() 函数进行线程同步。
每个线程块可用的共享内存量是有限的。可以使用 cudaGetDeviceProperties 函数来查询设备的共享内存大小。

分配 Shared Memory
静态分配：适用于共享内存大小在运行时保持不变的情况，在 kernel 中固定大小 vectorAddStatic&lt;&lt;&lt;blocksPerGrid, threadsPerBlock&gt;&gt;&gt;() 。它更简单，并且编译器可以进行更好的优化。
动态分配：适用于共享内存大小可能在运行时变化的情况，在启动 kernel 时 给出 vectorAddDynamic&lt;&lt;&lt;blocksPerGrid, threadsPerBlock, sharedMemSize&gt;&gt;&gt;()。
更多使用 Shared Memory 的实例：&hellip;
Bank
CUDA 共享内存被划分为多个内存 Bank，每个 Bank 在一时钟周期内只能处理一个内存请求。如果多个线程试图同时访问同一个 Bank 中的不同地址，就会发生 Bank 冲突 (Bank conflict)。这会导致内存访问串行化，降低性能。
避免 Bank 冲突的策略:


内存对齐: 确保线程访问的内存地址在不同的 Bank 中。


访问模式: 避免多个线程同时访问同一个 Bank 。 例如，如果共享内存是一个二维数组，则应避免所有线程同时访问同一列（或同一行，取决于内存布局）。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "CUDA Notes",
      "item": "https://ashburnLee.github.io/blog-2-hugo/cuda-notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Memory Shared 1",
      "item": "https://ashburnLee.github.io/blog-2-hugo/cuda-notes/memory-shared-1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Memory Shared 1",
  "name": "Memory Shared 1",
  "description": "Shared Memory 片上内存，极低延迟 是每个线程块 (Thread Block) 独有的； 生命周期与创建它的线程块相同；当线程块执行完毕后，共享内存中的数据也会被释放。 用于实现高性能的协作并行算法，例如并行归约。 用于手动管理的数据缓存，减少对全局内存的访问。比如通过 Shared Mem 实现 reverse 一个数组。 共享内存可以静态分配（在编译时指定大小）或动态分配（在运行时指定大小）； 每个 SM 都有，且是有限的共享内存容量； 注意 Bank conflict 在共享内存中进行读写操作时，通常需要使用 __syncthreads() 函数进行线程同步。 每个线程块可用的共享内存量是有限的。可以使用 cudaGetDeviceProperties 函数来查询设备的共享内存大小。 分配 Shared Memory 静态分配：适用于共享内存大小在运行时保持不变的情况，在 kernel 中固定大小 vectorAddStatic\u0026lt;\u0026lt;\u0026lt;blocksPerGrid, threadsPerBlock\u0026gt;\u0026gt;\u0026gt;() 。它更简单，并且编译器可以进行更好的优化。\n动态分配：适用于共享内存大小可能在运行时变化的情况，在启动 kernel 时 给出 vectorAddDynamic\u0026lt;\u0026lt;\u0026lt;blocksPerGrid, threadsPerBlock, sharedMemSize\u0026gt;\u0026gt;\u0026gt;()。\n更多使用 Shared Memory 的实例：\u0026hellip;\nBank CUDA 共享内存被划分为多个内存 Bank，每个 Bank 在一时钟周期内只能处理一个内存请求。如果多个线程试图同时访问同一个 Bank 中的不同地址，就会发生 Bank 冲突 (Bank conflict)。这会导致内存访问串行化，降低性能。\n避免 Bank 冲突的策略:\n内存对齐: 确保线程访问的内存地址在不同的 Bank 中。\n访问模式: 避免多个线程同时访问同一个 Bank 。 例如，如果共享内存是一个二维数组，则应避免所有线程同时访问同一列（或同一行，取决于内存布局）。\n",
  "keywords": [
    "CUDA", "Shared Memory", "Bank"
  ],
  "articleBody": "Shared Memory 片上内存，极低延迟 是每个线程块 (Thread Block) 独有的； 生命周期与创建它的线程块相同；当线程块执行完毕后，共享内存中的数据也会被释放。 用于实现高性能的协作并行算法，例如并行归约。 用于手动管理的数据缓存，减少对全局内存的访问。比如通过 Shared Mem 实现 reverse 一个数组。 共享内存可以静态分配（在编译时指定大小）或动态分配（在运行时指定大小）； 每个 SM 都有，且是有限的共享内存容量； 注意 Bank conflict 在共享内存中进行读写操作时，通常需要使用 __syncthreads() 函数进行线程同步。 每个线程块可用的共享内存量是有限的。可以使用 cudaGetDeviceProperties 函数来查询设备的共享内存大小。 分配 Shared Memory 静态分配：适用于共享内存大小在运行时保持不变的情况，在 kernel 中固定大小 vectorAddStatic\u003c\u003c\u003e\u003e() 。它更简单，并且编译器可以进行更好的优化。\n动态分配：适用于共享内存大小可能在运行时变化的情况，在启动 kernel 时 给出 vectorAddDynamic\u003c\u003c\u003e\u003e()。\n更多使用 Shared Memory 的实例：…\nBank CUDA 共享内存被划分为多个内存 Bank，每个 Bank 在一时钟周期内只能处理一个内存请求。如果多个线程试图同时访问同一个 Bank 中的不同地址，就会发生 Bank 冲突 (Bank conflict)。这会导致内存访问串行化，降低性能。\n避免 Bank 冲突的策略:\n内存对齐: 确保线程访问的内存地址在不同的 Bank 中。\n访问模式: 避免多个线程同时访问同一个 Bank 。 例如，如果共享内存是一个二维数组，则应避免所有线程同时访问同一列（或同一行，取决于内存布局）。\n数据布局: 选择合适的数据布局，例如将数据按 Bank 进行排列，以最大限度地减少冲突。\n错位访问：通过在共享内存的声明中添加一个小的偏移量，可以避免 Bank conflict。\n交错访问：通过交错访问共享内存，可以避免 Bank conflict。\n数据对齐：确保线程访问的数据在共享内存中对齐到 Bank 宽度。例如，如果每个 Bank 宽度为 4bytes，则确保每次访问的地址是4的倍数。\nBlock 中使用 Shared Memory 一个 block 中使用的 Shared Memory 不一定是单维的。虽然 Shared Memory 的物理布局是线性的，但你可以将其逻辑地组织成多维数组。\n静态分配：\n__global__ void myKernel() { __shared__ float matrix[16][16]; // 16x16 的二维数组 // ... 使用 matrix ... } 动态分配：\n使用 extern __shared__ 声明 Shared Memory 时，你可以动态分配内存:\n__global__ void myKernel(int size) { extern __shared__ float shared_mem[]; float *matrix = shared_mem; // 将 shared_mem 视为一个指针 // ... 使用 matrix 作为二维数组 ... 需要手动计算索引 } 重要考虑:\n性能: 无论你如何逻辑地组织 Shared Memory，其底层物理布局始终是线性的。 因此，访问模式对性能至关重要。 为了最大限度地提高性能，应尽量避免 Bank conflict（银行冲突）。 这通常意味着访问元素时应尽量保持内存访问的连续性。 多维数组的访问模式需要仔细设计，以避免 Bank conflict。 索引计算: 对于动态分配的 Shared Memory，你需要自己负责索引计算，这可能会增加代码的复杂性。 大小限制: 每个 block 可用的 Shared Memory 总量是有限的。 你需要根据你的 GPU 架构和 block 大小来选择合适的多维数组大小。 Bank 的组织方式 Bank 的宽度是硬件决定的，无法通过软件配置进行更改。 同一个 Bank 中的相邻地址是不连续的。 同一个 Bank 中的相邻地址之间相差 32 * 宽（x Byte） 0, 32, 64, 96, … 这些数字表示的是共享内存地址的编号。在共享内存中，每个字节都有一个唯一的地址编号。这些地址编号从 0 开始，依次递增。 Shared Memory 的地址编号是从 0 开始，每个字节都有一个唯一的编号。*** 如下是 32 个 Bank，每个 Bank 宽 1Bytes（8位） Bank 0: 0, 32, 64, 96, 128, 160, 192, 224, ... Bank 1: 1, 33, 65, 97, 129, 161, 193, 225, ... Bank 2: 2, 34, 66, 98, 130, 162, 194, 226, ... ... Bank 31: 31, 63, 95, 127, 159, 191, 223, 255, ... 如下是 32 个 Bank，每个 Bank 宽 4Bytes（32位）这是一般情况 Bank 0: 0, 128, 256, ... Bank 1: 4, 132, 260, ... Bank 2: 8, 136, 264, ... ... Bank 31: 124, 252, 380, ... Bank 冲突 同一个 warp 中多个线程同时访问同一个 Bank 中的不同地址，会导致 Bank conflict。\n不同 warp 中的线程可以独立访问共享内存，而不会导致 Bank conflict。这是因为 warp 调度器会分别处理每个 warp 的内存访问请求。\ncase1: 一个 Warp 中的 32 个线程尝试访问 Shared Memory 中的以下地址： Thread 0: addr 0 Thread 1: addr 4 Thread 2: addr 8 ... Thread 31: addr 124 在这个例子中，每个线程访问的地址都位于不同的 Bank 中，因此不会发生 Bank conflict。\ncase2: 如果一个 Warp 中的 32 个线程尝试访问 Shared Memory 中的以下地址： Thread 0: Address 0 Thread 1: Address 0 Thread 2: Address 0 ... Thread 31: Address 0 所有线程都访问同一个地址，这不会导致 Bank conflict，因为硬件会将数据广播给所有线程.\ncase3: 如果一个 Warp 中的 32 个线程尝试访问 Shared Memory 中的以下地址： Thread 0: Address 0 Thread 1: Address 32 Thread 2: Address 64 ... Thread 31: Address 992 所有线程都尝试访问 Bank 0，这会导致严重的 Bank conflict，因为这些访问必须串行化。\n二维数组中元素在内存中的地址计算，行优先 在行优先存储中，数组的元素按照以下顺序存储：\na[0][0], a[0][1], a[0][2], ..., a[0][num_cols-1], a[1][0], a[1][1], a[1][2], ..., a[1][num_cols-1], a[2][0], a[2][1], a[2][2], ..., a[2][num_cols-1], ... a[num_rows-1][0], a[num_rows-1][1], a[num_rows-1][2], ..., a[num_rows-1][num_cols-1] 假设有一个二维数组 a[num_rows][num_cols]，我们要计算元素 a[row][col] 在内存中的地址。推导如下：\n行偏移量：要找到 a[row][col] 的地址，我们首先需要跳过 row 行。每一行有 num_cols 个元素，所以我们需要跳过 row * num_cols 个元素。 列偏移量：在跳过 row 行后，我们需要在当前行中跳过 col 个元素。 总偏移量：总共需要跳过 row * num_cols + col 个元素。 地址计算：由于每个元素占用 element_size 个字节，所以总偏移量需要乘以 element_size。最后，加上数组的起始地址 base_address，就可以得到元素 a[row][col] 在内存中的地址： Address = base_address + (row * num_cols + col) * element_size\nbase_address：表示数组在内存中的起始位置。\n",
  "wordCount" : "469",
  "inLanguage": "en",
  "datePublished": "2025-08-31T12:45:52+08:00",
  "dateModified": "2025-08-31T12:45:52+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ashburnLee.github.io/blog-2-hugo/cuda-notes/memory-shared-1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Junhui's Journal 2",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ashburnLee.github.io/blog-2-hugo/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ashburnLee.github.io/blog-2-hugo/" accesskey="h" title="Junhui&#39;s Journal 2 (Alt + H)">Junhui&#39;s Journal 2</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Memory Shared 1
    </h1>
    <div class="post-meta"><span title='2025-08-31 12:45:52 +0800 CST'>August 31, 2025</span>

</div>
  </header> 
  <div class="post-content"><h2 id="shared-memory">Shared Memory<a hidden class="anchor" aria-hidden="true" href="#shared-memory">#</a></h2>
<ul>
<li>片上内存，极低延迟</li>
<li>是每个线程块 (Thread Block) 独有的；</li>
<li>生命周期与创建它的线程块相同；当线程块执行完毕后，共享内存中的数据也会被释放。</li>
<li>用于实现高性能的协作并行算法，例如并行归约。</li>
<li>用于手动管理的数据缓存，减少对全局内存的访问。比如通过 Shared Mem 实现 reverse 一个数组。</li>
<li>共享内存可以静态分配（在编译时指定大小）或动态分配（在运行时指定大小）；</li>
<li>每个 SM 都有，且是有限的共享内存容量；</li>
<li>注意 Bank conflict</li>
<li>在共享内存中进行读写操作时，通常需要使用 <code>__syncthreads()</code> 函数进行线程同步。</li>
<li>每个线程块可用的共享内存量是有限的。可以使用 <code>cudaGetDeviceProperties</code> 函数来查询设备的共享内存大小。</li>
</ul>
<h2 id="分配-shared-memory">分配 Shared Memory<a hidden class="anchor" aria-hidden="true" href="#分配-shared-memory">#</a></h2>
<p>静态分配：适用于共享内存大小在运行时保持不变的情况，在 kernel 中固定大小 <code>vectorAddStatic&lt;&lt;&lt;blocksPerGrid, threadsPerBlock&gt;&gt;&gt;()</code> 。它更简单，并且编译器可以进行更好的优化。</p>
<p>动态分配：适用于共享内存大小可能在运行时变化的情况，在启动 kernel 时 给出 <code>vectorAddDynamic&lt;&lt;&lt;blocksPerGrid, threadsPerBlock, sharedMemSize&gt;&gt;&gt;()</code>。</p>
<p>更多使用 Shared Memory 的实例：&hellip;</p>
<h2 id="bank">Bank<a hidden class="anchor" aria-hidden="true" href="#bank">#</a></h2>
<p>CUDA 共享内存被划分为多个内存 Bank，<strong>每个 Bank 在一时钟周期内只能处理一个内存请求</strong>。如果多个线程试图同时访问同一个 Bank 中的不同地址，就会发生 Bank 冲突 (Bank conflict)。这会导致内存访问串行化，降低性能。</p>
<p>避免 Bank 冲突的策略:</p>
<ul>
<li>
<p>内存对齐: 确保线程访问的内存地址在不同的 Bank 中。</p>
</li>
<li>
<p>访问模式: 避免多个线程同时访问同一个 Bank 。 例如，如果共享内存是一个二维数组，则应避免所有线程同时访问同一列（或同一行，取决于内存布局）。</p>
</li>
<li>
<p>数据布局: 选择合适的数据布局，例如将数据按 Bank 进行排列，以最大限度地减少冲突。</p>
</li>
<li>
<p>错位访问：通过在共享内存的声明中添加一个小的偏移量，可以避免 Bank conflict。</p>
</li>
<li>
<p>交错访问：通过交错访问共享内存，可以避免 Bank conflict。</p>
</li>
<li>
<p>数据对齐：确保线程访问的数据在共享内存中对齐到 Bank 宽度。例如，如果每个 Bank 宽度为 4bytes，则确保每次访问的地址是4的倍数。</p>
</li>
</ul>
<h2 id="block-中使用-shared-memory">Block 中使用 Shared Memory<a hidden class="anchor" aria-hidden="true" href="#block-中使用-shared-memory">#</a></h2>
<p>一个 block 中使用的 Shared Memory 不一定是单维的。虽然 Shared Memory 的物理布局是线性的，但你可以将其逻辑地组织成多维数组。</p>
<ol>
<li>
<p>静态分配：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>__global__ <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">myKernel</span>() {
</span></span><span style="display:flex;"><span>  __shared__ <span style="color:#66d9ef">float</span> matrix[<span style="color:#ae81ff">16</span>][<span style="color:#ae81ff">16</span>]; <span style="color:#75715e">// 16x16 的二维数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ... 使用 matrix ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div></li>
<li>
<p>动态分配：</p>
<p>使用 <code>extern __shared__</code> 声明 Shared Memory 时，你可以动态分配内存:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>__global__ <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">myKernel</span>(<span style="color:#66d9ef">int</span> size) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">extern</span> __shared__ <span style="color:#66d9ef">float</span> shared_mem[];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">float</span> <span style="color:#f92672">*</span>matrix <span style="color:#f92672">=</span> shared_mem; <span style="color:#75715e">// 将 shared_mem 视为一个指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ... 使用 matrix 作为二维数组 ...  需要手动计算索引
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div></li>
</ol>
<p>重要考虑:</p>
<ul>
<li>性能: 无论你如何逻辑地组织 Shared Memory，其底层<strong>物理布局始终是线性</strong>的。 因此，访问模式对性能至关重要。 为了最大限度地提高性能，应尽量避免 Bank conflict（银行冲突）。 这通常意味着访问元素时应尽量保持内存访问的连续性。 多维数组的访问模式需要仔细设计，以避免 Bank conflict。</li>
<li>索引计算: 对于动态分配的 Shared Memory，你需要自己负责索引计算，这可能会增加代码的复杂性。</li>
<li>大小限制: 每个 block 可用的 Shared Memory 总量是有限的。 你需要根据你的 GPU 架构和 block 大小来选择合适的多维数组大小。</li>
</ul>
<h2 id="bank-的组织方式">Bank 的组织方式<a hidden class="anchor" aria-hidden="true" href="#bank-的组织方式">#</a></h2>
<ul>
<li>Bank 的宽度是硬件决定的，无法通过软件配置进行更改。</li>
<li>同一个 Bank 中的相邻地址是<strong>不连续的</strong>。</li>
<li>同一个 Bank 中的相邻地址之间相差 32 * 宽（x Byte）</li>
<li>0, 32, 64, 96, &hellip; 这些数字表示的是<strong>共享内存地址的编号</strong>。在共享内存中，每个字节都有一个唯一的地址编号。这些地址编号从 0 开始，依次递增。</li>
<li>Shared Memory 的地址编号是从 0 开始，<strong>每个字节都有一个唯一的编号</strong>。***</li>
</ul>
<h3 id="如下是-32-个-bank每个-bank-宽-1bytes8位">如下是 32 个 Bank，每个 Bank 宽 1Bytes（8位）<a hidden class="anchor" aria-hidden="true" href="#如下是-32-个-bank每个-bank-宽-1bytes8位">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>Bank 0: 0, 32, 64, 96, 128, 160, 192, 224, ...
</span></span><span style="display:flex;"><span>Bank 1: 1, 33, 65, 97, 129, 161, 193, 225, ...
</span></span><span style="display:flex;"><span>Bank 2: 2, 34, 66, 98, 130, 162, 194, 226, ...
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>Bank 31: 31, 63, 95, 127, 159, 191, 223, 255, ...
</span></span></code></pre></div><h3 id="如下是-32-个-bank每个-bank-宽-4bytes32位这是一般情况">如下是 32 个 Bank，每个 Bank 宽 4Bytes（32位）这是一般情况<a hidden class="anchor" aria-hidden="true" href="#如下是-32-个-bank每个-bank-宽-4bytes32位这是一般情况">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>Bank 0: 0, 128, 256, ...
</span></span><span style="display:flex;"><span>Bank 1: 4, 132, 260, ...
</span></span><span style="display:flex;"><span>Bank 2: 8, 136, 264, ...
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>Bank 31: 124, 252, 380, ...
</span></span></code></pre></div><h2 id="bank-冲突">Bank 冲突<a hidden class="anchor" aria-hidden="true" href="#bank-冲突">#</a></h2>
<p>同一个 warp 中多个线程同时访问同一个 Bank 中的不同地址，会导致 Bank conflict。</p>
<p>不同 warp 中的线程可以独立访问共享内存，而不会导致 Bank conflict。这是因为 warp 调度器会分别处理每个 warp 的内存访问请求。</p>
<h3 id="case1-一个-warp-中的-32-个线程尝试访问-shared-memory-中的以下地址">case1: 一个 Warp 中的 32 个线程尝试访问 Shared Memory 中的以下地址：<a hidden class="anchor" aria-hidden="true" href="#case1-一个-warp-中的-32-个线程尝试访问-shared-memory-中的以下地址">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>Thread 0: addr <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>Thread 1: addr <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>Thread 2: addr <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>Thread 31: addr <span style="color:#ae81ff">124</span>
</span></span></code></pre></div><p>在这个例子中，每个线程访问的<strong>地址都位于不同的 Bank 中</strong>，因此<strong>不会发生</strong> Bank conflict。</p>
<h3 id="case2-如果一个-warp-中的-32-个线程尝试访问-shared-memory-中的以下地址">case2: 如果一个 Warp 中的 32 个线程尝试访问 Shared Memory 中的以下地址：<a hidden class="anchor" aria-hidden="true" href="#case2-如果一个-warp-中的-32-个线程尝试访问-shared-memory-中的以下地址">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>Thread 0: Address <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>Thread 1: Address <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>Thread 2: Address <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>Thread 31: Address <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>所有线程都访问同一个地址，这<strong>不会导致</strong> Bank conflict，因为硬件会将数据<strong>广播</strong>给所有线程.</p>
<h3 id="case3-如果一个-warp-中的-32-个线程尝试访问-shared-memory-中的以下地址">case3: 如果一个 Warp 中的 32 个线程尝试访问 Shared Memory 中的以下地址：<a hidden class="anchor" aria-hidden="true" href="#case3-如果一个-warp-中的-32-个线程尝试访问-shared-memory-中的以下地址">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>Thread 0: Address <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>Thread 1: Address <span style="color:#ae81ff">32</span>
</span></span><span style="display:flex;"><span>Thread 2: Address <span style="color:#ae81ff">64</span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>Thread 31: Address <span style="color:#ae81ff">992</span>
</span></span></code></pre></div><p>所有线程都尝试访问 Bank 0，这会<strong>导致严重的</strong> Bank conflict，因为这些访问必须串行化。</p>
<h2 id="二维数组中元素在内存中的地址计算行优先">二维数组中元素在内存中的地址计算，行优先<a hidden class="anchor" aria-hidden="true" href="#二维数组中元素在内存中的地址计算行优先">#</a></h2>
<p>在行优先存储中，数组的元素按照以下顺序存储：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>a<span style="color:#f92672">[</span>0<span style="color:#f92672">][</span>0<span style="color:#f92672">]</span>, a<span style="color:#f92672">[</span>0<span style="color:#f92672">][</span>1<span style="color:#f92672">]</span>, a<span style="color:#f92672">[</span>0<span style="color:#f92672">][</span>2<span style="color:#f92672">]</span>, ..., a<span style="color:#f92672">[</span>0<span style="color:#f92672">][</span>num_cols-1<span style="color:#f92672">]</span>,
</span></span><span style="display:flex;"><span>a<span style="color:#f92672">[</span>1<span style="color:#f92672">][</span>0<span style="color:#f92672">]</span>, a<span style="color:#f92672">[</span>1<span style="color:#f92672">][</span>1<span style="color:#f92672">]</span>, a<span style="color:#f92672">[</span>1<span style="color:#f92672">][</span>2<span style="color:#f92672">]</span>, ..., a<span style="color:#f92672">[</span>1<span style="color:#f92672">][</span>num_cols-1<span style="color:#f92672">]</span>,
</span></span><span style="display:flex;"><span>a<span style="color:#f92672">[</span>2<span style="color:#f92672">][</span>0<span style="color:#f92672">]</span>, a<span style="color:#f92672">[</span>2<span style="color:#f92672">][</span>1<span style="color:#f92672">]</span>, a<span style="color:#f92672">[</span>2<span style="color:#f92672">][</span>2<span style="color:#f92672">]</span>, ..., a<span style="color:#f92672">[</span>2<span style="color:#f92672">][</span>num_cols-1<span style="color:#f92672">]</span>,
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>a<span style="color:#f92672">[</span>num_rows-1<span style="color:#f92672">][</span>0<span style="color:#f92672">]</span>, a<span style="color:#f92672">[</span>num_rows-1<span style="color:#f92672">][</span>1<span style="color:#f92672">]</span>, a<span style="color:#f92672">[</span>num_rows-1<span style="color:#f92672">][</span>2<span style="color:#f92672">]</span>, ..., a<span style="color:#f92672">[</span>num_rows-1<span style="color:#f92672">][</span>num_cols-1<span style="color:#f92672">]</span>
</span></span></code></pre></div><p>假设有一个二维数组 <code>a[num_rows][num_cols]</code>，我们要计算元素 <code>a[row][col]</code> 在内存中的地址。推导如下：</p>
<ol>
<li>行偏移量：要找到 <code>a[row][col]</code> 的地址，我们首先需要跳过 <code>row</code> 行。每一行有 <code>num_cols</code> 个元素，所以我们需要跳过 <code>row * num_cols</code> 个元素。</li>
<li>列偏移量：在跳过 <code>row</code> 行后，我们需要在当前行中跳过 <code>col</code> 个元素。</li>
<li>总偏移量：总共需要跳过 <code>row * num_cols + col</code> 个元素。</li>
<li>地址计算：由于每个元素占用 <code>element_size</code> 个字节，所以总偏移量需要乘以 <code>element_size</code>。最后，加上数组的起始地址 <code>base_address</code>，就可以得到元素 <code>a[row][col]</code> 在内存中的地址：</li>
</ol>
<p><code>Address = base_address + (row * num_cols + col) * element_size</code></p>
<p><code>base_address</code>：表示数组在内存中的起始位置。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ashburnLee.github.io/blog-2-hugo/tags/cuda/">CUDA</a></li>
      <li><a href="https://ashburnLee.github.io/blog-2-hugo/tags/shared-memory/">Shared Memory</a></li>
      <li><a href="https://ashburnLee.github.io/blog-2-hugo/tags/bank/">Bank</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://ashburnLee.github.io/blog-2-hugo/">Junhui&#39;s Journal 2</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
