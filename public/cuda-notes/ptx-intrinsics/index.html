<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>PTX Intrinsics | Junhui&#39;s Journal 2</title>
<meta name="keywords" content="CUDA, Intrinsics">
<meta name="description" content="Intrinsic
NVIDIA GPU intrinsics 提供了一种在 CUDA 或其他支持的编程模型中直接访问底层 GPU 硬件功能的方式.
Intrinsics 是更高级的抽象，允许开发者在 C/C&#43;&#43; 代码中使用类似函数调用的方式来访问 GPU 指令.
PTX
PTX (Parallel Thread Execution) 是一种低级并行线程执行的虚拟指令集架构，作为 CUDA 程序的中间表示。CUDA 编译器将 CUDA 代码编译成 PTX 代码，然后 PTX 代码再由驱动程序即时编译 (JIT) 成目标 GPU 的机器码。
PTX 是一种汇编级别的指令集，更接近底层硬件。所以手写 PTX 是复杂，
DeepSeek 项目展示了如何使用 PTX 绕过 CUDA 的限制，从而实现更高效的 GPU 编程。这种方法不仅提升了性能，还展示了在有限算力资源下如何进行创新和突破.
实际应用中，需要根据具体的算法和硬件特性进行更深入的优化。
直接编写 PTX 代码通常只在对性能有极致要求的场景下使用。在大多数情况下，使用高级CUDA C/C&#43;&#43;代码，并结合NVIDIA提供的性能分析工具（如Nsight Systems和Nsight Compute）进行优化，可以获得更好的开发效率和可维护性。
关系
当在 CUDA 代码中使用 intrinsics 时，CUDA 编译器会将这些 intrinsics 转换为相应的 PTX 指令。如，一个 warp shuffle intrinsic 可能会被编译成 shfl PTX 指令。">
<meta name="author" content="">
<link rel="canonical" href="https://ashburnLee.github.io/blog-2-hugo/cuda-notes/ptx-intrinsics/">
<link crossorigin="anonymous" href="/blog-2-hugo/assets/css/stylesheet.bdaf5941cb3c05e36e857d9e2953ba0c4485ba7bc2da15db169d66a77cbc7a87.css" integrity="sha256-va9ZQcs8BeNuhX2eKVO6DESFunvC2hXbFp1mp3y8eoc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ashburnLee.github.io/blog-2-hugo/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ashburnLee.github.io/blog-2-hugo/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ashburnLee.github.io/blog-2-hugo/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ashburnLee.github.io/blog-2-hugo/apple-touch-icon.png">
<link rel="mask-icon" href="https://ashburnLee.github.io/blog-2-hugo/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://ashburnLee.github.io/blog-2-hugo/cuda-notes/ptx-intrinsics/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" id="MathJax-script" async></script>


<meta property="og:url" content="https://ashburnLee.github.io/blog-2-hugo/cuda-notes/ptx-intrinsics/">
  <meta property="og:site_name" content="Junhui&#39;s Journal 2">
  <meta property="og:title" content="PTX Intrinsics">
  <meta property="og:description" content="Intrinsic NVIDIA GPU intrinsics 提供了一种在 CUDA 或其他支持的编程模型中直接访问底层 GPU 硬件功能的方式.
Intrinsics 是更高级的抽象，允许开发者在 C/C&#43;&#43; 代码中使用类似函数调用的方式来访问 GPU 指令.
PTX PTX (Parallel Thread Execution) 是一种低级并行线程执行的虚拟指令集架构，作为 CUDA 程序的中间表示。CUDA 编译器将 CUDA 代码编译成 PTX 代码，然后 PTX 代码再由驱动程序即时编译 (JIT) 成目标 GPU 的机器码。
PTX 是一种汇编级别的指令集，更接近底层硬件。所以手写 PTX 是复杂，
DeepSeek 项目展示了如何使用 PTX 绕过 CUDA 的限制，从而实现更高效的 GPU 编程。这种方法不仅提升了性能，还展示了在有限算力资源下如何进行创新和突破.
实际应用中，需要根据具体的算法和硬件特性进行更深入的优化。
直接编写 PTX 代码通常只在对性能有极致要求的场景下使用。在大多数情况下，使用高级CUDA C/C&#43;&#43;代码，并结合NVIDIA提供的性能分析工具（如Nsight Systems和Nsight Compute）进行优化，可以获得更好的开发效率和可维护性。
关系 当在 CUDA 代码中使用 intrinsics 时，CUDA 编译器会将这些 intrinsics 转换为相应的 PTX 指令。如，一个 warp shuffle intrinsic 可能会被编译成 shfl PTX 指令。">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="cuda-notes">
    <meta property="article:published_time" content="2025-08-31T12:45:49+08:00">
    <meta property="article:modified_time" content="2025-08-31T12:45:49+08:00">
    <meta property="article:tag" content="CUDA">
    <meta property="article:tag" content="Intrinsics">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PTX Intrinsics">
<meta name="twitter:description" content="Intrinsic
NVIDIA GPU intrinsics 提供了一种在 CUDA 或其他支持的编程模型中直接访问底层 GPU 硬件功能的方式.
Intrinsics 是更高级的抽象，允许开发者在 C/C&#43;&#43; 代码中使用类似函数调用的方式来访问 GPU 指令.
PTX
PTX (Parallel Thread Execution) 是一种低级并行线程执行的虚拟指令集架构，作为 CUDA 程序的中间表示。CUDA 编译器将 CUDA 代码编译成 PTX 代码，然后 PTX 代码再由驱动程序即时编译 (JIT) 成目标 GPU 的机器码。
PTX 是一种汇编级别的指令集，更接近底层硬件。所以手写 PTX 是复杂，
DeepSeek 项目展示了如何使用 PTX 绕过 CUDA 的限制，从而实现更高效的 GPU 编程。这种方法不仅提升了性能，还展示了在有限算力资源下如何进行创新和突破.
实际应用中，需要根据具体的算法和硬件特性进行更深入的优化。
直接编写 PTX 代码通常只在对性能有极致要求的场景下使用。在大多数情况下，使用高级CUDA C/C&#43;&#43;代码，并结合NVIDIA提供的性能分析工具（如Nsight Systems和Nsight Compute）进行优化，可以获得更好的开发效率和可维护性。
关系
当在 CUDA 代码中使用 intrinsics 时，CUDA 编译器会将这些 intrinsics 转换为相应的 PTX 指令。如，一个 warp shuffle intrinsic 可能会被编译成 shfl PTX 指令。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "CUDA Notes",
      "item": "https://ashburnLee.github.io/blog-2-hugo/cuda-notes/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "PTX Intrinsics",
      "item": "https://ashburnLee.github.io/blog-2-hugo/cuda-notes/ptx-intrinsics/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "PTX Intrinsics",
  "name": "PTX Intrinsics",
  "description": "Intrinsic NVIDIA GPU intrinsics 提供了一种在 CUDA 或其他支持的编程模型中直接访问底层 GPU 硬件功能的方式.\nIntrinsics 是更高级的抽象，允许开发者在 C/C++ 代码中使用类似函数调用的方式来访问 GPU 指令.\nPTX PTX (Parallel Thread Execution) 是一种低级并行线程执行的虚拟指令集架构，作为 CUDA 程序的中间表示。CUDA 编译器将 CUDA 代码编译成 PTX 代码，然后 PTX 代码再由驱动程序即时编译 (JIT) 成目标 GPU 的机器码。\nPTX 是一种汇编级别的指令集，更接近底层硬件。所以手写 PTX 是复杂，\nDeepSeek 项目展示了如何使用 PTX 绕过 CUDA 的限制，从而实现更高效的 GPU 编程。这种方法不仅提升了性能，还展示了在有限算力资源下如何进行创新和突破.\n实际应用中，需要根据具体的算法和硬件特性进行更深入的优化。\n直接编写 PTX 代码通常只在对性能有极致要求的场景下使用。在大多数情况下，使用高级CUDA C/C++代码，并结合NVIDIA提供的性能分析工具（如Nsight Systems和Nsight Compute）进行优化，可以获得更好的开发效率和可维护性。\n关系 当在 CUDA 代码中使用 intrinsics 时，CUDA 编译器会将这些 intrinsics 转换为相应的 PTX 指令。如，一个 warp shuffle intrinsic 可能会被编译成 shfl PTX 指令。\n",
  "keywords": [
    "CUDA", "Intrinsics"
  ],
  "articleBody": "Intrinsic NVIDIA GPU intrinsics 提供了一种在 CUDA 或其他支持的编程模型中直接访问底层 GPU 硬件功能的方式.\nIntrinsics 是更高级的抽象，允许开发者在 C/C++ 代码中使用类似函数调用的方式来访问 GPU 指令.\nPTX PTX (Parallel Thread Execution) 是一种低级并行线程执行的虚拟指令集架构，作为 CUDA 程序的中间表示。CUDA 编译器将 CUDA 代码编译成 PTX 代码，然后 PTX 代码再由驱动程序即时编译 (JIT) 成目标 GPU 的机器码。\nPTX 是一种汇编级别的指令集，更接近底层硬件。所以手写 PTX 是复杂，\nDeepSeek 项目展示了如何使用 PTX 绕过 CUDA 的限制，从而实现更高效的 GPU 编程。这种方法不仅提升了性能，还展示了在有限算力资源下如何进行创新和突破.\n实际应用中，需要根据具体的算法和硬件特性进行更深入的优化。\n直接编写 PTX 代码通常只在对性能有极致要求的场景下使用。在大多数情况下，使用高级CUDA C/C++代码，并结合NVIDIA提供的性能分析工具（如Nsight Systems和Nsight Compute）进行优化，可以获得更好的开发效率和可维护性。\n关系 当在 CUDA 代码中使用 intrinsics 时，CUDA 编译器会将这些 intrinsics 转换为相应的 PTX 指令。如，一个 warp shuffle intrinsic 可能会被编译成 shfl PTX 指令。\n例如，在 CUDA 中，你可以使用 __shfl_xor_sync intrinsic 来执行 warp shuffle 操作。这个 intrinsic 会被编译成 PTX 指令 shfl.xor，该指令在 warp 内的不同线程之间交换数据。\n",
  "wordCount" : "87",
  "inLanguage": "en",
  "datePublished": "2025-08-31T12:45:49+08:00",
  "dateModified": "2025-08-31T12:45:49+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ashburnLee.github.io/blog-2-hugo/cuda-notes/ptx-intrinsics/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Junhui's Journal 2",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ashburnLee.github.io/blog-2-hugo/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ashburnLee.github.io/blog-2-hugo/" accesskey="h" title="Junhui&#39;s Journal 2 (Alt + H)">Junhui&#39;s Journal 2</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      PTX Intrinsics
    </h1>
    <div class="post-meta"><span title='2025-08-31 12:45:49 +0800 CST'>August 31, 2025</span>

</div>
  </header> 
  <div class="post-content"><h2 id="intrinsic">Intrinsic<a hidden class="anchor" aria-hidden="true" href="#intrinsic">#</a></h2>
<p>NVIDIA GPU intrinsics 提供了一种在 CUDA 或其他支持的编程模型中直接访问底层 GPU 硬件功能的方式.</p>
<p>Intrinsics 是<strong>更高级的抽象</strong>，允许开发者在 C/C++ 代码中使用类似函数调用的方式来访问 GPU 指令.</p>
<h2 id="ptx">PTX<a hidden class="anchor" aria-hidden="true" href="#ptx">#</a></h2>
<p>PTX (Parallel Thread Execution) 是一种低级并行线程执行的虚拟指令集架构，作为 CUDA 程序的中间表示。CUDA 编译器将 CUDA 代码编译成 PTX 代码，然后 PTX 代码再由驱动程序即时编译 (JIT) 成目标 GPU 的机器码。</p>
<p>PTX 是一种汇编级别的指令集，更接近底层硬件。所以手写 PTX 是复杂，</p>
<p>DeepSeek 项目展示了如何使用 PTX 绕过 CUDA 的限制，从而实现更高效的 GPU 编程。这种方法不仅提升了性能，还展示了在有限算力资源下如何进行创新和突破.</p>
<p>实际应用中，需要根据具体的<strong>算法和硬件特性</strong>进行更深入的优化。</p>
<p>直接编写 PTX 代码通常只在对<strong>性能有极致要求</strong>的场景下使用。在大多数情况下，使用高级CUDA C/C++代码，并结合NVIDIA提供的性能分析工具（如Nsight Systems和Nsight Compute）进行优化，可以获得更好的开发效率和可维护性。</p>
<h2 id="关系">关系<a hidden class="anchor" aria-hidden="true" href="#关系">#</a></h2>
<p>当在 CUDA 代码中使用 intrinsics 时，CUDA 编译器会将这些 intrinsics 转换为相应的 PTX 指令。如，一个 <code>warp shuffle</code> intrinsic 可能会被编译成 <code>shfl</code> PTX 指令。</p>
<p>例如，在 CUDA 中，你可以使用 <code>__shfl_xor_sync</code> intrinsic 来执行 <code>warp shuffle</code> 操作。这个 intrinsic 会被编译成 PTX 指令 <code>shfl.xor</code>，该指令在 warp 内的不同线程之间交换数据。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ashburnLee.github.io/blog-2-hugo/tags/cuda/">CUDA</a></li>
      <li><a href="https://ashburnLee.github.io/blog-2-hugo/tags/intrinsics/">Intrinsics</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://ashburnLee.github.io/blog-2-hugo/">Junhui&#39;s Journal 2</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
