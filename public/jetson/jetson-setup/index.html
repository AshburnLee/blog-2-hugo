<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Jetson Setup | Junhui&#39;s Journal 2</title>
<meta name="keywords" content="Jetson">
<meta name="description" content="NVIDIA Orin 是一款专为自动驾驶汽车和机器人设计的高性能系统级芯片，包含新一代 Ampere GPU 架构和 Arm Hercules CPU 内核，以及深度学习加速器和计算机视觉加速器。
应用领域：Orin 芯片不仅适用于自动驾驶汽车，还广泛应用于机器人、工业边缘计算等领域。
支持C/C&#43;&#43;, python, cuda, pytorch, ROS (Robot Operating System), JetPack SDK, DeepStream, VScode
TensorRT 是 NVIDIA 开发的一个高性能深度学习推理 SDK。它不是完全开源的.
Linux for Tegra (L4T) 是 NVIDIA 为其 Tegra 系列系统芯片 (SoC) 开发的嵌入式 Linux 发行版。它主要用于 NVIDIA Jetson 系列开发套件等嵌入式系统。L4T 提供了运行在 Tegra SoC 上的内核、驱动程序、库和工具，支持各种应用，包括机器人、人工智能、自动驾驶和媒体处理等。 它包含了 NVIDIA 专有的驱动程序，以充分利用 Tegra SoC 的硬件加速功能。不同的 L4T 版本支持不同的 Tegra 系列芯片和功能。 例如，较新的版本可能支持 Vulkan 和更新的 CUDA 版本。 开发者可以使用 L4T 来构建和部署各种嵌入式应用。
配置Jetson Orin Nano
记录命令
linux ip: &lt;linux-ip&gt;
uname: junhui

sudo apt-get update
sudo apt-get install python3-pip
sudo pip3 install -U jetson-stats
sudo jtop

sudo poweroff

systemctl status bluetooth
systemctl start bluetooth

iwconfig  # 看网速等网络状态
install Jetpack
# 找不到 nvcc 编译器
sudo apt install nvidia-jetpack  # 8GB 内容
find / -name &#34;nvcc&#34; 2&gt;/dev/null

export CUDA_HOME=/usr/local/cuda-12.6
export PATH=$PATH:$CUDA_HOME/bin
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$CUDA_HOME/lib64

# 找到 sample code
find / -name &#34;vectorAdd.cu&#34; 2&gt;/dev/null 
bash /usr/local/cuda-11.4/bin/cuda-install-samples-11.4.sh ./  #拷贝 samples 到指定路径

# 验证：(默认找不到头文件，只能指明-I)
nvcc $CUDA_HOME/samples/0_Simple/vectorAdd/vectorAdd.cu -I/usr/local/cuda-11.4/samples/common/inc/ -o vectorAdd

nvcc vectorAdd.cu -I/home/junhui/workspace/NVIDIA_CUDA-11.4_Samples/common/inc/ -o vectorAdd
nvcc deviceQuery.cpp -I/home/junhui/workspace/NVIDIA_CUDA-11.4_Samples/common/inc -o deviceQuery

# 检查
dpkg -l | grep nvidia  #这个命令会列出所有安装的与 &#34;nvidia&#34; 相关的软件包。
dpkg -l | grep nvidia 获取一个大致的组件列表，然后使用 apt-cache show 命令查看特定组件的详细信息
主机连接 Orin 最佳实践
假如没有外接显示器和鼠标键盘。">
<meta name="author" content="">
<link rel="canonical" href="https://ashburnLee.github.io/blog-2-hugo/jetson/jetson-setup/">
<link crossorigin="anonymous" href="/blog-2-hugo/assets/css/stylesheet.bdaf5941cb3c05e36e857d9e2953ba0c4485ba7bc2da15db169d66a77cbc7a87.css" integrity="sha256-va9ZQcs8BeNuhX2eKVO6DESFunvC2hXbFp1mp3y8eoc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ashburnLee.github.io/blog-2-hugo/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ashburnLee.github.io/blog-2-hugo/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ashburnLee.github.io/blog-2-hugo/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ashburnLee.github.io/blog-2-hugo/apple-touch-icon.png">
<link rel="mask-icon" href="https://ashburnLee.github.io/blog-2-hugo/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://ashburnLee.github.io/blog-2-hugo/jetson/jetson-setup/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" id="MathJax-script" async></script>


<meta property="og:url" content="https://ashburnLee.github.io/blog-2-hugo/jetson/jetson-setup/">
  <meta property="og:site_name" content="Junhui&#39;s Journal 2">
  <meta property="og:title" content="Jetson Setup">
  <meta property="og:description" content="NVIDIA Orin 是一款专为自动驾驶汽车和机器人设计的高性能系统级芯片，包含新一代 Ampere GPU 架构和 Arm Hercules CPU 内核，以及深度学习加速器和计算机视觉加速器。
应用领域：Orin 芯片不仅适用于自动驾驶汽车，还广泛应用于机器人、工业边缘计算等领域。
支持C/C&#43;&#43;, python, cuda, pytorch, ROS (Robot Operating System), JetPack SDK, DeepStream, VScode
TensorRT 是 NVIDIA 开发的一个高性能深度学习推理 SDK。它不是完全开源的.
Linux for Tegra (L4T) 是 NVIDIA 为其 Tegra 系列系统芯片 (SoC) 开发的嵌入式 Linux 发行版。它主要用于 NVIDIA Jetson 系列开发套件等嵌入式系统。L4T 提供了运行在 Tegra SoC 上的内核、驱动程序、库和工具，支持各种应用，包括机器人、人工智能、自动驾驶和媒体处理等。 它包含了 NVIDIA 专有的驱动程序，以充分利用 Tegra SoC 的硬件加速功能。不同的 L4T 版本支持不同的 Tegra 系列芯片和功能。 例如，较新的版本可能支持 Vulkan 和更新的 CUDA 版本。 开发者可以使用 L4T 来构建和部署各种嵌入式应用。
配置Jetson Orin Nano 记录命令 linux ip: &lt;linux-ip&gt; uname: junhui sudo apt-get update sudo apt-get install python3-pip sudo pip3 install -U jetson-stats sudo jtop sudo poweroff systemctl status bluetooth systemctl start bluetooth iwconfig # 看网速等网络状态 install Jetpack # 找不到 nvcc 编译器 sudo apt install nvidia-jetpack # 8GB 内容 find / -name &#34;nvcc&#34; 2&gt;/dev/null export CUDA_HOME=/usr/local/cuda-12.6 export PATH=$PATH:$CUDA_HOME/bin export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$CUDA_HOME/lib64 # 找到 sample code find / -name &#34;vectorAdd.cu&#34; 2&gt;/dev/null bash /usr/local/cuda-11.4/bin/cuda-install-samples-11.4.sh ./ #拷贝 samples 到指定路径 # 验证：(默认找不到头文件，只能指明-I) nvcc $CUDA_HOME/samples/0_Simple/vectorAdd/vectorAdd.cu -I/usr/local/cuda-11.4/samples/common/inc/ -o vectorAdd nvcc vectorAdd.cu -I/home/junhui/workspace/NVIDIA_CUDA-11.4_Samples/common/inc/ -o vectorAdd nvcc deviceQuery.cpp -I/home/junhui/workspace/NVIDIA_CUDA-11.4_Samples/common/inc -o deviceQuery # 检查 dpkg -l | grep nvidia #这个命令会列出所有安装的与 &#34;nvidia&#34; 相关的软件包。 dpkg -l | grep nvidia 获取一个大致的组件列表，然后使用 apt-cache show 命令查看特定组件的详细信息 主机连接 Orin 最佳实践 假如没有外接显示器和鼠标键盘。">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="jetson">
    <meta property="article:published_time" content="2025-08-31T12:47:02+08:00">
    <meta property="article:modified_time" content="2025-08-31T12:47:02+08:00">
    <meta property="article:tag" content="Jetson">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jetson Setup">
<meta name="twitter:description" content="NVIDIA Orin 是一款专为自动驾驶汽车和机器人设计的高性能系统级芯片，包含新一代 Ampere GPU 架构和 Arm Hercules CPU 内核，以及深度学习加速器和计算机视觉加速器。
应用领域：Orin 芯片不仅适用于自动驾驶汽车，还广泛应用于机器人、工业边缘计算等领域。
支持C/C&#43;&#43;, python, cuda, pytorch, ROS (Robot Operating System), JetPack SDK, DeepStream, VScode
TensorRT 是 NVIDIA 开发的一个高性能深度学习推理 SDK。它不是完全开源的.
Linux for Tegra (L4T) 是 NVIDIA 为其 Tegra 系列系统芯片 (SoC) 开发的嵌入式 Linux 发行版。它主要用于 NVIDIA Jetson 系列开发套件等嵌入式系统。L4T 提供了运行在 Tegra SoC 上的内核、驱动程序、库和工具，支持各种应用，包括机器人、人工智能、自动驾驶和媒体处理等。 它包含了 NVIDIA 专有的驱动程序，以充分利用 Tegra SoC 的硬件加速功能。不同的 L4T 版本支持不同的 Tegra 系列芯片和功能。 例如，较新的版本可能支持 Vulkan 和更新的 CUDA 版本。 开发者可以使用 L4T 来构建和部署各种嵌入式应用。
配置Jetson Orin Nano
记录命令
linux ip: &lt;linux-ip&gt;
uname: junhui

sudo apt-get update
sudo apt-get install python3-pip
sudo pip3 install -U jetson-stats
sudo jtop

sudo poweroff

systemctl status bluetooth
systemctl start bluetooth

iwconfig  # 看网速等网络状态
install Jetpack
# 找不到 nvcc 编译器
sudo apt install nvidia-jetpack  # 8GB 内容
find / -name &#34;nvcc&#34; 2&gt;/dev/null

export CUDA_HOME=/usr/local/cuda-12.6
export PATH=$PATH:$CUDA_HOME/bin
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$CUDA_HOME/lib64

# 找到 sample code
find / -name &#34;vectorAdd.cu&#34; 2&gt;/dev/null 
bash /usr/local/cuda-11.4/bin/cuda-install-samples-11.4.sh ./  #拷贝 samples 到指定路径

# 验证：(默认找不到头文件，只能指明-I)
nvcc $CUDA_HOME/samples/0_Simple/vectorAdd/vectorAdd.cu -I/usr/local/cuda-11.4/samples/common/inc/ -o vectorAdd

nvcc vectorAdd.cu -I/home/junhui/workspace/NVIDIA_CUDA-11.4_Samples/common/inc/ -o vectorAdd
nvcc deviceQuery.cpp -I/home/junhui/workspace/NVIDIA_CUDA-11.4_Samples/common/inc -o deviceQuery

# 检查
dpkg -l | grep nvidia  #这个命令会列出所有安装的与 &#34;nvidia&#34; 相关的软件包。
dpkg -l | grep nvidia 获取一个大致的组件列表，然后使用 apt-cache show 命令查看特定组件的详细信息
主机连接 Orin 最佳实践
假如没有外接显示器和鼠标键盘。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Jetson",
      "item": "https://ashburnLee.github.io/blog-2-hugo/jetson/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Jetson Setup",
      "item": "https://ashburnLee.github.io/blog-2-hugo/jetson/jetson-setup/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Jetson Setup",
  "name": "Jetson Setup",
  "description": "NVIDIA Orin 是一款专为自动驾驶汽车和机器人设计的高性能系统级芯片，包含新一代 Ampere GPU 架构和 Arm Hercules CPU 内核，以及深度学习加速器和计算机视觉加速器。\n应用领域：Orin 芯片不仅适用于自动驾驶汽车，还广泛应用于机器人、工业边缘计算等领域。\n支持C/C++, python, cuda, pytorch, ROS (Robot Operating System), JetPack SDK, DeepStream, VScode\nTensorRT 是 NVIDIA 开发的一个高性能深度学习推理 SDK。它不是完全开源的.\nLinux for Tegra (L4T) 是 NVIDIA 为其 Tegra 系列系统芯片 (SoC) 开发的嵌入式 Linux 发行版。它主要用于 NVIDIA Jetson 系列开发套件等嵌入式系统。L4T 提供了运行在 Tegra SoC 上的内核、驱动程序、库和工具，支持各种应用，包括机器人、人工智能、自动驾驶和媒体处理等。 它包含了 NVIDIA 专有的驱动程序，以充分利用 Tegra SoC 的硬件加速功能。不同的 L4T 版本支持不同的 Tegra 系列芯片和功能。 例如，较新的版本可能支持 Vulkan 和更新的 CUDA 版本。 开发者可以使用 L4T 来构建和部署各种嵌入式应用。\n配置Jetson Orin Nano 记录命令 linux ip: \u0026lt;linux-ip\u0026gt; uname: junhui sudo apt-get update sudo apt-get install python3-pip sudo pip3 install -U jetson-stats sudo jtop sudo poweroff systemctl status bluetooth systemctl start bluetooth iwconfig # 看网速等网络状态 install Jetpack # 找不到 nvcc 编译器 sudo apt install nvidia-jetpack # 8GB 内容 find / -name \u0026#34;nvcc\u0026#34; 2\u0026gt;/dev/null export CUDA_HOME=/usr/local/cuda-12.6 export PATH=$PATH:$CUDA_HOME/bin export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$CUDA_HOME/lib64 # 找到 sample code find / -name \u0026#34;vectorAdd.cu\u0026#34; 2\u0026gt;/dev/null bash /usr/local/cuda-11.4/bin/cuda-install-samples-11.4.sh ./ #拷贝 samples 到指定路径 # 验证：(默认找不到头文件，只能指明-I) nvcc $CUDA_HOME/samples/0_Simple/vectorAdd/vectorAdd.cu -I/usr/local/cuda-11.4/samples/common/inc/ -o vectorAdd nvcc vectorAdd.cu -I/home/junhui/workspace/NVIDIA_CUDA-11.4_Samples/common/inc/ -o vectorAdd nvcc deviceQuery.cpp -I/home/junhui/workspace/NVIDIA_CUDA-11.4_Samples/common/inc -o deviceQuery # 检查 dpkg -l | grep nvidia #这个命令会列出所有安装的与 \u0026#34;nvidia\u0026#34; 相关的软件包。 dpkg -l | grep nvidia 获取一个大致的组件列表，然后使用 apt-cache show 命令查看特定组件的详细信息 主机连接 Orin 最佳实践 假如没有外接显示器和鼠标键盘。\n",
  "keywords": [
    "Jetson"
  ],
  "articleBody": "NVIDIA Orin 是一款专为自动驾驶汽车和机器人设计的高性能系统级芯片，包含新一代 Ampere GPU 架构和 Arm Hercules CPU 内核，以及深度学习加速器和计算机视觉加速器。\n应用领域：Orin 芯片不仅适用于自动驾驶汽车，还广泛应用于机器人、工业边缘计算等领域。\n支持C/C++, python, cuda, pytorch, ROS (Robot Operating System), JetPack SDK, DeepStream, VScode\nTensorRT 是 NVIDIA 开发的一个高性能深度学习推理 SDK。它不是完全开源的.\nLinux for Tegra (L4T) 是 NVIDIA 为其 Tegra 系列系统芯片 (SoC) 开发的嵌入式 Linux 发行版。它主要用于 NVIDIA Jetson 系列开发套件等嵌入式系统。L4T 提供了运行在 Tegra SoC 上的内核、驱动程序、库和工具，支持各种应用，包括机器人、人工智能、自动驾驶和媒体处理等。 它包含了 NVIDIA 专有的驱动程序，以充分利用 Tegra SoC 的硬件加速功能。不同的 L4T 版本支持不同的 Tegra 系列芯片和功能。 例如，较新的版本可能支持 Vulkan 和更新的 CUDA 版本。 开发者可以使用 L4T 来构建和部署各种嵌入式应用。\n配置Jetson Orin Nano 记录命令 linux ip: uname: junhui sudo apt-get update sudo apt-get install python3-pip sudo pip3 install -U jetson-stats sudo jtop sudo poweroff systemctl status bluetooth systemctl start bluetooth iwconfig # 看网速等网络状态 install Jetpack # 找不到 nvcc 编译器 sudo apt install nvidia-jetpack # 8GB 内容 find / -name \"nvcc\" 2\u003e/dev/null export CUDA_HOME=/usr/local/cuda-12.6 export PATH=$PATH:$CUDA_HOME/bin export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$CUDA_HOME/lib64 # 找到 sample code find / -name \"vectorAdd.cu\" 2\u003e/dev/null bash /usr/local/cuda-11.4/bin/cuda-install-samples-11.4.sh ./ #拷贝 samples 到指定路径 # 验证：(默认找不到头文件，只能指明-I) nvcc $CUDA_HOME/samples/0_Simple/vectorAdd/vectorAdd.cu -I/usr/local/cuda-11.4/samples/common/inc/ -o vectorAdd nvcc vectorAdd.cu -I/home/junhui/workspace/NVIDIA_CUDA-11.4_Samples/common/inc/ -o vectorAdd nvcc deviceQuery.cpp -I/home/junhui/workspace/NVIDIA_CUDA-11.4_Samples/common/inc -o deviceQuery # 检查 dpkg -l | grep nvidia #这个命令会列出所有安装的与 \"nvidia\" 相关的软件包。 dpkg -l | grep nvidia 获取一个大致的组件列表，然后使用 apt-cache show 命令查看特定组件的详细信息 主机连接 Orin 最佳实践 假如没有外接显示器和鼠标键盘。\n1. ssh 链接 Orin 当使用 USB-C 连接主机和 Orin 后，可以通过 Type-C 产生的虚拟网口连接，IP地址是固定的：192.168.55.1。通过这个地址 ssh 连接 Orin。\n2. 配置 Orin wifi 1. 连接 wifi sudo nmcli device wifi connect '' password '' 有时候网络会出毛病，不是命令的问题。\n2. 使用 NetworkManager: sudo apt update sudo apt install network-manager sudo service NetworkManager start 3. 将Orin 接入显示器。通过图形界面来连接，常规方式。不方便，需要接入显示器和鼠标键盘。 这时也可以通过上述得到的 wlan0 的 inet ssh连接 Orin。\n# linux链接指定wifi sudo nmcli device wifi connect '' password '' #扫描可用wifi网络 nmcli dev wifi list # 列出所有已保存的网络连接 nmcli con show # 删除连接 nmcli con delete uuid # 激活连接 nmcli con up ziroom801_5G Proxy 问题 windows上链接了代理，如何让 Jetson 连接代理？\n在 Windows Clash 中开启“允许局域网链接” \u0026 “TUN模式” 找到 windows IP 在 Jetson 中 输入 export https_proxy=http://:7890 通过 wget 验证 对于 Docker，需要配置 Docker 的 http_proxy. 祥见下 KAQ问题：为什么 wget 可以通过设置的代理，但是 ping 不能？ 答：因为两者的使用的协议不同。wget使用 http 或 https协议。而 ping 使用 ICMP 协议。\nJetson Orin SUPER mode 如何在设备上切换 Power Mode：\nsudo nvpmodel -q # 产看当前mode sudo nvpmodel -m 通过 nvpmodel 设置的电源模式在重启后仍然有效 。除非再次调用 nvpmodel，否则模式不会改变。\nNV Power Mode: 10W 对应 mode=0 NV Power Mode: 25W 对应 mode=1 NV Power Mode: MAXN_SUPER 对应 mode=2 安装 Nsight Compute 通过重新烧录 Jetpack，ncu 成功安装。\nNsight System：已安装，使用 nsys profile -o vectorAdd ./vectorAdd 生成文件 vectorAdd2.nsys-rep 然后可以通过 nsys-ui vectorAdd.nsys-rep 图形化分析结果。\nnsys-ui 开启UI，找到可执行文件，Start 开始分析，结束后会生成一个 .nsys-rep 文件。此方法显示Qt版本问题。不成功。\n更新 jetpack 需要安装 SDK manager 到 ubuntu 20.04 (vmware中的虚拟机), 然后烧录到 Jetson Orin 中。\n安装 jetson-containers https://github.com/dusty-nv/jetson-containers\nDocker 网络问题： 1. 通过 配置 Docker 代理： sudo mkdir -p /etc/systemd/system/docker.service.d sudo vim /etc/systemd/system/docker.service.d/http-proxy.conf # http-proxy.conf 中添加以下内容： [Service] Environment=\"HTTP_PROXY=http://:7890\" Environment=\"HTTPS_PROXY=http://:7890\" Environment=\"NO_PROXY=localhost,127.0.0.1\" 2. 然后需要在 Windows 的 Clash 中开启 “允许局域网连接” 。 3. 重启 daemon 和 docker： sudo systemctl daemon-reload , sudo systemctl restart docker 3. 开启 “TUN模式”，最后开启它，否则代理不起作用。*** 如此 Docker pull 可以正确下载（只是不是 100% 稳定，已经很好了，证明了这条路是通的对的）\n关于 Docker 其他要知道的 配置文件添加国内镜像\n额外的：我在 config.yaml 中添加了 bind-address: 0.0.0.0 监听所有IP地址: 设置为 0.0.0.0 意味着 Clash 将监听来自所有网络接口的连接请求。这包括本地回环地址（127.0.0.1）以及任何其他网络接口（如局域网接口、Wi-Fi等）。这使得局域网内的其他设备也能够通过 Clash 的代理服务访问互联网。\n配合 allow-lan 使用: 只有当 allow-lan: true 时，bind-address 的设置才会生效。这意味着，如果你希望其他局域网设备能够通过 Clash 进行代理访问，你必须同时启用这两个设置。\napt 也不走环境代理 apt update 不会使用环境代理，创建 apt 的配置文件并添加内容如下\nsudo vim /etc/apt/apt.conf.d/proxy.conf Acquire::http::Proxy \"http://:7890/\"; Acquire::https::Proxy \"http://:7890/\"; 或者：\nsudo apt update -o Acquire::http::Proxy=\"http://:7890/\" -o Acquire::https::Proxy=\"http://:7890/\" 每个程序可能要配置自己的代理，环境变量的作用范围是不同的，代理协议的支持 不同程序间是不同的，所以当发现某个程序没有使用eport的代理，那就需要单独配置了。或者使用全局代理工具。\n快速查看 ip 当 windows 通过 ssh 连接到 linux 时，Windows 是客户端，Linux 是服务器。此时，在 Linux 上查看 env SSH_CONNECTION：\nSSH_CONNECTION= 14019 22 给你重要的 4 信息：\n客户端 IP 地址 (Client IP Address): 发起 SSH 连接的客户端机器的 IP 地址。 即你的 Windows 机器的 IP 地址。 客户端端口号 (Client Port Number): 客户端机器用于发起 SSH 连接的端口号。 这是一个临时的、随机分配的端口。 服务器 IP 地址 (Server IP Address): 接收 SSH 连接的 Linux 服务器的 IP 地址。 服务器端口号 (Server Port Number): Linux 服务器上 SSH daemon 监听的端口号。 默认情况下，SSH 监听端口是 22。 总结 Jetson 连接 windows 代理 Windows 局域网IP， Jetson 同局域网联网 Jetson: export http_proxy=\"http://:7890\" Clash 开启允许局域网连接 配置 docker 文件：sudo vim /etc/systemd/system/docker.service.d/http-proxy.conf，添加上述 http_proxy。 重启 Daemon \u0026 docker Clash 开启 TUN模式 要想灵活运用，需要知道上述设计的原理。 这样换另一个代理软件，也能正确使用。\n远程链接 jetson 我有一个Linux设备作为服务器，同时有一个Windows设备作为客户端。在家里的相同 wifi 下我成功通过 SSH 从我的 Windows机器连接到Linux服务器。现在我需要把Linux服务器留在家里，在咖啡馆用windows 机器远程连接到家里的Linux服务器，我应该如何做？给出具体步骤。\n安装开关 开发板背面有一个12针接口，其中的第1针为PWR BTN，第7、8针DIS AUTO ON，这两个针脚可以通过短接和接开关来实现软开关功能，达到不需要每次拔插电源就能开关机的目的。\nPWR BTN（电源按钮）和GND短接： 连接一个开关按钮，当按下时短接这两个针脚，可以用来控制开机或关机信号。 DIS AUTO ON两针脚： 这两个针脚短接后可以禁止自动上电启动，使开发板插上电源不自动启动，配合PWR BTN来实现手动开关机。 具体连线方式是将PWR BTN接开关一侧，开关的另一侧接GND，同时将DIS AUTO ON短接(就是两个针脚连接在一起。)，或者某种组合可以达到手动控制上电开关的目的。 两个针脚短路，在电子电路中是指这两个针脚之间用导线、金属或开关闭合，使两点之间的电阻接近于零，也就是这两个针脚直接连通了，没有电阻阻挡电流流过。换句话说，就是这两个针脚被“短接”了。短路使得电压在两个针脚之间降为接近0V，从而达到控制信号的目的。\nPin针脚的作用是设备内部的电气控制逻辑决定的，默认是这两个针脚不连通时触发“自动开机”信号。\n选择复位式开关，即 Normal On，按下时开关闭合，松开时断开。Jetson 设备不会要求开关持续按压，只需检测到“按下信号”即可启动。按下按钮时短接 PWR BTN 和 GND，设备感知到这一信号触发开机动作，松开后断开，设备继续启动运行。\n",
  "wordCount" : "625",
  "inLanguage": "en",
  "datePublished": "2025-08-31T12:47:02+08:00",
  "dateModified": "2025-08-31T12:47:02+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ashburnLee.github.io/blog-2-hugo/jetson/jetson-setup/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Junhui's Journal 2",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ashburnLee.github.io/blog-2-hugo/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ashburnLee.github.io/blog-2-hugo/" accesskey="h" title="Junhui&#39;s Journal 2 (Alt + H)">Junhui&#39;s Journal 2</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Jetson Setup
    </h1>
    <div class="post-meta"><span title='2025-08-31 12:47:02 +0800 CST'>August 31, 2025</span>

</div>
  </header> 
  <div class="post-content"><p>NVIDIA Orin 是一款专为<strong>自动驾驶汽车</strong>和<strong>机器人</strong>设计的高性能系统级芯片，包含新一代 Ampere GPU 架构和 Arm Hercules CPU 内核，以及深度学习加速器和计算机视觉加速器。</p>
<p>应用领域：Orin 芯片不仅适用于自动驾驶汽车，还广泛应用于机器人、工业边缘计算等领域。</p>
<p>支持C/C++, python, cuda, pytorch, ROS (Robot Operating System), JetPack SDK, DeepStream, VScode</p>
<p>TensorRT 是 NVIDIA 开发的一个高性能深度学习推理 SDK。它不是完全开源的.</p>
<p><code>Linux for Tegra (L4T) </code>是 NVIDIA 为其 Tegra 系列系统芯片 (SoC) 开发的嵌入式 Linux 发行版。它主要用于 NVIDIA Jetson 系列开发套件等嵌入式系统。L4T 提供了运行在 Tegra SoC 上的内核、驱动程序、库和工具，支持各种应用，包括机器人、人工智能、自动驾驶和媒体处理等。 它包含了 NVIDIA 专有的驱动程序，以充分利用 Tegra SoC 的硬件加速功能。不同的 L4T 版本支持不同的 Tegra 系列芯片和功能。 例如，较新的版本可能支持 Vulkan 和更新的 CUDA 版本。 开发者可以使用 L4T 来构建和部署各种嵌入式应用。</p>
<h1 id="配置jetson-orin-nano">配置Jetson Orin Nano<a hidden class="anchor" aria-hidden="true" href="#配置jetson-orin-nano">#</a></h1>
<h2 id="记录命令">记录命令<a hidden class="anchor" aria-hidden="true" href="#记录命令">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>linux ip: &lt;linux-ip&gt;
</span></span><span style="display:flex;"><span>uname: junhui
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo apt-get update
</span></span><span style="display:flex;"><span>sudo apt-get install python3-pip
</span></span><span style="display:flex;"><span>sudo pip3 install -U jetson-stats
</span></span><span style="display:flex;"><span>sudo jtop
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo poweroff
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>systemctl status bluetooth
</span></span><span style="display:flex;"><span>systemctl start bluetooth
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>iwconfig  <span style="color:#75715e"># 看网速等网络状态</span>
</span></span></code></pre></div><h2 id="install-jetpack">install Jetpack<a hidden class="anchor" aria-hidden="true" href="#install-jetpack">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># 找不到 nvcc 编译器</span>
</span></span><span style="display:flex;"><span>sudo apt install nvidia-jetpack  <span style="color:#75715e"># 8GB 内容</span>
</span></span><span style="display:flex;"><span>find / -name <span style="color:#e6db74">&#34;nvcc&#34;</span> 2&gt;/dev/null
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>export CUDA_HOME<span style="color:#f92672">=</span>/usr/local/cuda-12.6
</span></span><span style="display:flex;"><span>export PATH<span style="color:#f92672">=</span>$PATH:$CUDA_HOME/bin
</span></span><span style="display:flex;"><span>export LD_LIBRARY_PATH<span style="color:#f92672">=</span>$LD_LIBRARY_PATH:$CUDA_HOME/lib64
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 找到 sample code</span>
</span></span><span style="display:flex;"><span>find / -name <span style="color:#e6db74">&#34;vectorAdd.cu&#34;</span> 2&gt;/dev/null 
</span></span><span style="display:flex;"><span>bash /usr/local/cuda-11.4/bin/cuda-install-samples-11.4.sh ./  <span style="color:#75715e">#拷贝 samples 到指定路径</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 验证：(默认找不到头文件，只能指明-I)</span>
</span></span><span style="display:flex;"><span>nvcc $CUDA_HOME/samples/0_Simple/vectorAdd/vectorAdd.cu -I/usr/local/cuda-11.4/samples/common/inc/ -o vectorAdd
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>nvcc vectorAdd.cu -I/home/junhui/workspace/NVIDIA_CUDA-11.4_Samples/common/inc/ -o vectorAdd
</span></span><span style="display:flex;"><span>nvcc deviceQuery.cpp -I/home/junhui/workspace/NVIDIA_CUDA-11.4_Samples/common/inc -o deviceQuery
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 检查</span>
</span></span><span style="display:flex;"><span>dpkg -l | grep nvidia  <span style="color:#75715e">#这个命令会列出所有安装的与 &#34;nvidia&#34; 相关的软件包。</span>
</span></span><span style="display:flex;"><span>dpkg -l | grep nvidia 获取一个大致的组件列表，然后使用 apt-cache show 命令查看特定组件的详细信息
</span></span></code></pre></div><h1 id="主机连接-orin-最佳实践">主机连接 Orin 最佳实践<a hidden class="anchor" aria-hidden="true" href="#主机连接-orin-最佳实践">#</a></h1>
<p>假如没有外接显示器和鼠标键盘。</p>
<h2 id="1-ssh-链接-orin">1. ssh 链接 Orin<a hidden class="anchor" aria-hidden="true" href="#1-ssh-链接-orin">#</a></h2>
<p>当使用 USB-C 连接主机和 Orin 后，可以通过 Type-C 产生的虚拟网口连接，IP地址是固定的：<code>192.168.55.1</code>。通过这个地址 ssh 连接 Orin。</p>
<h2 id="2-配置-orin-wifi">2. 配置 Orin wifi<a hidden class="anchor" aria-hidden="true" href="#2-配置-orin-wifi">#</a></h2>
<h3 id="1-连接-wifi">1. 连接 wifi<a hidden class="anchor" aria-hidden="true" href="#1-连接-wifi">#</a></h3>
<p><code>sudo nmcli device wifi connect '&lt;wifi-name&gt;' password '&lt;password&gt;'</code> 有时候网络会出毛病，不是命令的问题。</p>
<h3 id="2-使用-networkmanager">2. 使用 NetworkManager:<a hidden class="anchor" aria-hidden="true" href="#2-使用-networkmanager">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo apt update
</span></span><span style="display:flex;"><span>sudo apt install network-manager
</span></span><span style="display:flex;"><span>sudo service NetworkManager start
</span></span></code></pre></div><h3 id="3-将orin-接入显示器通过图形界面来连接常规方式不方便需要接入显示器和鼠标键盘">3. <del>将Orin 接入显示器。通过图形界面来连接，常规方式。不方便，需要接入显示器和鼠标键盘。</del><a hidden class="anchor" aria-hidden="true" href="#3-将orin-接入显示器通过图形界面来连接常规方式不方便需要接入显示器和鼠标键盘">#</a></h3>
<p>这时也可以通过上述得到的 wlan0 的 inet ssh连接 Orin。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># linux链接指定wifi</span>
</span></span><span style="display:flex;"><span>sudo nmcli device wifi connect <span style="color:#e6db74">&#39;&lt;wifi-name&gt;&#39;</span> password <span style="color:#e6db74">&#39;&lt;password&gt;&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#扫描可用wifi网络</span>
</span></span><span style="display:flex;"><span>nmcli dev wifi list  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 列出所有已保存的网络连接</span>
</span></span><span style="display:flex;"><span>nmcli con show
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 删除连接</span>
</span></span><span style="display:flex;"><span>nmcli con delete uuid &lt;UUID&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 激活连接</span>
</span></span><span style="display:flex;"><span>nmcli con up ziroom801_5G  
</span></span></code></pre></div><h2 id="proxy-问题">Proxy 问题<a hidden class="anchor" aria-hidden="true" href="#proxy-问题">#</a></h2>
<p>windows上链接了代理，如何让 Jetson 连接代理？</p>
<ol>
<li>在 Windows Clash 中开启“允许局域网链接” &amp; “TUN模式”</li>
<li>找到 windows IP</li>
<li>在 Jetson 中 输入 <code>export https_proxy=http://&lt;windows_ip&gt;:7890</code></li>
<li>通过 <code>wget</code> 验证</li>
<li>对于 Docker，需要配置 Docker 的 http_proxy. 祥见下</li>
</ol>
<p>KAQ问题：为什么 wget 可以通过设置的代理，但是 ping 不能？
答：因为两者的使用的协议不同。wget使用 http 或 https协议。而 ping 使用 ICMP 协议。</p>
<h2 id="jetson-orin-super-mode">Jetson Orin SUPER mode<a hidden class="anchor" aria-hidden="true" href="#jetson-orin-super-mode">#</a></h2>
<p>如何在设备上切换 Power Mode：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo nvpmodel -q  <span style="color:#75715e"># 产看当前mode</span>
</span></span><span style="display:flex;"><span>sudo nvpmodel -m &lt;mode_id&gt;
</span></span></code></pre></div><p>通过 nvpmodel 设置的电源模式在重启后仍然有效 。除非再次调用 nvpmodel，否则模式不会改变。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>NV Power Mode: 10W 对应 mode<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>NV Power Mode: 25W 对应 mode<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>NV Power Mode: MAXN_SUPER 对应 mode<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>
</span></span></code></pre></div><h2 id="安装-nsight-compute">安装 Nsight Compute<a hidden class="anchor" aria-hidden="true" href="#安装-nsight-compute">#</a></h2>
<p>通过重新烧录 Jetpack，ncu 成功安装。</p>
<h2 id="nsight-system已安装使用">Nsight System：已安装，使用<a hidden class="anchor" aria-hidden="true" href="#nsight-system已安装使用">#</a></h2>
<ol>
<li>
<p><code>nsys profile -o vectorAdd ./vectorAdd</code> 生成文件 <code>vectorAdd2.nsys-rep</code> 然后可以通过 <code>nsys-ui vectorAdd.nsys-rep</code> 图形化分析结果。</p>
</li>
<li>
<p><code>nsys-ui</code> 开启UI，找到可执行文件，Start 开始分析，结束后会生成一个 <code>.nsys-rep</code> 文件。此方法显示Qt版本问题。不成功。</p>
</li>
</ol>
<h2 id="更新-jetpack">更新 jetpack<a hidden class="anchor" aria-hidden="true" href="#更新-jetpack">#</a></h2>
<p>需要安装 SDK manager 到 ubuntu 20.04 (vmware中的虚拟机), 然后烧录到 Jetson Orin 中。</p>
<h2 id="安装-jetson-containers">安装 jetson-containers<a hidden class="anchor" aria-hidden="true" href="#安装-jetson-containers">#</a></h2>
<p><a href="https://github.com/dusty-nv/jetson-containers">https://github.com/dusty-nv/jetson-containers</a></p>
<h2 id="docker-网络问题">Docker 网络问题：<a hidden class="anchor" aria-hidden="true" href="#docker-网络问题">#</a></h2>
<h3 id="1-通过-配置-docker-代理">1. 通过 配置 Docker 代理：<a hidden class="anchor" aria-hidden="true" href="#1-通过-配置-docker-代理">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo mkdir -p /etc/systemd/system/docker.service.d
</span></span><span style="display:flex;"><span>sudo vim /etc/systemd/system/docker.service.d/http-proxy.conf
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># http-proxy.conf 中添加以下内容：</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>Service<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>Environment<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;HTTP_PROXY=http://&lt;windows-ip&gt;:7890&#34;</span>
</span></span><span style="display:flex;"><span>Environment<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;HTTPS_PROXY=http://&lt;windows-ip&gt;:7890&#34;</span>
</span></span><span style="display:flex;"><span>Environment<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;NO_PROXY=localhost,127.0.0.1&#34;</span>
</span></span></code></pre></div><h3 id="2-然后需要在-windows-的-clash-中开启-允许局域网连接-">2. 然后需要在 Windows 的 Clash 中开启 “允许局域网连接” 。<a hidden class="anchor" aria-hidden="true" href="#2-然后需要在-windows-的-clash-中开启-允许局域网连接-">#</a></h3>
<h3 id="3-重启-daemon-和-docker-sudo-systemctl-daemon-reload--sudo-systemctl-restart-docker">3. 重启 daemon 和 docker： <code>sudo systemctl daemon-reload</code> , <code>sudo systemctl restart docker</code><a hidden class="anchor" aria-hidden="true" href="#3-重启-daemon-和-docker-sudo-systemctl-daemon-reload--sudo-systemctl-restart-docker">#</a></h3>
<h3 id="3-开启-tun模式最后开启它否则代理不起作用">3. 开启 “TUN模式”，最后开启它，否则代理不起作用。***<a hidden class="anchor" aria-hidden="true" href="#3-开启-tun模式最后开启它否则代理不起作用">#</a></h3>
<p>如此 <code>Docker pull</code> 可以正确下载（只是不是 100% 稳定，已经很好了，证明了这条路是通的对的）</p>
<h2 id="关于-docker-其他要知道的">关于 Docker 其他要知道的<a hidden class="anchor" aria-hidden="true" href="#关于-docker-其他要知道的">#</a></h2>
<p>配置文件添加国内镜像</p>
<h2 id="额外的我在-configyaml-中添加了-bind-address-0000">额外的：我在 config.yaml 中添加了 <code>bind-address: 0.0.0.0</code><a hidden class="anchor" aria-hidden="true" href="#额外的我在-configyaml-中添加了-bind-address-0000">#</a></h2>
<p>监听所有IP地址: 设置为 0.0.0.0 意味着 Clash 将监听来自所有网络接口的连接请求。这包括本地回环地址（127.0.0.1）以及任何其他网络接口（如局域网接口、Wi-Fi等）。这使得局域网内的其他设备也能够通过 Clash 的代理服务访问互联网。</p>
<p>配合 allow-lan 使用: 只有当 allow-lan: true 时，bind-address 的设置才会生效。这意味着，如果你希望其他局域网设备能够通过 Clash 进行代理访问，你必须同时启用这两个设置。</p>
<h2 id="apt-也不走环境代理">apt 也不走环境代理<a hidden class="anchor" aria-hidden="true" href="#apt-也不走环境代理">#</a></h2>
<p><strong><code>apt update</code> 不会使用环境代理</strong>，创建 apt 的配置文件并添加内容如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo vim /etc/apt/apt.conf.d/proxy.conf
</span></span><span style="display:flex;"><span>Acquire::http::Proxy <span style="color:#e6db74">&#34;http://&lt;windows-ip&gt;:7890/&#34;</span>;
</span></span><span style="display:flex;"><span>Acquire::https::Proxy <span style="color:#e6db74">&#34;http://&lt;windows-ip&gt;:7890/&#34;</span>;
</span></span></code></pre></div><p>或者：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo apt update -o Acquire::http::Proxy<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;http://&lt;windows-ip&gt;:7890/&#34;</span> -o Acquire::https::Proxy<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;http://&lt;windows-ip&gt;:7890/&#34;</span>
</span></span></code></pre></div><p><strong>每个程序可能要配置自己的代理</strong>，环境变量的作用范围是不同的，代理协议的支持 不同程序间是不同的，所以当发现某个程序没有使用eport的代理，那就需要单独配置了。或者使用全局代理工具。</p>
<h2 id="快速查看-ip">快速查看 ip<a hidden class="anchor" aria-hidden="true" href="#快速查看-ip">#</a></h2>
<p>当 windows 通过 ssh 连接到 linux 时，Windows 是客户端，Linux 是服务器。此时，在 Linux 上查看 env <code>SSH_CONNECTION</code>：</p>
<p><code>SSH_CONNECTION=&lt;windows-ip&gt; 14019 &lt;linux-ip&gt; 22</code> 给你重要的 4 信息：</p>
<ul>
<li>客户端 IP 地址 (Client IP Address): 发起 SSH 连接的客户端机器的 IP 地址。 即你的 Windows 机器的 IP 地址。</li>
<li>客户端端口号 (Client Port Number): 客户端机器用于发起 SSH 连接的端口号。 这是一个临时的、随机分配的端口。</li>
<li>服务器 IP 地址 (Server IP Address): 接收 SSH 连接的 Linux 服务器的 IP 地址。</li>
<li>服务器端口号 (Server Port Number): Linux 服务器上 SSH daemon 监听的端口号。 默认情况下，SSH 监听端口是 22。</li>
</ul>
<h1 id="总结-jetson-连接-windows-代理">总结 Jetson 连接 windows 代理<a hidden class="anchor" aria-hidden="true" href="#总结-jetson-连接-windows-代理">#</a></h1>
<ol>
<li>Windows 局域网IP，<code>&lt;windows-ip&gt;</code></li>
<li>Jetson 同局域网联网</li>
<li>Jetson: <code>export http_proxy=&quot;http://&lt;windows-ip&gt;:7890&quot;</code></li>
<li>Clash 开启允许局域网连接</li>
<li>配置 docker 文件：<code>sudo vim /etc/systemd/system/docker.service.d/http-proxy.conf</code>，添加上述 http_proxy。</li>
<li>重启 Daemon &amp; docker</li>
<li>Clash 开启 TUN模式</li>
</ol>
<p>要想灵活运用，需要知道上述设计的原理。 这样换另一个代理软件，也能正确使用。</p>
<h2 id="远程链接-jetson">远程链接 jetson<a hidden class="anchor" aria-hidden="true" href="#远程链接-jetson">#</a></h2>
<p>我有一个Linux设备作为服务器，同时有一个Windows设备作为客户端。在家里的相同 wifi 下我成功通过 SSH 从我的 Windows机器连接到Linux服务器。现在我需要把Linux服务器留在家里，在咖啡馆用windows 机器远程连接到家里的Linux服务器，我应该如何做？给出具体步骤。</p>
<h2 id="安装开关">安装开关<a hidden class="anchor" aria-hidden="true" href="#安装开关">#</a></h2>
<p>开发板背面有一个<strong>12针接口</strong>，其中的第1针为<code>PWR BTN</code>，第7、8针<code>DIS AUTO ON</code>，这两个针脚可以通过短接和接开关来实现软开关功能，达到不需要每次拔插电源就能开关机的目的。</p>
<ul>
<li><code>PWR BTN</code>（电源按钮）和<code>GND</code>短接： 连接一个开关按钮，当按下时短接这两个针脚，可以用来控制开机或关机信号。</li>
<li><code>DIS AUTO ON</code>两针脚： 这两个针脚短接后可以禁止自动上电启动，使开发板插上电源不自动启动，配合<code>PWR BTN</code>来实现手动开关机。</li>
<li>具体连线方式是将<code>PWR BTN</code>接开关一侧，开关的另一侧接<code>GND</code>，同时将<code>DIS AUTO ON</code>短接(就是两个针脚连接在一起。)，或者某种组合可以达到手动控制上电开关的目的。</li>
</ul>
<p>两个针脚<strong>短路</strong>，在电子电路中是指这两个针脚之间用导线、金属或开关闭合，使两点之间的电阻接近于零，也就是这两个针脚直接连通了，没有电阻阻挡电流流过。换句话说，就是这两个针脚被“短接”了。短路使得电压在两个针脚之间降为接近0V，从而达到控制信号的目的。</p>
<p>Pin针脚的作用是<strong>设备内部的电气控制逻辑决定的</strong>，默认是这两个针脚不连通时触发“自动开机”信号。</p>
<p>选择复位式开关，即 Normal On，按下时开关闭合，松开时断开。Jetson 设备不会要求开关持续按压，只需检测到“按下信号”即可启动。按下按钮时短接 PWR BTN 和 GND，设备感知到这一信号触发开机动作，松开后断开，设备继续启动运行。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ashburnLee.github.io/blog-2-hugo/tags/jetson/">Jetson</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://ashburnLee.github.io/blog-2-hugo/">Junhui&#39;s Journal 2</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
