<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Git | Junhui&#39;s Journal 2</title>
<meta name="keywords" content="git">
<meta name="description" content="Push 和提 PR 是两个概念。一个PR其实是一个分支的概念，push 就 PR 该后，需要在 github 页面中手动提 PR（当然也可以通过gh命令）。这里要表达的是push和提PR是两回事。
要想在 github 页面显示自己的分支，必须要 push。不想让别人看见自己的分支就不要提 PR。
Git
常用命令
git log --oneline
git rm -r --cached build  # 将git上的build文件夹删除，同时保留本地。然后commit push后，远端的build也就被删除了。这里有个cache的概念。 

git reflog
git reset --hard 1359d449
git show-ref --verify --quiet
git rebase
git rev-parse HEAD
git submodule sync &amp;&amp; git submodule update --init --recursive

git diff &gt; my.diff
git apply my.diff  # 在新的 branch

git clone --single-branch

git log --author=&#34;Author Name&#34;
git log --grep=&#34;message&#34;
git revert
git config --list

git commit --amend -m &#34;new commit message&#34;
git push origin junhui_typo --force

git reset --soft HEAD^  # 撤销上一个commit
git reset --hard HEAD^  # 撤销所有commit
git reset --hard        # 撤销上一个操作（当上一个操作结果不如预期时）
如果我有两个commit，先有commit a 后有commit b，如何在commit a中修改代码
# To modify code in commit a, you can use the `git rebase` command.
# Here&#39;s an example:

# 1. Start an interactive rebase session
git rebase -i HEAD~2

# 2. In the interactive rebase editor, change &#34;pick&#34; to &#34;edit&#34; for commit a
#    and save the file

# 3. Git will stop at commit a. Now you can modify the code as needed
# 在commit a中添加你的修改

# 4. Stage the changes
git add .

# 5. Amend the commit
git commit --amend  # 似乎不能是 --no-edit, 佛则这个commit就会消失

# 6. Continue the rebase
git rebase --continue

# The code in commit a is now modified.
3个commit，压缩为一个commit
git log
# step1
git rebase -i lastCommitID  //lastCommitID 倒数第四次提交
# OR
git rebase -i HEAD~3

# step2 vim 编辑
# 要把*下面*两个红色框 ‘pick’ 改为‘s’,表示第三次提交合并入第二次，第二次提交合并入第一次。
# 保存退出
git push -f BRANCHNAME
Cherry-pick
    a - b - c - d     Master
         \
           e - f - g  Feature

git checkout master
# Cherry pick 操作, 【仅仅pick这一个commit】
git cherry-pick f

#结果
    a - b - c - d - f   Master
         \
           e - f - g    Feature
# 若有冲突，解决后
git cherry-pick --continue
优势：cherry-pick 比笨方法好，笨方法会将重命名后的文件都保留">
<meta name="author" content="">
<link rel="canonical" href="https://ashburnLee.github.io/blog-2-hugo/git/">
<link crossorigin="anonymous" href="/blog-2-hugo/assets/css/stylesheet.bdaf5941cb3c05e36e857d9e2953ba0c4485ba7bc2da15db169d66a77cbc7a87.css" integrity="sha256-va9ZQcs8BeNuhX2eKVO6DESFunvC2hXbFp1mp3y8eoc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ashburnLee.github.io/blog-2-hugo/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ashburnLee.github.io/blog-2-hugo/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ashburnLee.github.io/blog-2-hugo/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ashburnLee.github.io/blog-2-hugo/apple-touch-icon.png">
<link rel="mask-icon" href="https://ashburnLee.github.io/blog-2-hugo/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://ashburnLee.github.io/blog-2-hugo/git/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" id="MathJax-script" async></script>


<meta property="og:url" content="https://ashburnLee.github.io/blog-2-hugo/git/">
  <meta property="og:site_name" content="Junhui&#39;s Journal 2">
  <meta property="og:title" content="Git">
  <meta property="og:description" content="Push 和提 PR 是两个概念。一个PR其实是一个分支的概念，push 就 PR 该后，需要在 github 页面中手动提 PR（当然也可以通过gh命令）。这里要表达的是push和提PR是两回事。
要想在 github 页面显示自己的分支，必须要 push。不想让别人看见自己的分支就不要提 PR。
Git 常用命令 git log --oneline git rm -r --cached build # 将git上的build文件夹删除，同时保留本地。然后commit push后，远端的build也就被删除了。这里有个cache的概念。 git reflog git reset --hard 1359d449 git show-ref --verify --quiet git rebase git rev-parse HEAD git submodule sync &amp;&amp; git submodule update --init --recursive git diff &gt; my.diff git apply my.diff # 在新的 branch git clone --single-branch git log --author=&#34;Author Name&#34; git log --grep=&#34;message&#34; git revert git config --list git commit --amend -m &#34;new commit message&#34; git push origin junhui_typo --force git reset --soft HEAD^ # 撤销上一个commit git reset --hard HEAD^ # 撤销所有commit git reset --hard # 撤销上一个操作（当上一个操作结果不如预期时） 如果我有两个commit，先有commit a 后有commit b，如何在commit a中修改代码 # To modify code in commit a, you can use the `git rebase` command. # Here&#39;s an example: # 1. Start an interactive rebase session git rebase -i HEAD~2 # 2. In the interactive rebase editor, change &#34;pick&#34; to &#34;edit&#34; for commit a # and save the file # 3. Git will stop at commit a. Now you can modify the code as needed # 在commit a中添加你的修改 # 4. Stage the changes git add . # 5. Amend the commit git commit --amend # 似乎不能是 --no-edit, 佛则这个commit就会消失 # 6. Continue the rebase git rebase --continue # The code in commit a is now modified. 3个commit，压缩为一个commit git log # step1 git rebase -i lastCommitID //lastCommitID 倒数第四次提交 # OR git rebase -i HEAD~3 # step2 vim 编辑 # 要把*下面*两个红色框 ‘pick’ 改为‘s’,表示第三次提交合并入第二次，第二次提交合并入第一次。 # 保存退出 git push -f BRANCHNAME Cherry-pick a - b - c - d Master \ e - f - g Feature git checkout master # Cherry pick 操作, 【仅仅pick这一个commit】 git cherry-pick f #结果 a - b - c - d - f Master \ e - f - g Feature # 若有冲突，解决后 git cherry-pick --continue 优势：cherry-pick 比笨方法好，笨方法会将重命名后的文件都保留">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:published_time" content="2025-08-31T12:57:44+08:00">
    <meta property="article:modified_time" content="2025-08-31T12:57:44+08:00">
    <meta property="article:tag" content="Git">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Git">
<meta name="twitter:description" content="Push 和提 PR 是两个概念。一个PR其实是一个分支的概念，push 就 PR 该后，需要在 github 页面中手动提 PR（当然也可以通过gh命令）。这里要表达的是push和提PR是两回事。
要想在 github 页面显示自己的分支，必须要 push。不想让别人看见自己的分支就不要提 PR。
Git
常用命令
git log --oneline
git rm -r --cached build  # 将git上的build文件夹删除，同时保留本地。然后commit push后，远端的build也就被删除了。这里有个cache的概念。 

git reflog
git reset --hard 1359d449
git show-ref --verify --quiet
git rebase
git rev-parse HEAD
git submodule sync &amp;&amp; git submodule update --init --recursive

git diff &gt; my.diff
git apply my.diff  # 在新的 branch

git clone --single-branch

git log --author=&#34;Author Name&#34;
git log --grep=&#34;message&#34;
git revert
git config --list

git commit --amend -m &#34;new commit message&#34;
git push origin junhui_typo --force

git reset --soft HEAD^  # 撤销上一个commit
git reset --hard HEAD^  # 撤销所有commit
git reset --hard        # 撤销上一个操作（当上一个操作结果不如预期时）
如果我有两个commit，先有commit a 后有commit b，如何在commit a中修改代码
# To modify code in commit a, you can use the `git rebase` command.
# Here&#39;s an example:

# 1. Start an interactive rebase session
git rebase -i HEAD~2

# 2. In the interactive rebase editor, change &#34;pick&#34; to &#34;edit&#34; for commit a
#    and save the file

# 3. Git will stop at commit a. Now you can modify the code as needed
# 在commit a中添加你的修改

# 4. Stage the changes
git add .

# 5. Amend the commit
git commit --amend  # 似乎不能是 --no-edit, 佛则这个commit就会消失

# 6. Continue the rebase
git rebase --continue

# The code in commit a is now modified.
3个commit，压缩为一个commit
git log
# step1
git rebase -i lastCommitID  //lastCommitID 倒数第四次提交
# OR
git rebase -i HEAD~3

# step2 vim 编辑
# 要把*下面*两个红色框 ‘pick’ 改为‘s’,表示第三次提交合并入第二次，第二次提交合并入第一次。
# 保存退出
git push -f BRANCHNAME
Cherry-pick
    a - b - c - d     Master
         \
           e - f - g  Feature

git checkout master
# Cherry pick 操作, 【仅仅pick这一个commit】
git cherry-pick f

#结果
    a - b - c - d - f   Master
         \
           e - f - g    Feature
# 若有冲突，解决后
git cherry-pick --continue
优势：cherry-pick 比笨方法好，笨方法会将重命名后的文件都保留">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Git",
      "item": "https://ashburnLee.github.io/blog-2-hugo/git/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Git",
  "name": "Git",
  "description": "Push 和提 PR 是两个概念。一个PR其实是一个分支的概念，push 就 PR 该后，需要在 github 页面中手动提 PR（当然也可以通过gh命令）。这里要表达的是push和提PR是两回事。\n要想在 github 页面显示自己的分支，必须要 push。不想让别人看见自己的分支就不要提 PR。\nGit 常用命令 git log --oneline git rm -r --cached build # 将git上的build文件夹删除，同时保留本地。然后commit push后，远端的build也就被删除了。这里有个cache的概念。 git reflog git reset --hard 1359d449 git show-ref --verify --quiet git rebase git rev-parse HEAD git submodule sync \u0026amp;\u0026amp; git submodule update --init --recursive git diff \u0026gt; my.diff git apply my.diff # 在新的 branch git clone --single-branch git log --author=\u0026#34;Author Name\u0026#34; git log --grep=\u0026#34;message\u0026#34; git revert git config --list git commit --amend -m \u0026#34;new commit message\u0026#34; git push origin junhui_typo --force git reset --soft HEAD^ # 撤销上一个commit git reset --hard HEAD^ # 撤销所有commit git reset --hard # 撤销上一个操作（当上一个操作结果不如预期时） 如果我有两个commit，先有commit a 后有commit b，如何在commit a中修改代码 # To modify code in commit a, you can use the `git rebase` command. # Here\u0026#39;s an example: # 1. Start an interactive rebase session git rebase -i HEAD~2 # 2. In the interactive rebase editor, change \u0026#34;pick\u0026#34; to \u0026#34;edit\u0026#34; for commit a # and save the file # 3. Git will stop at commit a. Now you can modify the code as needed # 在commit a中添加你的修改 # 4. Stage the changes git add . # 5. Amend the commit git commit --amend # 似乎不能是 --no-edit, 佛则这个commit就会消失 # 6. Continue the rebase git rebase --continue # The code in commit a is now modified. 3个commit，压缩为一个commit git log # step1 git rebase -i lastCommitID //lastCommitID 倒数第四次提交 # OR git rebase -i HEAD~3 # step2 vim 编辑 # 要把*下面*两个红色框 ‘pick’ 改为‘s’,表示第三次提交合并入第二次，第二次提交合并入第一次。 # 保存退出 git push -f BRANCHNAME Cherry-pick a - b - c - d Master \\ e - f - g Feature git checkout master # Cherry pick 操作, 【仅仅pick这一个commit】 git cherry-pick f #结果 a - b - c - d - f Master \\ e - f - g Feature # 若有冲突，解决后 git cherry-pick --continue 优势：cherry-pick 比笨方法好，笨方法会将重命名后的文件都保留\n",
  "keywords": [
    "git"
  ],
  "articleBody": "Push 和提 PR 是两个概念。一个PR其实是一个分支的概念，push 就 PR 该后，需要在 github 页面中手动提 PR（当然也可以通过gh命令）。这里要表达的是push和提PR是两回事。\n要想在 github 页面显示自己的分支，必须要 push。不想让别人看见自己的分支就不要提 PR。\nGit 常用命令 git log --oneline git rm -r --cached build # 将git上的build文件夹删除，同时保留本地。然后commit push后，远端的build也就被删除了。这里有个cache的概念。 git reflog git reset --hard 1359d449 git show-ref --verify --quiet git rebase git rev-parse HEAD git submodule sync \u0026\u0026 git submodule update --init --recursive git diff \u003e my.diff git apply my.diff # 在新的 branch git clone --single-branch git log --author=\"Author Name\" git log --grep=\"message\" git revert git config --list git commit --amend -m \"new commit message\" git push origin junhui_typo --force git reset --soft HEAD^ # 撤销上一个commit git reset --hard HEAD^ # 撤销所有commit git reset --hard # 撤销上一个操作（当上一个操作结果不如预期时） 如果我有两个commit，先有commit a 后有commit b，如何在commit a中修改代码 # To modify code in commit a, you can use the `git rebase` command. # Here's an example: # 1. Start an interactive rebase session git rebase -i HEAD~2 # 2. In the interactive rebase editor, change \"pick\" to \"edit\" for commit a # and save the file # 3. Git will stop at commit a. Now you can modify the code as needed # 在commit a中添加你的修改 # 4. Stage the changes git add . # 5. Amend the commit git commit --amend # 似乎不能是 --no-edit, 佛则这个commit就会消失 # 6. Continue the rebase git rebase --continue # The code in commit a is now modified. 3个commit，压缩为一个commit git log # step1 git rebase -i lastCommitID //lastCommitID 倒数第四次提交 # OR git rebase -i HEAD~3 # step2 vim 编辑 # 要把*下面*两个红色框 ‘pick’ 改为‘s’,表示第三次提交合并入第二次，第二次提交合并入第一次。 # 保存退出 git push -f BRANCHNAME Cherry-pick a - b - c - d Master \\ e - f - g Feature git checkout master # Cherry pick 操作, 【仅仅pick这一个commit】 git cherry-pick f #结果 a - b - c - d - f Master \\ e - f - g Feature # 若有冲突，解决后 git cherry-pick --continue 优势：cherry-pick 比笨方法好，笨方法会将重命名后的文件都保留\n[git如何cherry-pick 一个PR的多个commit？] [git如何cherry-pick 多个commit？] git cherry-pick commit1 commit2 commit3\ncherry-pick 多个commits： git cherry-pick A^..B 【A必须早与B，这个A^表示A是被包含的】 git cherry-pick 6fba45042585eac431138ae0aa8ebd579b09872b^..aef984b66360661b3116d9d1c1c9ca0cad66bf7f\nGit merge a - b master \\ e - f feature git checkout master git merge feature # 结果： a - b - e - f master # 如果你是master的author，当 master更新后，可以直接push（无PR），此时master远端也就更新了（有了新的feature） # 坑 rebase 和 rebase --continue 之间不要 commit。\ngit 在别人的分支上 提PR 直接通过upstream上创建分支 提PR 通过fork的repo上创建分支 github webhook Webhook 是一种使一个应用提供实时信息给其他应用的方法。它在特定事件发生时发送 HTTP 请求（通常是 POST(理解为发送一个请求到某一个位置) 请求）到预先配置的 URL。\n在 GitHub 中，你可以设置 webhook 来监听你的仓库的各种事件，如 push 事件、pull request 事件、issue 事件等。当这些事件发生时，GitHub 会发送一个包含事件详细信息的 HTTP 请求到你设置的 webhook URL。\nWebhook 的主要作用是实现实时的、自动的集成。例如，你可以设置一个 webhook，当你的仓库收到新的 push 时，自动触发 Jenkins 的构建，或者当新的 issue 被创建时，自动发送通知到你的 Slack 频道。\n如果你不使用 webhook，你就需要定期轮询 GitHub 的 API 来检查是否有新的事件。这可能会导致延迟（因为你需要等待下一次轮询才能检测到新的事件），并且可能会浪费资源（因为你需要不断地发送请求，即使没有新的事件）。而使用 webhook，你可以立即得到通知，并且只在有新的事件时才需要处理请求，从而提高效率和响应速度。\ngh gh --version conda install gh gh auth login #你首先要login，才可以使用gh访问指定repo gh run list --repo gh run view --repo gh run download --repo xxx --name yyy #下载Action中的artifact 在自动化中使用，在shell中使用，自动提PR，等\n",
  "wordCount" : "430",
  "inLanguage": "en",
  "datePublished": "2025-08-31T12:57:44+08:00",
  "dateModified": "2025-08-31T12:57:44+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ashburnLee.github.io/blog-2-hugo/git/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Junhui's Journal 2",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ashburnLee.github.io/blog-2-hugo/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ashburnLee.github.io/blog-2-hugo/" accesskey="h" title="Junhui&#39;s Journal 2 (Alt + H)">Junhui&#39;s Journal 2</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Git
    </h1>
    <div class="post-meta"><span title='2025-08-31 12:57:44 +0800 CST'>August 31, 2025</span>

</div>
  </header> 
  <div class="post-content"><p>Push 和提 PR 是两个概念。<strong>一个PR其实是一个分支的概念</strong>，push 就 PR 该后，需要在 github 页面中手动提 PR（当然也可以通过gh命令）。这里要表达的是push和提PR是两回事。</p>
<p>要想在 github 页面显示自己的分支，必须要 push。不想让别人看见自己的分支就不要提 PR。</p>
<h1 id="git">Git<a hidden class="anchor" aria-hidden="true" href="#git">#</a></h1>
<h2 id="常用命令">常用命令<a hidden class="anchor" aria-hidden="true" href="#常用命令">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git log --oneline
</span></span><span style="display:flex;"><span>git rm -r --cached build  <span style="color:#75715e"># 将git上的build文件夹删除，同时保留本地。然后commit push后，远端的build也就被删除了。这里有个cache的概念。 </span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>git reflog
</span></span><span style="display:flex;"><span>git reset --hard 1359d449
</span></span><span style="display:flex;"><span>git show-ref --verify --quiet
</span></span><span style="display:flex;"><span>git rebase
</span></span><span style="display:flex;"><span>git rev-parse HEAD
</span></span><span style="display:flex;"><span>git submodule sync <span style="color:#f92672">&amp;&amp;</span> git submodule update --init --recursive
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>git diff &gt; my.diff
</span></span><span style="display:flex;"><span>git apply my.diff  <span style="color:#75715e"># 在新的 branch</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>git clone --single-branch
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>git log --author<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Author Name&#34;</span>
</span></span><span style="display:flex;"><span>git log --grep<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;message&#34;</span>
</span></span><span style="display:flex;"><span>git revert
</span></span><span style="display:flex;"><span>git config --list
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>git commit --amend -m <span style="color:#e6db74">&#34;new commit message&#34;</span>
</span></span><span style="display:flex;"><span>git push origin junhui_typo --force
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>git reset --soft HEAD^  <span style="color:#75715e"># 撤销上一个commit</span>
</span></span><span style="display:flex;"><span>git reset --hard HEAD^  <span style="color:#75715e"># 撤销所有commit</span>
</span></span><span style="display:flex;"><span>git reset --hard        <span style="color:#75715e"># 撤销上一个操作（当上一个操作结果不如预期时）</span>
</span></span></code></pre></div><h2 id="如果我有两个commit先有commit-a-后有commit-b如何在commit-a中修改代码">如果我有两个commit，先有commit a 后有commit b，如何在commit a中修改代码<a hidden class="anchor" aria-hidden="true" href="#如果我有两个commit先有commit-a-后有commit-b如何在commit-a中修改代码">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># To modify code in commit a, you can use the `git rebase` command.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Here&#39;s an example:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 1. Start an interactive rebase session</span>
</span></span><span style="display:flex;"><span>git rebase -i HEAD~2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. In the interactive rebase editor, change &#34;pick&#34; to &#34;edit&#34; for commit a</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#    and save the file</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3. Git will stop at commit a. Now you can modify the code as needed</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 在commit a中添加你的修改</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 4. Stage the changes</span>
</span></span><span style="display:flex;"><span>git add .
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 5. Amend the commit</span>
</span></span><span style="display:flex;"><span>git commit --amend  <span style="color:#75715e"># 似乎不能是 --no-edit, 佛则这个commit就会消失</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 6. Continue the rebase</span>
</span></span><span style="display:flex;"><span>git rebase --continue
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># The code in commit a is now modified.</span>
</span></span></code></pre></div><h2 id="3个commit压缩为一个commit">3个commit，压缩为一个commit<a hidden class="anchor" aria-hidden="true" href="#3个commit压缩为一个commit">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git log
</span></span><span style="display:flex;"><span><span style="color:#75715e"># step1</span>
</span></span><span style="display:flex;"><span>git rebase -i lastCommitID  //lastCommitID 倒数第四次提交
</span></span><span style="display:flex;"><span><span style="color:#75715e"># OR</span>
</span></span><span style="display:flex;"><span>git rebase -i HEAD~3
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># step2 vim 编辑</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 要把*下面*两个红色框 ‘pick’ 改为‘s’,表示第三次提交合并入第二次，第二次提交合并入第一次。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 保存退出</span>
</span></span><span style="display:flex;"><span>git push -f BRANCHNAME
</span></span></code></pre></div><h2 id="cherry-pick">Cherry-pick<a hidden class="anchor" aria-hidden="true" href="#cherry-pick">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>    a - b - c - d     Master
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>           e - f - g  Feature
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>git checkout master
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Cherry pick 操作, 【仅仅pick这一个commit】</span>
</span></span><span style="display:flex;"><span>git cherry-pick f
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#结果</span>
</span></span><span style="display:flex;"><span>    a - b - c - d - f   Master
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>           e - f - g    Feature
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 若有冲突，解决后</span>
</span></span><span style="display:flex;"><span>git cherry-pick --continue
</span></span></code></pre></div><p>优势：cherry-pick 比笨方法好，笨方法会将重命名后的文件都保留</p>
<p>[git如何cherry-pick 一个PR的多个commit？]
[git如何cherry-pick 多个commit？]
<code>git cherry-pick commit1 commit2 commit3</code></p>
<p>cherry-pick 多个commits：
<code>git cherry-pick A^..B</code> 【A必须早与B，这个A^表示A是被包含的】
<code>git cherry-pick 6fba45042585eac431138ae0aa8ebd579b09872b^..aef984b66360661b3116d9d1c1c9ca0cad66bf7f</code></p>
<h2 id="git-merge">Git merge<a hidden class="anchor" aria-hidden="true" href="#git-merge">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>    a - b     master
</span></span><span style="display:flex;"><span>         <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>           e - f  feature
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>git checkout master
</span></span><span style="display:flex;"><span>git merge feature
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 结果：</span>
</span></span><span style="display:flex;"><span>    a - b - e - f     master
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 如果你是master的author，当 master更新后，可以直接push（无PR），此时master远端也就更新了（有了新的feature）</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span></code></pre></div><h2 id="坑">坑<a hidden class="anchor" aria-hidden="true" href="#坑">#</a></h2>
<p><code>rebase</code> 和 <code>rebase --continue</code> 之间不要 <code>commit</code>。</p>
<h2 id="git-在别人的分支上">git 在别人的分支上<a hidden class="anchor" aria-hidden="true" href="#git-在别人的分支上">#</a></h2>
<h2 id="提pr-直接通过upstream上创建分支">提PR 直接通过upstream上创建分支<a hidden class="anchor" aria-hidden="true" href="#提pr-直接通过upstream上创建分支">#</a></h2>
<h2 id="提pr-通过fork的repo上创建分支">提PR 通过fork的repo上创建分支<a hidden class="anchor" aria-hidden="true" href="#提pr-通过fork的repo上创建分支">#</a></h2>
<h2 id="github-webhook">github webhook<a hidden class="anchor" aria-hidden="true" href="#github-webhook">#</a></h2>
<p>Webhook 是一种使一个应用提供实时信息给其他应用的方法。它在特定事件发生时发送 HTTP 请求（通常是 POST(理解为发送一个请求到某一个位置) 请求）到预先配置的 URL。</p>
<p>在 GitHub 中，你可以设置 webhook 来监听你的仓库的各种事件，如 push 事件、pull request 事件、issue 事件等。当这些事件发生时，GitHub 会发送一个包含事件详细信息的 HTTP 请求到你设置的 webhook URL。</p>
<p>Webhook 的主要作用是实现<strong>实时的、自动</strong>的集成。例如，你可以设置一个 webhook，当你的仓库收到新的 push 时，自动触发 Jenkins 的构建，或者当新的 issue 被创建时，自动发送通知到你的 Slack 频道。</p>
<p>如果你不使用 webhook，你就需要定期轮询 GitHub 的 API 来检查是否有新的事件。这可能会导致延迟（因为你需要等待下一次轮询才能检测到新的事件），并且可能会浪费资源（因为你需要不断地发送请求，即使没有新的事件）。而使用 webhook，你可以立即得到通知，并且只在有新的事件时才需要处理请求，从而提高效率和响应速度。</p>
<h1 id="gh">gh<a hidden class="anchor" aria-hidden="true" href="#gh">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>gh --version
</span></span><span style="display:flex;"><span>conda install gh
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>gh auth login <span style="color:#75715e">#你首先要login，才可以使用gh访问指定repo</span>
</span></span><span style="display:flex;"><span>gh run list --repo
</span></span><span style="display:flex;"><span>gh run view &lt;run-id&gt; --repo 
</span></span><span style="display:flex;"><span>gh run download --repo xxx --name yyy <span style="color:#75715e">#下载Action中的artifact</span>
</span></span></code></pre></div><p>在自动化中使用，在shell中使用，自动提PR，等</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ashburnLee.github.io/blog-2-hugo/tags/git/">Git</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://ashburnLee.github.io/blog-2-hugo/">Junhui&#39;s Journal 2</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
