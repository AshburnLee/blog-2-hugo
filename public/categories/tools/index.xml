<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Tools on Junhui&#39;s Journal 2</title>
    <link>https://ashburnLee.github.io/blog-2-hugo/categories/tools/</link>
    <description>Recent content in Tools on Junhui&#39;s Journal 2</description>
    <generator>Hugo -- 0.149.0</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 31 Aug 2025 12:57:46 +0800</lastBuildDate>
    <atom:link href="https://ashburnLee.github.io/blog-2-hugo/categories/tools/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>网络 Clash</title>
      <link>https://ashburnLee.github.io/blog-2-hugo/%E7%BD%91%E7%BB%9C-clash/</link>
      <pubDate>Sun, 31 Aug 2025 12:57:46 +0800</pubDate>
      <guid>https://ashburnLee.github.io/blog-2-hugo/%E7%BD%91%E7%BB%9C-clash/</guid>
      <description>&lt;h1 id=&#34;路由路径&#34;&gt;路由路径&lt;/h1&gt;
&lt;p&gt;查看Windows系统中的路由路径，可以使用命令行工具 tracert（Trace Route），它可以显示数据包从本机到目标主机经过的每个路由节点（跳数），帮助分析路由路径和每跳延迟。也可使用 pathping 命令结合了 ping 和 tracert 的功能，带来更详细的路径和丢包统计。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;tracert 目标域名或IP地址
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pathping www.baidu.com
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;cookies&#34;&gt;cookies&lt;/h1&gt;
&lt;p&gt;Cookie 是网页服务器发送到你的浏览器中并储存的一小段数据文件（文本信息）。网页浏览器会保存这些Cookie，并在你访问同一网站时自动发送给服务器，使服务器能够识别你之前的访问和身份，并为你提供个性化服务。&lt;/p&gt;
&lt;h1 id=&#34;requests-库&#34;&gt;requests 库&lt;/h1&gt;
&lt;p&gt;requests 库是基于 HTTP 协议的客户端库。&lt;code&gt;requests.get()&lt;/code&gt; 等方法默认且仅支持 &lt;code&gt;HTTP/HTTPS&lt;/code&gt; 请求，这些方法定义的请求类型（&lt;code&gt;GET、POST、PUT、DELETE&lt;/code&gt;等）都是 HTTP 协议定义的动作。&lt;/p&gt;
&lt;p&gt;在发送请求时，优势需要给出&lt;code&gt;header&lt;/code&gt;。用来传递额外的元信息，比如访问指定服务器的 token。&lt;code&gt;headers&lt;/code&gt; 是一个字典，可以张这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; requests
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;GITHUB_TOKEN &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; xxx  &lt;span style=&#34;color:#75715e&#34;&gt;# Copy your GitHub token here&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;headers &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;User-Agent&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;MyApp/1.0&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Authorization&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Bearer my_secret_token&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Accept&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;application/json&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Authorization&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;token &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;GITHUB_TOKEN&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;response &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; requests&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://api.example.com/data&amp;#34;&lt;/span&gt;, headers&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;headers)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(response&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;status_code)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(response&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;json())
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;路由器负责将局域网的私有-ip-地址转换为互联网上的公网-ip-地址从而保证了互联网上的地址唯一性&#34;&gt;路由器负责将局域网的私有 IP 地址转换为互联网上的公网 IP 地址，从而保证了互联网上的地址唯一性&lt;/h1&gt;
&lt;p&gt;用一个具体的例子来说明路由器如何将局域网的私有 IP 地址转换为互联网上的公网 IP 地址，从而保证互联网地址的唯一性（通过 （Network Address Translation）NAT）。&lt;/p&gt;
&lt;p&gt;场景： 一个家庭网络，包含一台路由器、一台笔记本电脑和一手机。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Jenkins</title>
      <link>https://ashburnLee.github.io/blog-2-hugo/jenkins/</link>
      <pubDate>Sun, 31 Aug 2025 12:57:45 +0800</pubDate>
      <guid>https://ashburnLee.github.io/blog-2-hugo/jenkins/</guid>
      <description>&lt;h2 id=&#34;tutorial&#34;&gt;tutorial&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pipline &amp;amp; jenkinsfile 手册：https://www.jenkins.io/doc/book/pipeline/getting-started/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供的全局变量 &lt;code&gt;env.&lt;/code&gt;: &lt;code&gt;&amp;lt;Jenkins master的地址&amp;gt;/pipeline-syntax/globals#env&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pipline 实例：https://www.jenkins.io/doc/pipeline/examples/&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;尽可能应用jenkins提供的命令而不是一股脑儿使用shell脚本&#34;&gt;尽可能应用Jenkins提供的命令，而不是一股脑儿使用shell脚本&lt;/h2&gt;
&lt;p&gt;比如，git clone，使用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;checkout &lt;span style=&#34;color:#a6e22e&#34;&gt;scmGit&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;branches: &lt;span style=&#34;color:#f92672&#34;&gt;[[&lt;/span&gt;name: params&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;BRANCH&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                extensions: &lt;span style=&#34;color:#f92672&#34;&gt;[],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                userRemoteConfigs: &lt;span style=&#34;color:#f92672&#34;&gt;[[&lt;/span&gt;credentialsId: params&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;GITHUB_CREDENTIAL&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; url: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://github.com/xxx.git&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;jenkins是面向过程的对于任务配置多考虑使用表驱动&#34;&gt;jenkins是面向过程的，对于任务配置，多考虑使用表驱动&lt;/h2&gt;
&lt;h2 id=&#34;pipline-中访问-env-变量&#34;&gt;Pipline 中访问 env 变量&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;stage&lt;span style=&#34;color:#f92672&#34;&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    println &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;WORKSPACE: ${env.WORKSPACE}&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    echo env&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;WORKSPACE&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    echo WORKSPACE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;环境变量可以通过 Groovy 代码访问，方式为 &lt;code&gt;env.VARNAME&lt;/code&gt; 或者直接使用 &lt;code&gt;VARNAME&lt;/code&gt;。你也可以修改这些属性，但只能通过使用 &lt;code&gt;env.&lt;/code&gt; 前缀来写入。所以：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;jenkins job 中有保留的 env 变量，避免疑惑这些变量要加上 &lt;code&gt;env.&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;env 变量即使在机器上设定了，也是可以修改的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;groovy中的数学计算&#34;&gt;groovy中的数学计算&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; number &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;243&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 要计算的数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; fifthRoot &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; number &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;/5)  /&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;计算&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;次方根&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;两种pipline&#34;&gt;两种pipline&lt;/h2&gt;
&lt;p&gt;在Jenkins中，有两种主要类型的Pipeline：Scripted Pipeline 和 Declarative Pipeline。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Scripted Pipeline【我的工作中都是这种的脚本】:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;使用Groovy语法编写，允许更灵活的流程控制和自定义逻辑。&lt;/li&gt;
&lt;li&gt;通过node和stage等关键字来定义流水线的执行节点和阶段。&lt;/li&gt;
&lt;li&gt;可以直接编写Groovy脚本来构建流水线。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Declarative Pipeline:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;使用更结构化的语法，更易于阅读和维护。&lt;/li&gt;
&lt;li&gt;通过pipeline、agent、stages等关键字来定义流水线的结构和执行环境。&lt;/li&gt;
&lt;li&gt;提供了更丰富的语法来定义构建、部署和测试等阶段。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jenkins-中如何在多个-node-并行执行任务&#34;&gt;jenkins 中如何在多个 NODE 并行执行任务&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; parallel_tasks &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[:]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;params&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;GPU_TASK&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    parallel_tasks&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;GPU_TASK&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        node&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;params&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;GPU_NODE&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            stage&lt;span style=&#34;color:#f92672&#34;&gt;(){}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;params&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;CPU_TASK&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    parallel_tasks&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;CPU_TASK&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        node&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;params&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;CPU_NODE&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            stage&lt;span style=&#34;color:#f92672&#34;&gt;(){}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;parallel&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;parallel_tasks&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;elvis-操作符-&#34;&gt;Elvis 操作符 &lt;code&gt;?:&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;这两句句话有什么不同：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux Shell</title>
      <link>https://ashburnLee.github.io/blog-2-hugo/linux-shell/</link>
      <pubDate>Sun, 31 Aug 2025 12:57:45 +0800</pubDate>
      <guid>https://ashburnLee.github.io/blog-2-hugo/linux-shell/</guid>
      <description>&lt;h2 id=&#34;内存占用排序&#34;&gt;内存占用排序&lt;/h2&gt;
&lt;p&gt;实时查看和排序： &lt;code&gt;top → Shift+M&lt;/code&gt; 键入 &amp;lsquo;c&amp;rsquo; 隐藏/显示 完整命令&lt;/p&gt;
&lt;p&gt;快速查看排序列表： &lt;code&gt;ps aux --sort=-rss | head -10&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在资源受限的 Jetson 系统上是自愿检测的有力工具。&lt;/p&gt;
&lt;h2 id=&#34;cpptools-srv&#34;&gt;cpptools-srv&lt;/h2&gt;
&lt;p&gt;cpptools语言服务器。该进程提供代码智能提示（IntelliSense）、代码补全、语法检查、调试支持等功能。负责解析你的C/C++项目源代码，提升编辑和调试体验。&lt;/p&gt;
&lt;h2 id=&#34;vscode-ssh-链接服务-问题&#34;&gt;vscode ssh 链接服务 问题&lt;/h2&gt;
&lt;p&gt;VSCode 通过 SSH 连接目标服务器时，发现该服务器的主机密钥（host key）与本地保存的记录不一致。&lt;/p&gt;
&lt;p&gt;查看host上的key：&lt;code&gt;C:\Users\name\.ssh\kown_hosts&lt;/code&gt; 中的记录&lt;/p&gt;
&lt;p&gt;和&lt;/p&gt;
&lt;p&gt;服务器上的key：&lt;code&gt;ssh-keyscan -t rsa 192.168.x.x&lt;/code&gt; 应该一致。&lt;/p&gt;
&lt;p&gt;不一致时，将 host 上的删除，重新链接。不能删除服务器上的。因为你是host，想要链接服务器，你改变服务器的 key，很荒唐。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-t&lt;/code&gt; 指定密钥算法类型（rsa、ecdsa、ed25519等），所以你要先看看是哪个算法。发现两者密钥不一致，应该先确认服务器端主机密钥的正确性和安全性，然后删除本地客户端的旧密钥记录，再重新连接接受新的服务器密钥。&lt;/p&gt;
&lt;h2 id=&#34;服务器上的-key-secure-shell-host-key&#34;&gt;服务器上的 key 【Secure Shell Host Key】&lt;/h2&gt;
&lt;p&gt;ssh host key 是服务器用来唯一标识自身的SSH密钥对中的公钥部分。&lt;/p&gt;
&lt;p&gt;这个密钥是&lt;strong&gt;服务器的身份证&lt;/strong&gt;，用来确保客户端连接的是正确的服务器。当你用 VSCode 连接服务器时，VSCode（通过它的SSH扩展）会自动从服务器&lt;strong&gt;拉取&lt;/strong&gt;该服务器的host key（公钥），并在本地 &lt;strong&gt;known_hosts 文件里缓存&lt;/strong&gt;起来。这个过程并不是生成密钥，而是“拿到”和“保存”服务器提前生成好的密钥，以便后续验证。&lt;/p&gt;
&lt;p&gt;在大多数 Linux 服务器系统安装过程中，系统会自动调用 ssh-keygen 生成一组 SSH 主机密钥对（包括公钥和私钥），文件通常存放在 &lt;code&gt;/etc/ssh/&lt;/code&gt; 目录下，如 &lt;code&gt;ssh_host_rsa_key&lt;/code&gt; 和对应的 &lt;code&gt;.pub&lt;/code&gt; 文件等。用于 永久性保存用于识别服务器身份。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python</title>
      <link>https://ashburnLee.github.io/blog-2-hugo/python/</link>
      <pubDate>Sun, 31 Aug 2025 12:57:45 +0800</pubDate>
      <guid>https://ashburnLee.github.io/blog-2-hugo/python/</guid>
      <description>&lt;h2 id=&#34;pyenv--poetry&#34;&gt;pyenv &amp;amp;&amp;amp; poetry&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo apt update
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo apt upgrade
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pyenv install 3.9.0 -v &lt;span style=&#34;color:#75715e&#34;&gt;#建议不要使用系统python，而是为虚拟环境安装独立python&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 如果上述命令失败，看看log，大概率是某个package没有安装，log 通过 去掉 ‘-v’&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 创建一个名为 ppo_me 的 virtualenv，它基于 Python 3.9.0 版本。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pyenv virtualenv 3.9.0 ppo_me
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 激活虚拟环境。在当前目录下创建一个 .python-version 文件，并将 ppo_me 写入该文件。 当你进入这个目录或其子目录时，pyenv 会自动读取 .python-version 文件，并将 Python 环境设置为 ppo_me 这个 virtualenv。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pyenv local ppo_me
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 删除ppo_me 的虚拟环境，并删除对应的Python版本。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pyenv deactivate
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pyenv virtualenv-delete ppo_me
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pyenv uninstall 3.10.14
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rm -rf .python-version 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pyenv install 3.9.0
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pyenv virtualenv 3.9.0 ppo_me
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 创建一个 .python-version 文件，指定该项目使用的虚拟环境。 当你进入项目目录时，pyenv 会自动激活该虚拟环境。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pyenv local ppo_me
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;【KAQ】： 然后在当前目录下 执行 which python， 还是返回系统 Python 版本，而不是 指定的虚拟空间中的3.9.0 为什么? 通过 pyenv rehash&lt;/p&gt;</description>
    </item>
    <item>
      <title>CICD</title>
      <link>https://ashburnLee.github.io/blog-2-hugo/cicd/</link>
      <pubDate>Sun, 31 Aug 2025 12:57:44 +0800</pubDate>
      <guid>https://ashburnLee.github.io/blog-2-hugo/cicd/</guid>
      <description>&lt;p&gt;回忆 Jenkin 是如何实现当 PR push 时自动触发执行的？需要找一个 jenkins 插件帮助我实现 PR 通过 关键字 触发 CI.&lt;/p&gt;
&lt;p&gt;使用什么插件？尝试了 “GitHub Branch Source” 中的 “Multibranch Pipeline projects”，需要在目标 repo 的根目录中创建并编辑 JenkinsFile 文件并且在 github repo 中配置一个webhook，每当有新 PR 到这个 repo，扫描 repo 并触发新 branch 执行 JenkinsFile。每一个 branch 触发一个 job，而这个 job 是不能通过修改 job config 来参数化的，需要通过 property step 在 JenkinsFile 中将这个branch 的 job 参数化。如此就可以执行任何内容了。&lt;/p&gt;
&lt;h1 id=&#34;pytest&#34;&gt;Pytest&lt;/h1&gt;
&lt;h2 id=&#34;pytest-测试框架&#34;&gt;Pytest 测试框架&lt;/h2&gt;
&lt;p&gt;pytest 提供了许多装饰器，比如 &lt;code&gt;@pytest.mark.parametrize&lt;/code&gt; 让你为一个测试用例提供多个输入（输出参数，不同参数之间会进行&lt;strong&gt;笛卡尔积组合&lt;/strong&gt;）。减少了重复代码。&lt;/p&gt;
&lt;p&gt;更多用法 看看 pytest 命令参数。结果有4中状态，xfailed 等。实例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; pytest
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@pytest.mark.parametrize&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@pytest.mark.parametrize&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;b&amp;#34;&lt;/span&gt;, [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;y&amp;#39;&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;test_example&lt;/span&gt;(a, b):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Testing with a=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;a&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; and b=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;b&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 输出将会是：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Testing with a=1 and b=x&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Testing with a=1 and b=y&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Testing with a=2 and b=x&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Testing with a=2 and b=y&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;跳过某些-test-cases&#34;&gt;跳过某些 test cases&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;pytest.mark.skip&lt;/code&gt; 标记 case。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;--deselect-from-file&lt;/code&gt; 接受一个文件，这个文件中的所有 cases 都会被跳过。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;--ignore=test_xxx.py&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;与-pytest-一同使用的插件&#34;&gt;与 pytest 一同使用的插件&lt;/h2&gt;
&lt;p&gt;pytest-select&lt;/p&gt;</description>
    </item>
    <item>
      <title>Git</title>
      <link>https://ashburnLee.github.io/blog-2-hugo/git/</link>
      <pubDate>Sun, 31 Aug 2025 12:57:44 +0800</pubDate>
      <guid>https://ashburnLee.github.io/blog-2-hugo/git/</guid>
      <description>&lt;p&gt;Push 和提 PR 是两个概念。&lt;strong&gt;一个PR其实是一个分支的概念&lt;/strong&gt;，push 就 PR 该后，需要在 github 页面中手动提 PR（当然也可以通过gh命令）。这里要表达的是push和提PR是两回事。&lt;/p&gt;
&lt;p&gt;要想在 github 页面显示自己的分支，必须要 push。不想让别人看见自己的分支就不要提 PR。&lt;/p&gt;
&lt;h1 id=&#34;git&#34;&gt;Git&lt;/h1&gt;
&lt;h2 id=&#34;常用命令&#34;&gt;常用命令&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git log --oneline
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git rm -r --cached build  &lt;span style=&#34;color:#75715e&#34;&gt;# 将git上的build文件夹删除，同时保留本地。然后commit push后，远端的build也就被删除了。这里有个cache的概念。 &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git reflog
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git reset --hard 1359d449
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git show-ref --verify --quiet
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git rebase
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git rev-parse HEAD
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git submodule sync &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; git submodule update --init --recursive
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git diff &amp;gt; my.diff
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git apply my.diff  &lt;span style=&#34;color:#75715e&#34;&gt;# 在新的 branch&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone --single-branch
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git log --author&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Author Name&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git log --grep&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;message&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git revert
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git config --list
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git commit --amend -m &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;new commit message&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git push origin junhui_typo --force
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git reset --soft HEAD^  &lt;span style=&#34;color:#75715e&#34;&gt;# 撤销上一个commit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git reset --hard HEAD^  &lt;span style=&#34;color:#75715e&#34;&gt;# 撤销所有commit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git reset --hard        &lt;span style=&#34;color:#75715e&#34;&gt;# 撤销上一个操作（当上一个操作结果不如预期时）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;如果我有两个commit先有commit-a-后有commit-b如何在commit-a中修改代码&#34;&gt;如果我有两个commit，先有commit a 后有commit b，如何在commit a中修改代码&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# To modify code in commit a, you can use the `git rebase` command.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Here&amp;#39;s an example:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 1. Start an interactive rebase session&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git rebase -i HEAD~2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 2. In the interactive rebase editor, change &amp;#34;pick&amp;#34; to &amp;#34;edit&amp;#34; for commit a&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#    and save the file&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 3. Git will stop at commit a. Now you can modify the code as needed&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 在commit a中添加你的修改&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 4. Stage the changes&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git add .
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 5. Amend the commit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git commit --amend  &lt;span style=&#34;color:#75715e&#34;&gt;# 似乎不能是 --no-edit, 佛则这个commit就会消失&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 6. Continue the rebase&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git rebase --continue
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# The code in commit a is now modified.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;3个commit压缩为一个commit&#34;&gt;3个commit，压缩为一个commit&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git log
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# step1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git rebase -i lastCommitID  //lastCommitID 倒数第四次提交
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# OR&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git rebase -i HEAD~3
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# step2 vim 编辑&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 要把*下面*两个红色框 ‘pick’ 改为‘s’,表示第三次提交合并入第二次，第二次提交合并入第一次。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 保存退出&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git push -f BRANCHNAME
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;cherry-pick&#34;&gt;Cherry-pick&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    a - b - c - d     Master
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;           e - f - g  Feature
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git checkout master
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Cherry pick 操作, 【仅仅pick这一个commit】&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git cherry-pick f
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#结果&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    a - b - c - d - f   Master
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;           e - f - g    Feature
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 若有冲突，解决后&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git cherry-pick --continue
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;优势：cherry-pick 比笨方法好，笨方法会将重命名后的文件都保留&lt;/p&gt;</description>
    </item>
    <item>
      <title>Github Actions</title>
      <link>https://ashburnLee.github.io/blog-2-hugo/github-actions/</link>
      <pubDate>Sun, 31 Aug 2025 12:57:44 +0800</pubDate>
      <guid>https://ashburnLee.github.io/blog-2-hugo/github-actions/</guid>
      <description>&lt;h2 id=&#34;使用-actionscache&#34;&gt;使用 actions/cache&lt;/h2&gt;
&lt;p&gt;如果你的工作流程经常运行，使用缓存来存储依赖项（如 Bandit）可以减少安装时间。
比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yml&#34; data-lang=&#34;yml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Cache Python dependencies&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;uses&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;actions/cache@v2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;with&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;path&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;~/.cache/pip&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;key&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;${{ runner.os }}-pip-${{ hashFiles(&amp;#39;**/requirements.txt&amp;#39;) }}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;restore-keys&lt;/span&gt;: |&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;            ${{ runner.os }}-pip-&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;我的-github-workflow-工作流程经常运行但是不一定是在同一台机器上这种情况下actionscache-如何cache&#34;&gt;我的 github workflow 工作流程经常运行，但是不一定是在同一台机器上，这种情况下actions/cache 如何cache&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;actions/cache@v2&lt;/code&gt; 是跨工作流程和跨运行器设计的，这意味着即使工作流程在不同的机器上运行，缓存仍然是有效的。&lt;strong&gt;缓存是与仓库相关联的&lt;/strong&gt;，而不是与特定的运行器实例相关联。&lt;/p&gt;
&lt;p&gt;这是 &lt;code&gt;actions/cache&lt;/code&gt; 的一个重要特性。缓存不是存储在某一台特定的运行器或机器上，而是&lt;strong&gt;存储在 GitHub 的云端基础设施中&lt;/strong&gt;。当你使用 &lt;code&gt;actions/cache&lt;/code&gt; 创建缓存时，GitHub 会将缓存内容保存在其服务器上，这样无论后续的工作流程在哪里运行，都可以访问和恢复这些缓存。&lt;/p&gt;
&lt;h2 id=&#34;坑&#34;&gt;坑&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;actions/checkout@v4 只会最少的 repo 内容给你，与手动 clone 不同，所以你需要提供一些其他参数来给出更多的 commit 等信息。&lt;strong&gt;因为actions/checkout@v4 默认不会把历史commit 给你&lt;/strong&gt; 需要添加 &lt;code&gt;fetch-depth: 0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;github 不希望你访问除了当前repo之外的目录，所以&lt;strong&gt;所有的操作都应该在这个repo的目录中&lt;/strong&gt;，比如你想clone例外一个repo，那么把它clone到当前repo的 external/new_repo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于GitHub Actions的安全限制，工作流中的步骤&lt;strong&gt;不能直接传递&lt;/strong&gt;输出到触发下一次工作流的schedule触发器。因此，你需要考虑其他方法来存储和检索PR编号，例如使用仓库的Secrets、工作流的**工件(artifacts)**或者外部存储服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;${{ env.TARGET_PRID }}&lt;/code&gt; 这种方式的变量是 yml 变量，不应该在 shell 命令中使用（即不应该使用在 &lt;code&gt;run: |&lt;/code&gt;）,但功能上也可以在shell 中这样访问。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;echo &amp;quot;TARGET_PRID=$(&amp;lt;file_downloaded/PRID.txt)&amp;quot; &amp;gt;&amp;gt; $GITHUB_ENV&lt;/code&gt; 这句话表示将变量 &lt;code&gt;TARGET_PRID&lt;/code&gt; 放在环境变量中，并且在&lt;strong&gt;相同的job&lt;/strong&gt;中的后续步骤中的 shell 总可以直接访问 &lt;code&gt;$TARGET_PRID&lt;/code&gt;。而且 在非shell的地方可以通过 &lt;code&gt;{{ env.TARGET_PRID }}&lt;/code&gt; 访问其值。在当前job中之后的步骤里，已经有值了，生效了。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
