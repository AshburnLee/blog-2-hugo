<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Github Actions | Junhui&#39;s Journal 2</title>
<meta name="keywords" content="github actions, CICD">
<meta name="description" content="使用 actions/cache
如果你的工作流程经常运行，使用缓存来存储依赖项（如 Bandit）可以减少安装时间。
比如：
      - name: Cache Python dependencies
        uses: actions/cache@v2
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles(&#39;**/requirements.txt&#39;) }}
          restore-keys: |
            ${{ runner.os }}-pip-
我的 github workflow 工作流程经常运行，但是不一定是在同一台机器上，这种情况下actions/cache 如何cache
actions/cache@v2 是跨工作流程和跨运行器设计的，这意味着即使工作流程在不同的机器上运行，缓存仍然是有效的。缓存是与仓库相关联的，而不是与特定的运行器实例相关联。
这是 actions/cache 的一个重要特性。缓存不是存储在某一台特定的运行器或机器上，而是存储在 GitHub 的云端基础设施中。当你使用 actions/cache 创建缓存时，GitHub 会将缓存内容保存在其服务器上，这样无论后续的工作流程在哪里运行，都可以访问和恢复这些缓存。
坑


actions/checkout@v4 只会最少的 repo 内容给你，与手动 clone 不同，所以你需要提供一些其他参数来给出更多的 commit 等信息。因为actions/checkout@v4 默认不会把历史commit 给你 需要添加 fetch-depth: 0


github 不希望你访问除了当前repo之外的目录，所以所有的操作都应该在这个repo的目录中，比如你想clone例外一个repo，那么把它clone到当前repo的 external/new_repo


由于GitHub Actions的安全限制，工作流中的步骤不能直接传递输出到触发下一次工作流的schedule触发器。因此，你需要考虑其他方法来存储和检索PR编号，例如使用仓库的Secrets、工作流的**工件(artifacts)**或者外部存储服务。


${{ env.TARGET_PRID }} 这种方式的变量是 yml 变量，不应该在 shell 命令中使用（即不应该使用在 run: |）,但功能上也可以在shell 中这样访问。


echo &quot;TARGET_PRID=$(&lt;file_downloaded/PRID.txt)&quot; &gt;&gt; $GITHUB_ENV 这句话表示将变量 TARGET_PRID 放在环境变量中，并且在相同的job中的后续步骤中的 shell 总可以直接访问 $TARGET_PRID。而且 在非shell的地方可以通过 {{ env.TARGET_PRID }} 访问其值。在当前job中之后的步骤里，已经有值了，生效了。">
<meta name="author" content="">
<link rel="canonical" href="https://ashburnLee.github.io/blog-2-hugo/github-actions/">
<link crossorigin="anonymous" href="/blog-2-hugo/assets/css/stylesheet.bdaf5941cb3c05e36e857d9e2953ba0c4485ba7bc2da15db169d66a77cbc7a87.css" integrity="sha256-va9ZQcs8BeNuhX2eKVO6DESFunvC2hXbFp1mp3y8eoc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ashburnLee.github.io/blog-2-hugo/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ashburnLee.github.io/blog-2-hugo/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ashburnLee.github.io/blog-2-hugo/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ashburnLee.github.io/blog-2-hugo/apple-touch-icon.png">
<link rel="mask-icon" href="https://ashburnLee.github.io/blog-2-hugo/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://ashburnLee.github.io/blog-2-hugo/github-actions/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" id="MathJax-script" async></script>


<meta property="og:url" content="https://ashburnLee.github.io/blog-2-hugo/github-actions/">
  <meta property="og:site_name" content="Junhui&#39;s Journal 2">
  <meta property="og:title" content="Github Actions">
  <meta property="og:description" content="使用 actions/cache 如果你的工作流程经常运行，使用缓存来存储依赖项（如 Bandit）可以减少安装时间。 比如：
- name: Cache Python dependencies uses: actions/cache@v2 with: path: ~/.cache/pip key: ${{ runner.os }}-pip-${{ hashFiles(&#39;**/requirements.txt&#39;) }} restore-keys: | ${{ runner.os }}-pip- 我的 github workflow 工作流程经常运行，但是不一定是在同一台机器上，这种情况下actions/cache 如何cache actions/cache@v2 是跨工作流程和跨运行器设计的，这意味着即使工作流程在不同的机器上运行，缓存仍然是有效的。缓存是与仓库相关联的，而不是与特定的运行器实例相关联。
这是 actions/cache 的一个重要特性。缓存不是存储在某一台特定的运行器或机器上，而是存储在 GitHub 的云端基础设施中。当你使用 actions/cache 创建缓存时，GitHub 会将缓存内容保存在其服务器上，这样无论后续的工作流程在哪里运行，都可以访问和恢复这些缓存。
坑 actions/checkout@v4 只会最少的 repo 内容给你，与手动 clone 不同，所以你需要提供一些其他参数来给出更多的 commit 等信息。因为actions/checkout@v4 默认不会把历史commit 给你 需要添加 fetch-depth: 0
github 不希望你访问除了当前repo之外的目录，所以所有的操作都应该在这个repo的目录中，比如你想clone例外一个repo，那么把它clone到当前repo的 external/new_repo
由于GitHub Actions的安全限制，工作流中的步骤不能直接传递输出到触发下一次工作流的schedule触发器。因此，你需要考虑其他方法来存储和检索PR编号，例如使用仓库的Secrets、工作流的**工件(artifacts)**或者外部存储服务。
${{ env.TARGET_PRID }} 这种方式的变量是 yml 变量，不应该在 shell 命令中使用（即不应该使用在 run: |）,但功能上也可以在shell 中这样访问。
echo &#34;TARGET_PRID=$(&lt;file_downloaded/PRID.txt)&#34; &gt;&gt; $GITHUB_ENV 这句话表示将变量 TARGET_PRID 放在环境变量中，并且在相同的job中的后续步骤中的 shell 总可以直接访问 $TARGET_PRID。而且 在非shell的地方可以通过 {{ env.TARGET_PRID }} 访问其值。在当前job中之后的步骤里，已经有值了，生效了。">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:published_time" content="2025-08-31T12:57:44+08:00">
    <meta property="article:modified_time" content="2025-08-31T12:57:44+08:00">
    <meta property="article:tag" content="Github Actions">
    <meta property="article:tag" content="CICD">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Github Actions">
<meta name="twitter:description" content="使用 actions/cache
如果你的工作流程经常运行，使用缓存来存储依赖项（如 Bandit）可以减少安装时间。
比如：
      - name: Cache Python dependencies
        uses: actions/cache@v2
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles(&#39;**/requirements.txt&#39;) }}
          restore-keys: |
            ${{ runner.os }}-pip-
我的 github workflow 工作流程经常运行，但是不一定是在同一台机器上，这种情况下actions/cache 如何cache
actions/cache@v2 是跨工作流程和跨运行器设计的，这意味着即使工作流程在不同的机器上运行，缓存仍然是有效的。缓存是与仓库相关联的，而不是与特定的运行器实例相关联。
这是 actions/cache 的一个重要特性。缓存不是存储在某一台特定的运行器或机器上，而是存储在 GitHub 的云端基础设施中。当你使用 actions/cache 创建缓存时，GitHub 会将缓存内容保存在其服务器上，这样无论后续的工作流程在哪里运行，都可以访问和恢复这些缓存。
坑


actions/checkout@v4 只会最少的 repo 内容给你，与手动 clone 不同，所以你需要提供一些其他参数来给出更多的 commit 等信息。因为actions/checkout@v4 默认不会把历史commit 给你 需要添加 fetch-depth: 0


github 不希望你访问除了当前repo之外的目录，所以所有的操作都应该在这个repo的目录中，比如你想clone例外一个repo，那么把它clone到当前repo的 external/new_repo


由于GitHub Actions的安全限制，工作流中的步骤不能直接传递输出到触发下一次工作流的schedule触发器。因此，你需要考虑其他方法来存储和检索PR编号，例如使用仓库的Secrets、工作流的**工件(artifacts)**或者外部存储服务。


${{ env.TARGET_PRID }} 这种方式的变量是 yml 变量，不应该在 shell 命令中使用（即不应该使用在 run: |）,但功能上也可以在shell 中这样访问。


echo &quot;TARGET_PRID=$(&lt;file_downloaded/PRID.txt)&quot; &gt;&gt; $GITHUB_ENV 这句话表示将变量 TARGET_PRID 放在环境变量中，并且在相同的job中的后续步骤中的 shell 总可以直接访问 $TARGET_PRID。而且 在非shell的地方可以通过 {{ env.TARGET_PRID }} 访问其值。在当前job中之后的步骤里，已经有值了，生效了。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Github Actions",
      "item": "https://ashburnLee.github.io/blog-2-hugo/github-actions/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Github Actions",
  "name": "Github Actions",
  "description": "使用 actions/cache 如果你的工作流程经常运行，使用缓存来存储依赖项（如 Bandit）可以减少安装时间。 比如：\n- name: Cache Python dependencies uses: actions/cache@v2 with: path: ~/.cache/pip key: ${{ runner.os }}-pip-${{ hashFiles(\u0026#39;**/requirements.txt\u0026#39;) }} restore-keys: | ${{ runner.os }}-pip- 我的 github workflow 工作流程经常运行，但是不一定是在同一台机器上，这种情况下actions/cache 如何cache actions/cache@v2 是跨工作流程和跨运行器设计的，这意味着即使工作流程在不同的机器上运行，缓存仍然是有效的。缓存是与仓库相关联的，而不是与特定的运行器实例相关联。\n这是 actions/cache 的一个重要特性。缓存不是存储在某一台特定的运行器或机器上，而是存储在 GitHub 的云端基础设施中。当你使用 actions/cache 创建缓存时，GitHub 会将缓存内容保存在其服务器上，这样无论后续的工作流程在哪里运行，都可以访问和恢复这些缓存。\n坑 actions/checkout@v4 只会最少的 repo 内容给你，与手动 clone 不同，所以你需要提供一些其他参数来给出更多的 commit 等信息。因为actions/checkout@v4 默认不会把历史commit 给你 需要添加 fetch-depth: 0\ngithub 不希望你访问除了当前repo之外的目录，所以所有的操作都应该在这个repo的目录中，比如你想clone例外一个repo，那么把它clone到当前repo的 external/new_repo\n由于GitHub Actions的安全限制，工作流中的步骤不能直接传递输出到触发下一次工作流的schedule触发器。因此，你需要考虑其他方法来存储和检索PR编号，例如使用仓库的Secrets、工作流的**工件(artifacts)**或者外部存储服务。\n${{ env.TARGET_PRID }} 这种方式的变量是 yml 变量，不应该在 shell 命令中使用（即不应该使用在 run: |）,但功能上也可以在shell 中这样访问。\necho \u0026quot;TARGET_PRID=$(\u0026lt;file_downloaded/PRID.txt)\u0026quot; \u0026gt;\u0026gt; $GITHUB_ENV 这句话表示将变量 TARGET_PRID 放在环境变量中，并且在相同的job中的后续步骤中的 shell 总可以直接访问 $TARGET_PRID。而且 在非shell的地方可以通过 {{ env.TARGET_PRID }} 访问其值。在当前job中之后的步骤里，已经有值了，生效了。\n",
  "keywords": [
    "github actions", "CICD"
  ],
  "articleBody": "使用 actions/cache 如果你的工作流程经常运行，使用缓存来存储依赖项（如 Bandit）可以减少安装时间。 比如：\n- name: Cache Python dependencies uses: actions/cache@v2 with: path: ~/.cache/pip key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }} restore-keys: | ${{ runner.os }}-pip- 我的 github workflow 工作流程经常运行，但是不一定是在同一台机器上，这种情况下actions/cache 如何cache actions/cache@v2 是跨工作流程和跨运行器设计的，这意味着即使工作流程在不同的机器上运行，缓存仍然是有效的。缓存是与仓库相关联的，而不是与特定的运行器实例相关联。\n这是 actions/cache 的一个重要特性。缓存不是存储在某一台特定的运行器或机器上，而是存储在 GitHub 的云端基础设施中。当你使用 actions/cache 创建缓存时，GitHub 会将缓存内容保存在其服务器上，这样无论后续的工作流程在哪里运行，都可以访问和恢复这些缓存。\n坑 actions/checkout@v4 只会最少的 repo 内容给你，与手动 clone 不同，所以你需要提供一些其他参数来给出更多的 commit 等信息。因为actions/checkout@v4 默认不会把历史commit 给你 需要添加 fetch-depth: 0\ngithub 不希望你访问除了当前repo之外的目录，所以所有的操作都应该在这个repo的目录中，比如你想clone例外一个repo，那么把它clone到当前repo的 external/new_repo\n由于GitHub Actions的安全限制，工作流中的步骤不能直接传递输出到触发下一次工作流的schedule触发器。因此，你需要考虑其他方法来存储和检索PR编号，例如使用仓库的Secrets、工作流的**工件(artifacts)**或者外部存储服务。\n${{ env.TARGET_PRID }} 这种方式的变量是 yml 变量，不应该在 shell 命令中使用（即不应该使用在 run: |）,但功能上也可以在shell 中这样访问。\necho \"TARGET_PRID=$(",
  "wordCount" : "450",
  "inLanguage": "en",
  "datePublished": "2025-08-31T12:57:44+08:00",
  "dateModified": "2025-08-31T12:57:44+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ashburnLee.github.io/blog-2-hugo/github-actions/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Junhui's Journal 2",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ashburnLee.github.io/blog-2-hugo/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ashburnLee.github.io/blog-2-hugo/" accesskey="h" title="Junhui&#39;s Journal 2 (Alt + H)">Junhui&#39;s Journal 2</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://ashburnLee.github.io/blog-2-hugo/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Github Actions
    </h1>
    <div class="post-meta"><span title='2025-08-31 12:57:44 +0800 CST'>August 31, 2025</span>

</div>
  </header> 
  <div class="post-content"><h2 id="使用-actionscache">使用 actions/cache<a hidden class="anchor" aria-hidden="true" href="#使用-actionscache">#</a></h2>
<p>如果你的工作流程经常运行，使用缓存来存储依赖项（如 Bandit）可以减少安装时间。
比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Cache Python dependencies</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/cache@v2</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">with</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">path</span>: <span style="color:#ae81ff">~/.cache/pip</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">key</span>: <span style="color:#ae81ff">${{ runner.os }}-pip-${{ hashFiles(&#39;**/requirements.txt&#39;) }}</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">restore-keys</span>: |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ${{ runner.os }}-pip-</span>
</span></span></code></pre></div><h2 id="我的-github-workflow-工作流程经常运行但是不一定是在同一台机器上这种情况下actionscache-如何cache">我的 github workflow 工作流程经常运行，但是不一定是在同一台机器上，这种情况下actions/cache 如何cache<a hidden class="anchor" aria-hidden="true" href="#我的-github-workflow-工作流程经常运行但是不一定是在同一台机器上这种情况下actionscache-如何cache">#</a></h2>
<p><code>actions/cache@v2</code> 是跨工作流程和跨运行器设计的，这意味着即使工作流程在不同的机器上运行，缓存仍然是有效的。<strong>缓存是与仓库相关联的</strong>，而不是与特定的运行器实例相关联。</p>
<p>这是 <code>actions/cache</code> 的一个重要特性。缓存不是存储在某一台特定的运行器或机器上，而是<strong>存储在 GitHub 的云端基础设施中</strong>。当你使用 <code>actions/cache</code> 创建缓存时，GitHub 会将缓存内容保存在其服务器上，这样无论后续的工作流程在哪里运行，都可以访问和恢复这些缓存。</p>
<h2 id="坑">坑<a hidden class="anchor" aria-hidden="true" href="#坑">#</a></h2>
<ol>
<li>
<p>actions/checkout@v4 只会最少的 repo 内容给你，与手动 clone 不同，所以你需要提供一些其他参数来给出更多的 commit 等信息。<strong>因为actions/checkout@v4 默认不会把历史commit 给你</strong> 需要添加 <code>fetch-depth: 0</code></p>
</li>
<li>
<p>github 不希望你访问除了当前repo之外的目录，所以<strong>所有的操作都应该在这个repo的目录中</strong>，比如你想clone例外一个repo，那么把它clone到当前repo的 external/new_repo</p>
</li>
<li>
<p>由于GitHub Actions的安全限制，工作流中的步骤<strong>不能直接传递</strong>输出到触发下一次工作流的schedule触发器。因此，你需要考虑其他方法来存储和检索PR编号，例如使用仓库的Secrets、工作流的**工件(artifacts)**或者外部存储服务。</p>
</li>
<li>
<p><code>${{ env.TARGET_PRID }}</code> 这种方式的变量是 yml 变量，不应该在 shell 命令中使用（即不应该使用在 <code>run: |</code>）,但功能上也可以在shell 中这样访问。</p>
</li>
<li>
<p><code>echo &quot;TARGET_PRID=$(&lt;file_downloaded/PRID.txt)&quot; &gt;&gt; $GITHUB_ENV</code> 这句话表示将变量 <code>TARGET_PRID</code> 放在环境变量中，并且在<strong>相同的job</strong>中的后续步骤中的 shell 总可以直接访问 <code>$TARGET_PRID</code>。而且 在非shell的地方可以通过 <code>{{ env.TARGET_PRID }}</code> 访问其值。在当前job中之后的步骤里，已经有值了，生效了。</p>
</li>
<li>
<p><code>actions/upload-artifact@v4</code> 过程上传的文件或文件夹会被自动压缩成一个ZIP文件。这是GitHub Actions的工件存储服务的一部分，旨在优化存储和传输效率。当你使用 <code>actions/download-artifact@v4</code> 下载工件时，GitHub Actions 会自动为你解压这个ZIP文件。你不需要手动执行任何解压缩步骤。</p>
</li>
<li>
<p><code>actions/checkout@v4</code> 你给什么 ref 值？如果 ref 为空，它将检出当前工作流触发的仓库，就是 <code>on:</code> 的时候你指定的那个分支</p>
</li>
<li>
<p><code>defaults:run:</code> 会在之后步骤中的所有 <code>run:</code> 下生效，小心不要被覆盖</p>
</li>
<li>
<p><code>PAT</code> 和 <code>GITHUB_TOKEN</code> 的不同</p>
</li>
<li>
<p>在workflow中执行 <code>gh</code> 命令需要你的repo管理员提供 <code>GITHUB_TOKEN</code></p>
</li>
<li>
<p>yml 中的根目录是其所在repo的根目录，<code>$GITHUB_WORKSPACE</code> 环境变量指向的是当前仓库被检出到的目录，而GitHub Actions出于安全考虑，通常不允许你访问或修改该目录之外的文件系统。</p>
</li>
<li>
<p>使用官方action时，注意其行为可能与你认为都不同，比如 actions/checkout@v4，结果是其 commitlog 并不完整，需要提供其他参数。</p>
</li>
</ol>
<h2 id="defaults-run"><code>defaults: run:</code><a hidden class="anchor" aria-hidden="true" href="#defaults-run">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span><span style="color:#f92672">defaults</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">run</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">shell</span>: <span style="color:#ae81ff">bash -noprofile --norc -eo pipefail -c &#34;source /home/runner/setvars.sh &amp;gt; /dev/null; source {0}&#34;</span>
</span></span></code></pre></div><p>defaults 关键字允许你为整个工作流中的所有 run 步骤设置默认的行为。在你提供的代码片段中，defaults 被用来自定义运行shell命令时使用的shell程序及其选项。</p>
<p>具体来说，这段代码做了以下几件事情：</p>
<ul>
<li>
<p>设置默认shell：为所有的 run 步骤设置默认的shell为 bash。</p>
</li>
<li>
<p>设置shell选项：</p>
<ol>
<li><code>-noprofile</code>：告诉 bash 在启动时不读取profile文件（如 <code>~/.bash_profile</code> 或 <code>~/.profile</code>），这些文件通常在登录时执行。</li>
<li><code>--norc</code>：告诉 bash 在启动时不读取 <code>~/.bashrc</code> 配置文件，这个文件通常在非登录shell会话中执行。</li>
<li><code>-eo pipefail</code>：设置两个选项，<code>-e</code> 使得如果任何命令返回非零退出状态，整个命令列表将立即退出；<code>-o pipefail</code> 选项会导致管道（pipe）中的任何命令失败都会使整个管道命令返回非零状态。</li>
<li><code>-c</code>：后面跟随的是要执行的命令字符串。</li>
</ol>
</li>
<li>
<p>执行初始化命令：在执行任何 run 步骤中的脚本之前，先执行 <code>source /home/runner/setvars.sh &gt; /dev/null</code> 命令。这个命令似乎是为了初始化Intel oneAPI环境变量，使得后续的步骤可以使用oneAPI工具链。输出被重定向到 /dev/null，意味着你不会在日志中看到任何输出。</p>
</li>
<li>
<p>执行用户脚本：<code>source {0}</code> 是一个占位符，它将被后续 run 步骤中的脚本内容替换。这意味着每个 run 步骤中的脚本都会在初始化oneAPI环境之后执行。</p>
</li>
</ul>
<p>总的来说，这段代码为工作流中的所有 run 步骤设置了一个自定义的shell环境，其中包括了初始化Intel oneAPI环境的步骤，以确保所有的步骤都在正确配置的环境中运行。</p>
<p>注意：如果你在某个特定的 run 步骤中指定了 shell，那么它将覆盖在 defaults 中为 run 步骤设置的默认 shell 配置！！！</p>
<h2 id="needs-关键字">needs 关键字<a hidden class="anchor" aria-hidden="true" href="#needs-关键字">#</a></h2>
<p>如果你在一个工作流中上传工件，在另一个工作流中下载，后者需要有一个<code>needs</code>关键字来指定它依赖于前者。</p>
<h2 id="actionscheckoutv4"><code>actions/checkout@v4</code><a hidden class="anchor" aria-hidden="true" href="#actionscheckoutv4">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span>- <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Checkout repository</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/checkout@v4</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">with</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">ref</span>: <span style="color:#ae81ff">llvm-target</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">fetch-depth</span>: <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>注意这里的ref的值！！！如果 ref 为空，它将检出当前工作流触发的仓库，就是 <code>on:</code> 的时候你指定的那个分支</p>
<h2 id="设置步骤的输出">设置步骤的输出<a hidden class="anchor" aria-hidden="true" href="#设置步骤的输出">#</a></h2>
<p>Deprecated:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span><span style="color:#f92672">steps</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">id</span>: <span style="color:#ae81ff">get_pr_id</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">run</span>: <span style="color:#ae81ff">echo &#34;::set-output name=pr_id::$pr_id&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">steps</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Use the PR ID</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">run</span>: <span style="color:#ae81ff">echo &#34;The PR ID is ${{ steps.get_pr_id.outputs.pr_id }}&#34;</span>
</span></span></code></pre></div><p>GitHub Actions 的某个版本开始，推荐使用新的环境文件语法来设置输出，因为旧的 <code>::</code> 注解命令可能会被弃用</p>
<h2 id="artifacts-新的覆盖久的">artifacts 新的覆盖久的<a hidden class="anchor" aria-hidden="true" href="#artifacts-新的覆盖久的">#</a></h2>
<p>非也，在GitHub Actions中，每次workflow运行时上传的artifacts都会<strong>与那次运行关联</strong>，并且不会自动覆盖之前的artifacts。</p>
<p><code>actions/download-artifact@v4</code> 默认会尝试从与当前运行关联的 workflow 中下载 artifact。如果当前运行没有生成 artifact，它会回退到最近的成功运行中查找同名的 artifact。或者你提供给一个 id。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span>- <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Download artifact from a specific workflow run</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">actions/download-artifact@v4</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">with</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-artifact</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">run_id</span>: <span style="color:#ae81ff">12345678</span>
</span></span></code></pre></div><p>如果没有给定<code> run_id</code>，默认会尝试下载最新的可用工件。【正是所需】</p>
<h2 id="run_id"><code>run_id</code><a hidden class="anchor" aria-hidden="true" href="#run_id">#</a></h2>
<p>github 会给每个新的<strong>工作流运行</strong>分配一个唯一的 <code>run_id</code>。</p>
<h2 id="定义-workflow--jobs">定义： workflow &amp; jobs<a hidden class="anchor" aria-hidden="true" href="#定义-workflow--jobs">#</a></h2>
<p>一个工作流（workflow）由一个或多个作业（jobs）组成.</p>
<p>假设你有一个工作流文件 <code>.github/workflows/my-workflow.yml</code>，它包含两个作业：job1 和 job2。你可以在 job1 中设置一个输出，然后在 job2 中使用这个输出. 需要在job2 中设置： <code>needs: job1</code></p>
<p>然而，如果你有另一个工作流文件 <code>.github/workflows/another-workflow.yml</code>，它不能直接访问 my-workflow.yml 中的作业输出。不同工作流之间的数据传递需要使用其他方法，例如工件（artifacts）、缓存（cache）或者将数据写入到仓库的文件中。</p>
<h2 id="自动pr的作者是谁">自动PR的作者是谁<a hidden class="anchor" aria-hidden="true" href="#自动pr的作者是谁">#</a></h2>
<p>当使用 GitHub Actions 自动创建一个 Pull Request (PR) 时，PR 的作者通常是 GitHub Actions bot，也就是使用的 <code>GITHUB_TOKEN</code> 对应的 GitHub 用户。要在工作流中识别这个作者，你可以直接检查<strong>PR 的元数据</strong></p>
<h2 id="一个-workflow-这一次执行中创建的文件只能在当前执行中访问其他执行访问不了">一个 workflow 这一次执行中创建的文件只能在当前执行中访问，其他执行访问不了<a hidden class="anchor" aria-hidden="true" href="#一个-workflow-这一次执行中创建的文件只能在当前执行中访问其他执行访问不了">#</a></h2>
<p>是的</p>
<p>在GitHub Actions中，每次工作流执行时都是独立的。这意味着每次执行都会创建一个新的运行环境，这个环境是临时的，只在当前的工作流执行期间存在。当工作流执行完成后，所有的运行环境和其中的文件都会被清理掉。如果你在工作流的某次执行中创建了文件，并且希望这些文件在后续的执行中可用，你需要将<strong>文件持久化</strong>。GitHub Actions提供了两种主要的方法来持久化工作流中的数据：</p>
<ol>
<li>上传工件（Artifacts）： 使用 <code>actions/upload-artifact Action</code></li>
<li>缓存依赖项和文件： 使用 <code>actions/cache Action</code></li>
</ol>
<p>工件和缓存都有自己的限制和使用场景。工件主要用于在工作流之间共享数据，而缓存则用于加速工作流的执行，例如通过缓存依赖项来减少安装时间。</p>
<h2 id="artifacts-被存放在哪里">Artifacts 被存放在哪里<a hidden class="anchor" aria-hidden="true" href="#artifacts-被存放在哪里">#</a></h2>
<p>上传的文件被存储在 GitHub Actions 的工件存储中。保留一段时间（默认是90天）。Artifacts 存储在 GitHub 的服务器上，但具体的物理位置并不公开。GitHub 为每个仓库提供了一定量的免费存储空间来存放工件和日志，这些数据存储在 GitHub 的数据中心中。</p>
<h2 id="遇到的语法解释">遇到的语法解释<a hidden class="anchor" aria-hidden="true" href="#遇到的语法解释">#</a></h2>
<ol>
<li>uses 关键字来指定一个动作</li>
<li>with 关键字用于传递参数给动作</li>
<li>${{ }} 是用来插入表达式的语法。这种语法允许你在工作流中动态地引用变量、环境变量、上下文对象和表达式的结果</li>
<li>env: 下的变量 scope 是整个job，与 $GITHUB_ENV 中的变量 scope 一样</li>
</ol>
<h2 id="yml-调用-yml">yml 调用 yml<a hidden class="anchor" aria-hidden="true" href="#yml-调用-yml">#</a></h2>
<p>一个 yml 可以通过 <code>uses: ./.github/workflows/a.yml</code> 来复用另一个 yml 中的 job。</p>
<p>所以如果 b.yml 使用了 a.yml ，那么 b.yml 的 inputs 是 b 的<strong>调用者给的</strong>，a 的 inputs 是 a 的<strong>调用者给的</strong>。</p>
<p>a.yml 中通过:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span><span style="color:#f92672">on</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">workflow_call</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">inputs</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">python_version</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">description</span>: <span style="color:#ae81ff">Python version</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">type</span>: <span style="color:#ae81ff">string</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">default</span>: <span style="color:#e6db74">&#34;3.9&#34;</span>
</span></span></code></pre></div><p>来表示这个值需要调用者提供，在调用者中通过：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span><span style="color:#f92672">uses</span>: <span style="color:#ae81ff">./.github/workflows/a.yml</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">with</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">device</span>: <span style="color:#ae81ff">${{ inputs.python_version }}</span>
</span></span></code></pre></div><h2 id="steps-之间传递信息">steps 之间传递信息<a hidden class="anchor" aria-hidden="true" href="#steps-之间传递信息">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span>- <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Load conda cache</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">id</span>: <span style="color:#ae81ff">conda-cache</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">./.github/actions/load</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">env</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">CACHE_NUMBER</span>: <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">with</span>: <span style="color:#ae81ff">...</span>
</span></span><span style="display:flex;"><span>- <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Update conda env</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">if</span>: <span style="color:#ae81ff">${{ steps.conda-cache.outputs.status == &#39;miss&#39; }} </span> <span style="color:#75715e"># 这里</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">run</span>: <span style="color:#ae81ff">...</span>
</span></span></code></pre></div><h1 id="完整语法和功能见">完整语法和功能见：<a hidden class="anchor" aria-hidden="true" href="#完整语法和功能见">#</a></h1>
<p>这里是workflow的语法：
<a href="https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions">https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions</a></p>
<p>这里是action的语法：
<a href="https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions">https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://ashburnLee.github.io/blog-2-hugo/tags/github-actions/">Github Actions</a></li>
      <li><a href="https://ashburnLee.github.io/blog-2-hugo/tags/cicd/">CICD</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://ashburnLee.github.io/blog-2-hugo/">Junhui&#39;s Journal 2</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
