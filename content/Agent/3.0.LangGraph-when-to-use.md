+++
date = '2025-04-30T12:13:30+08:00'
draft = false
title = '3.0.LangGraph When to Use'
tags = ["Agent","LangGraph","LangChain"]
categories = ["Agent"]
+++

可以用它创建基于 LLM/VLM 模型的应用。



# LangChain VS LangGraph

- LangChain 核心是将多个 LLM 调用和 tools calling 通过链 **Chain 线性拼接**组成有序任务序列，适合顺序性、线性流程的场景。
- LangGraph 是由 LangChain 创建团队推出的一个扩展库，基于 LangChain 构建，但可独立使用。它引入了图结构（StateGraph）来管理任务流程，支持复杂的多角色 Agent 协作、有状态执行、循环分支、条件跳转等高级功能，更适合复杂、动态、带状态的多智能体协同或长期任务管理。

所以：

- LangChain 适合线性任务和单智能体场景。
- LangGraph 适合复杂任务、多智能体协作和状态管理场景。


# LangChain

LangChain 提供了标准的接口，用于将 models 和工具和组件交互，对于检索、LLM 调用、工具调用 很有用。LangChain 中的 classes 可以与 LangGraph 一同使用。

是市场上目前最成熟的 Agent 框架。


# 什么时候使用 LangGraph

你再设计AI Agent时会面临 **控制&自由** 的权衡：自由让你的 LLM 有更多空间进行创造并解决意外问题。；控制确保阿里可预测的行为和可维护。

- CodeAgent 的行为非常自由，可能很难预测，它比使用 JSON 方式更不可控。

- LangGraph 偏向**更多的控制**。如果你的应用程序**涉及一系列需要以特定方式协调的步骤**，并**在每个交叉点做出决策**，那么 LangGraph 就提供了你所需要的结构。

由于 **LLM 最擅长理解文本**，因此在能够回答问题之前，你需要**将其他复杂模态**（图表、表格）转换**为文本**。 ***

简单讲，如果你想**根据每个 step 的输出设计之后的动作流程，并相应地决定下一步执行什么**。那么 LangGraph 是正确的框架！！


# LangGraph 如何工作的？

使用有向图结构来定义您的应用程序的流程。

  - `Nodes`: 代表单个处理步骤，比如工具调用、LLM调用、条件逻辑、获取用户输入等人工干预。
  - `Edges`：定义步骤之间的可能转换
  - `States`: 由用户定义和维护，并在节点执行期间传递。在决定下一个目标节点时，我们查看的是当前状态。


## LangGraph 构建模块

构成 LangGraph 的核心组件，LangGraph 中的应用程序从**START**开始，根据执行情况，流程可能会进入一个函数或另一个函数，直到到达 **END**。

### 1. State

State 是 LangGraph 中的核心概念，它包含了应用程序中的所有内容。它是用户定义的，用户应**仔细思考**应用程序在步骤之间需要**跟踪哪些信息**。

### 2. Nodes

即 Python 函数。它将 State 作为输入，执行某些操作，并返回对状态的更新 new state。

~~~py
def node_1(state):
    print("---Node 1---")
    return {"graph_state": state['graph_state'] +" I am"}

def node_2(state):
    print("---Node 2---")
    return {"graph_state": state['graph_state'] +" happy!"}
~~~

Nodes 可以包含LLM 调用，tools 调用，条件逻辑和人工干预。

### 3. Edges

Edges 连接节点并定义你的图中可能的路径。如下，Edge 根据条件返回可能的两个 Nodes 中的一个。Edge 可以是直接的可以是条件的。

~~~py
import random
from typing import Literal

def decide_mood(state) -> Literal["node_2", "node_3"]:
    
    # Often, we will use state to decide on the next node to visit
    user_input = state['graph_state'] 
    
    # Here, let's just do a 50 / 50 split between nodes 2, 3
    if random.random() < 0.5:

        # 50% of the time, we return Node 2
        return "node_2"
    
    # 50% of the time, we return Node 3
    return "node_3"
~~~

### 4. StateGraph

这是包含**整个工作流的容器**。以 **START** 开始， **END** 结束。

~~~py
from IPython.display import Image, display
from langgraph.graph import StateGraph, START, END

# Build graph
builder = StateGraph(State)
builder.add_node("node_1", node_1)
builder.add_node("node_2", node_2)
builder.add_node("node_3", node_3)

# 将Edge链接，传入起、始位置
builder.add_edge(START, "node_1")
builder.add_conditional_edges("node_1", decide_mood)
builder.add_edge("node_2", END)
builder.add_edge("node_3", END)

# Add
graph = builder.compile()

# View,并且可以可视化工作流：
display(Image(graph.get_graph().draw_mermaid_png()))

# 最后invoke工作流
graph.invoke({"graph_state" : "Hi, this is Lance."})
~~~

所以 LangGraph 的最佳实战是**先定义各个组件，然后组装它们**。
 