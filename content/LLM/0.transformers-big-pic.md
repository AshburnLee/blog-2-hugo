+++
date = '2025-08-31T12:49:35+08:00'
draft = false
title = '0.Transformers Big Pic'
tags = ["LLM"]
categories = ["LLM"]
+++


使用一个新的 Python 环境，安装 轻量级 transformers `pip install "transformers[sentencepiece]"` 除安装主包 transformers 本身，还会安装与 sentencepiece 相关的额外依赖包，这是一种标准的 Python 包管理习惯，方便用户按需安装某些功能所需的附加依赖，而不用下载安装所有不需要的依赖。

HF 生态中的其他库 `transformers`、`Datasets`、`Tokenizers`、`Accelerate` 和 `Hugging Face Hub`


## NLP

LLMs 是 NLP 的一项重大进步，LLM 特点

- 规模很大：参数量从百万到百亿两级
- 通用能力：在没有特定任务训练的情况下执行多个任务
- 情景学习：它可以从 prompt 的实例中学习
- 涌现能力：随规模的增大，会出现意料之外的能力

LLMs 还是有局限

- 幻觉：他会生成不正确的信息
- 不会真正理解：它是纯粹通过统计执行动作的，没有对世界的真正理解
- 上下文窗口：有限
- 计算资源：需要大量计算资源，包括内存资源


## Transformers.pipline

Transformers 库的作用是提供了**创建共享模型**和**使用共享模型**的功能。

最基本的对象是 `pipeline()` 函数。它将模型与其必要的预处理和后处理步骤连接起来。

~~~py
from transformers import pipeline

classifier = pipeline("sentiment-analysis")  # 默认模型是 distilbert
classifier("I've been waiting for a HuggingFace course my whole life.")

[{'label': 'POSITIVE', 'score': 0.9598047137260437}]
~~~

上述，当创建 classifier 对象时，模型会被下载并缓存，没有指明模型则会 load 默认的模型。如果重新运行该命令，将使用缓存的模型，而无需再次下载。默认模型这里是 `distilbert/distilbert-base-uncased-finetuned-sst-2-english`，**不同的 pipline 有不同的 default 模型**。

pipline 是高层API，封装了整个推理过程（包括Tokenization， Embedding， Transformer，和最后的解码为类别标签），将自然语言传递给 classifier 后会执行三个步骤：

1. 将 text 变为模型可以理解的格式
2. pass 给模型
3. 预测结果进行后处理，供人理解


## 不同模态的 pipline

上例的 pipline 是 "sentiment-analysis"，还有更多的 piplines:

- text-generation
- text-classification
- summarization
- translation
- zero-shot-classification
- feature-extraction
- fill-mask
- ner
- question-answering  根据上下文提取信息，非生成信息
- image-to-text
- image-classification
- object-detection
- automatic-speech-recognition
- audio-classification
- text-to-speech
- image-text-to-text


## 例：zero-shot-classification

~~~py
from transformers import pipeline

classifier = pipeline("zero-shot-classification")
classifier(
    "This is a course about the Transformers library",
    candidate_labels=["education", "politics", "business"],
)

{'sequence': 'This is a course about the Transformers library',
 'labels': ['education', 'business', 'politics'],
 'scores': [0.8445963859558105, 0.111976258456707, 0.043427448719739914]}
~~~

即，使用我指定的，模型未见过的标签，进行分类。

## 使用指定模型

上述例子中使用的是默认的模型，也可以从 HF Hub 中选择特定模型用于特定任务。如：

~~~py
from transformers import pipeline

generator = pipeline("text-generation", model="HuggingFaceTB/SmolLM2-360M") # 指定模型
generator(
    "In this course, we will teach you how to",
    max_length=30,
    num_return_sequences=2,
)
~~~

当你点击一个模型时，会看到一个部件，它允许你直接在线试用该模型。这样你可以在下载之前快速测试模型的功能。**避免磁盘空间、代理流量、时间的浪费**。付费模型也可以在页面中试用。 【并没有找到在线使用的地方】


# 通用 Transformer 架构
## Transfer learning & 微调

可以利用一个在**英语上预训练**的模型，然后在一个 arXiv 语料库上进行微调，从而得到一个基于科学/研究的模型。微调只需要有限的数据量：预训练模型所获得的知识会被“迁移”，这就是迁移学习的术语来源。迁移的是权重。

Transfer learning 使模型适应特定任务。

应该总是尝试利用一个预训练模型，一个尽可能接近你所面临任务的模型，并进行微调。

## 通用结构

| ![图片描述](../../pics/transformers_architecture.png) |
|:----------------------:|
| *通用结构* |

`Encoder` (left): The encoder 获取 inputs，然后构建 inputs 的表示。即，构建对输入的理解。

`Decoder` (right): The decoder 应用 Encoder 的表示和其他输入生成目标序列。

## 单独使用

Encoder-only：用于需要理解输入的任务，如句子分类，如上文 zero-shot-classification
Decoder-only：用于文本生成任务

## Attention 层

当处理每个词的表示时，这一层会告诉模型**专注于**传递给它的句子中的某些特定词。

## Architectures 和 Checkpoints

- Architecture 定义了模型中每一层和每一操作
- Checkpoints 是在给定架构中将要加载的**权重**
- Model 是太宽泛的表达，可以指代上述两者


# Transformer 如何工作的

对于 Transformer 模型，其基本思路是相同的。由于其灵活的架构，大多数模型都是Encoder、Decoder或Encoder-Decoder结构的变体。

了解大多数任务遵循相似模式是有帮助的：输入数据通过模型进行处理，输出结果根据特定任务进行解释。差异在于数据如何准备、使用哪种模型架构变体以及如何处理输出。

Language models 通过训练来预测给定上下文时某个词的概率他是**自监督的**。**两种训练方式**：

- **Masked language modeling (MLM)** 被 BERT 等Encoder模型使用，this approach randomly masks some tokens in the input and trains the model to predict the original tokens based on the surrounding context. This allows the model to learn bidirectional context (looking at words both before and after the masked word). 

- **Causal language modeling (CLM)** 被 GPT 等Decoder模型使用，this approach predicts the next token based on all previous tokens in the sequence. The model can only use context from the left (previous tokens) to predict the next token.

语言模型和 Transformers 的关系是：Transformer 是语言模型的实现方式之一，他有自己的架构。但语言模型不限于 Transformer，早起的RNN 和LSTM都可以实现语言模型。


## 语言模型的类型
### 1 Encoder-only models (BERT，DistilBERT，ModernBERT) 

这些模型采用双向方法，从两个方向理解上下文。它们最适合需要**深度理解**文本的任务（分类）。他们有**bi-directional attention** 机制（公式上就是 self-attention，即无掩码的），被称作 **auto-encoding models**。**训练过程**是将输入句子以某种方式**破坏**掉，让模型重建初始语句。

### 2 Decoder-only models (GPT, Llama，Gemma，DeepSeekv3) 

这些模型从左到右处理文本，擅长**文本生成任务**。它们可以完成句子、写文章。Decoder 架构中，在每个阶段，对于给定的词，注意力层只能访问句子中位于其之前的词（之后的词被 Mask 掉），被称作 **auto-regressive models（自回归）**。训练的是预测句子中的下一个词。 所以用于生成任务。

### 3 Encoder-decoder models (T5, BART) 

这些模型结合了两种方法，使用Encoder理解输入，使用Decoder生成输出。用于**从一个序列到另一个序列任务**。

语言模型通常以**自监督方式**（无需人工标注）在大量文本数据上进行**预训练**，然后在特定任务上进行**微调**（即迁移学习）。Allows these models to adapt to **many different NLP tasks** with relatively **small amounts of task-specific data**.【这个表达很精确】


### 1. Text generation 

GPT-2 是一个Decoder 它使用 byte pair encoding (**BPE**)分词法 来 tokenize words 和生成 token embedding. `masked self-attention` 意味着这个模型只会关注于未来的词。他的训练方式完全是 `causal language modeling`。


### 2. Text classification

一个Encoder BEART 是**深度双向性的模型**，通过关注两侧的单词来学习更丰富的文本表示。

它使用 **WordPiece 分词法**来生成文本的 token embeddings。

它使用两个目标进行预训练：**掩码语言建模** & **下一句预测**。第一个任务是输入token中的一部分会**被随机掩码**，模型需要预测这些掩码。这解决了双向性的问题。第二个预训练任务是下一句预测。模型必须预测句子 B 是否紧随句子 A。

### 3. Token classification

在基础 BERT 模型结构最后添加一个 token classification head（通常是一个线性层或MLP）

### 4. Question answering 

在基础 BERT 模型顶部（？）添加一个 span classification head


### 5. Summarization

像 BART 和 T5 这样的 Encoder-Decoder 模型是为摘要任务、翻译任务的**序列到序列**模式设计的。

**Encoder** 与BERT类似，BART 通过破坏输入然后使用Decoder重建输入进行预训练。破坏输入的方式是 **text infilling corruption strategy**。

Encoder的输出**传递给Decoder**，Decoder必须预测被掩盖的token以及Encoder输出中的任何未损坏的token。这为Decoder提供了额外的上下文，以帮助其恢复原始文本。Decoder的输出被传递给language modeling head，该 head 执行线性变换将隐藏状态转换为 logits。在 logits 和标签之间计算交叉熵损失，标签只是向右移动一个位置的token。


### 6. Translation Encoder+Decoder模型

## Transformers 也可以应用于语音和音频、图像以及视频等其他模态
### 1. Whisper 音频数据预训练的Transformer

Encoder处理输入音频。原始音频首先被转换为**对数梅尔谱图**。然后，该谱图通过 Transformer Encoder网络进行处理。

Decoder是一个标准的 Transformer Decoder。

### 2. 视觉任务

有两种方法处理计算机视觉任务：

- 将图像分割成一系列图像块，并使用 Transformer 并行处理。
- 使用现代卷积神经网络，如 ConvNeXT，它依赖于卷积层但采用了现代网络设计。

`ViT` 和 `ConvNeXT` 常用于图像分类。但对于其他视觉任务，如目标检测、分割和深度估计，会了解 DETR、Mask2Former 和 GLPN，这些模型更适合这些任务。

`ViT` 引入的主要变化在于图像如何被输入到 Transformer 中：

- 一张图像被分割成不重叠的方形块，每个块都会转换成向量或块嵌入。
- A learnable embedding 一个特殊的 `[CLS]` token——就像 BERT 一样被添加到补丁嵌入的开头。
- position embeddings 也是需要学习的。
- output，特别是带有 `[CLS]` token的输出，被传递到一个多层感知器头（MLP）



# Transformers 架构

[Transformers 架构类型](#语言模型的类型)，描述了3中架构。

## 当代 LLMs

大多数 LLMs 都采用**仅 Decoder 架构**。这些模型在过去几年中规模和能力都有了显著增长，其中一些最大的模型包含数百亿个参数。现在的LLMs 训练都要经过两个阶段：

1. Pretraining：在大量文本上训练模型，可以预测下一个词。
2. Instruction Tuning：微调模型让他遵循指令，生成有意义的回复。

## Seq2Seq

Encoder-Decoder 模型（序列到序列模型）使用 Transformer 架构的各个部分。在每个阶段，Encoder的注意力层可以访问初始句子中的所有单词（Self-Attention，双向的，无掩码Attention），而 Decoder 的注意力层只能访问输入中给定单词**之前**的单词（文本生成，根据前面的 token 预测下一个 token，其Attention是 Masked Self-Attention，即在self-attention基础上添加了 Mask 用于屏蔽未来的 Token）。


## LLMs 演进

- Attention mechanisms：大多数 Transformer 模型使用**full attention**，即注意力矩阵是方阵。当处理长文本时，这可能会成为**计算瓶颈**。`Longformer` 和 `reformer` 是尝试提高效率的模型，它们使用稀疏版本的注意力矩阵来加速训练。
- LSH attention: Reformer 使用 LSH attention.
- Local attention: Longformer 使用 Local Attention。
- Axial positional encodings： Reformer 使用 Axial Positional Encodings。




# LLM 推理背后的核心概念

推理是使用训练好的 LLM 根据给定的输入提示生成类似人类的文本。语言模型利用其训练知识**逐字地构建响应**。

## Attention 的作用

Attention 赋予了 LLM 理解上下文和生成连贯响应的能力。在预测下一个词时，句子中的每个词**不同等重要**。例如，在句子 “法国的首都是......”中，“法国”和“首都”这两个词对于确定“巴黎”应该紧随其后至关重要。这种专注于相关信息的能力，即 Attention。它是现代 LLMs 区别于前几代语言模型的关键。

### 1 Encoder 的 Attention

Self Attention 公式：

$$\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{Q K^T}{\sqrt{d_k}}\right) V$$

- $ Q, K, V $: 查询、键、值向量，从输入嵌入（embedding）计算。
- $ d_k $: 键向量的维度。


### 2 Decoder 的 Attention

在 Self-Atterntion 基础上添加因果掩码（Causal Mask）：

$$\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{Q K^T}{\sqrt{d_k}} + M\right) V$$

- $ Q, K, V $: 查询（Query）、键（Key）、值（Value）向量，从输入嵌入计算。
- $ d_k $: 键向量的维度（通常为 64 或 128）。
- $ M $: 掩码矩阵（Causal Mask），上三角矩阵（不含对角线）值为负无穷（-inf），其余为 0。
- $ \text{softmax} $: 归一化注意力分数。


### 3 Multi-Head Attention

在实现上，每种Attention 都采用 Mult-Head Attention 方式，即将 $ Q, K, V $ 分割为多个子空间（heads，如 8 或 12 头），独立计算注意力，然后将结果拼接起来。$ \text{MultiHead}(Q, K, V) = \text{Concat}(\text{head}_1, \dots, \text{head}_h) W^O $

增强表达能力。


## Context Length （ Attention Span ）

`context length` 是生成一次响应时需要的大 token 数量（包括输入和输出 的所有tokens），可理解为模型工作时的内存大小。这个长度受限于多种因素：

模型的架构和大小、可用的硬件资源、输入和期望输出的复杂性。

通常不同的模型被设计成具有不同的上下文长度，以在能力和效率之间取得平衡。context length 直接和计算复杂度相关。

Attention 需要计算每个token 对其他token 的关联，生成一个大小为 $n \times n$ 的Attention 矩阵（其中 $n$ 是context length）。因此，内存需求随 $n^2$ 增长。

## Prompting

我们会以某种方式组织输入，引导 LLM 生成期望的输出。由于模型的主要任务是通过分析**每个输入 token 的重要性**来预测下一个 token，因此输入序列的措辞变得重要。

# LLMs 生成文本 过程 & 策略
## LLMs 实际生成文本的过程有两阶段

1. **The Prefill Phase**：是准备阶段包括一下。这个阶段计算密集，因为它需要一次性处理所有输入token，类似做阅读理解之前你要将文章通读。
    - `Tokenization`：将输入文本转换为 token（可以将其视为模型理解的基本构建块）
    - `Embedding Conversion`：将这些 token 转换为能够捕捉其含义的数值表示
    - `Initial Processing`：将这些嵌入通过模型的神经网络进行处理，以创建丰富的上下文理解

2. **The Decode Phase**：解码阶段是成生 text 的地方。模型以 `autoregressive process` 的过程逐个生成 token。每一个 token 的生成都依赖于前面生成的token。对于每一个 token 的生成，会有几个步骤：这个阶段是内存密集型的，因为模型需要跟踪所有先前生成的token及其关系。
    - `Attention Computation`：回顾所有先前的 token 以理解上下文
    - `Probability Calculation`：确定每个可能下一个词的几率
    - `Token Selection 采样`：根据这些概率选择下一个词
    - `Continuation Check`。决定是否继续或停止生成

## 模型如何选择 token 呢？这就是 Sampling Strategies

那么有哪些方法控制上述 生成文本 的过程呢？哪些方式来控制这个生成过程？模型是如何选择 token 的？即如何选择哪个token 作为生成内容的下一个。有以下方式：


### 1. 从概率到 Token 的选择

当模型需要选择下一个token时，它从词汇表中每个词的原始概率（称为 `logits`）开始。如何讲这些概率转换为选择呢？过程：

| ![图片描述](../../pics/prb2select.png) |
|:----------------------:|
| *通过Sampler chain从概率到Token的选择* |

- `Raw Logits`: 模型对每个可能的下一个单词的**初步直觉**，就是模型的直接输出。
- `Temperature Control`: 设置值更高（>1.0）会让选择更随机和富有创意; 设置值更低（<1.0）会让选择更专注和确定。
- `Top-p (Nucleus) Sampling`: 不可能考虑所有可能的单词，策略是只看那些累计概率达到我们**选定阈值**（例如，前 90%）的最可能单词。
- `Top-k Filtering`: 一种替代方法，我们只考虑 k 个最可能的下一个词。


### 2. Managing Repetition: Keeping Output Fresh

LLMs 的一大常见挑战是它们倾向于重复自己。复读机？为解决这个问题，使用两种类型的惩罚：

- **Presence Penalty**：任何之前出现过的 token 施加固定惩罚，无论出现次数多少。这有助于防止模型重复使用相同的词语。
- **Frequency Penalty**：一个 token 出现得越频繁，再次被选中的可能性就越小。

这种惩罚策略在模型的早期使用，用于调整原始概率，然后再应用其他采样策略。可以将其视为温和的推动力，鼓励模型探索新的词汇。

### 3. Controlling Generation Length: Setting Boundaries

我们需要方法来控制我们的 LLM 生成多少文本，总不能无限长。有几种方式：

- **Token Limits**: 设置最小和最大 token 数量
- **Stop Sequences**: 定义特定的模式来指示生成的结束
- **End-of-Sequence Detection**: 让模型自然地结束其回应


### 4. Beam Search: Looking Ahead for Better Coherence

之前的策略都是一次一个token的，Beam Search 是一种更整体的策略。它不是在每个步骤中只做出一个选择，而是同时探索多个可能的路径。

| ![图片描述](../../pics/beam-search.png) |
|:----------------------:|
| *beam search process* |

过程:

1. 每一步都保持多个候选序列（通常为 5-10 个）
2. 对每个候选序列，计算下一个 token 的概率
3. 仅保留最有潜力的序列和下一个 token 的组合
4. 继续此过程，直到达到期望 length 或停止条件
5. 选择概率最高的序列

这种方法通常能生成更连贯、语法更正确的文本，但它需要比简单方法更多的计算资源。


## 衡量模型的关键性能指标

- 首次令牌时间（Time to First Token，TTFT）：你能多快获得第一个响应？这对**用户体验**至关重要，主要受预填充阶段的影响。
- 输出令牌时间（Time Per Output Token，TPOT）：你能多快生成后续令牌？这决定了**整体生成速度**。
- Throughput 吞吐量：你能同时处理多少个请求？这影响**扩展性和成本**效率。
- VRAM 使用量：你需要多少 GPU 内存？这通常是实际应用中的**主要限制**因素。


## 挑战：The Context Length Challenge

LLM 推理中最显著的挑战之一是有效管理上下文长度。更长的上下文能提供更多信息，但也伴随着巨大的成本：

- 内存使用：随 context length 度呈指数级增长，Attention 矩阵大小 $ n^2 $
- 处理速度：随 context length 度呈线性级下降
- 资源分配：需要仔细平衡 VRAM 使用


## 解决方法：The KV Cache Optimization

优化之一是 KV（键值）缓存。这种技术通过存储和重用中间计算结果显著提高了推理速度。这种优化 减少重复计算、提升生成速度、使**长上下文生成**变得实用。

详见 [KV Cache in llama.cpp]({{< ref "../LLM/5.10-llama.cpp-Attention-kv-cache.md" >}})


# Bias

在大规模数据上进行预训练，研究人员通常会抓取他们能找到的所有内容，既包括了互联网上可用的最好内容，也包括了最糟糕的内容。

BERT 是少数几个没有通过从互联网上抓取数据构建的 Transformer 模型之一，它是使用表面上看起来中性的数据，这些训练数据来自**英语维基百科**和 **BookCorpus** 数据集。

原始模型很容易生成性别歧视、种族歧视或恐同内容。在你自己的数据上微调模型并不能消除这种内在偏见。


---

Stay curious and keep asking questions! 🧠✨

